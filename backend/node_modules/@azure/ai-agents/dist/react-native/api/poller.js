// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { delay } from "@azure/core-util";
const DEFAULT_POLL_INTERVAL_IN_MS = 1000;
/**
 * Deserializes the state from a serialized string
 */
export function deserializeState(serializedState) {
    try {
        return JSON.parse(serializedState).state;
    }
    catch (e) {
        throw new Error(`Unable to deserialize input state: ${serializedState}`);
    }
}
export function createPoller({ initOperation, pollOperation, getOperationStatus, getOperationError, intervalInMs, resumeFrom, }) {
    let statePromise;
    let state;
    if (resumeFrom) {
        state = deserializeState(resumeFrom);
        statePromise = Promise.resolve(state);
    }
    else {
        statePromise = initOperation().then((result) => {
            state = {
                result,
                status: getOperationStatus(result),
            };
            return state;
        });
    }
    let resultPromise;
    const abortController = new AbortController();
    const handlers = new Map();
    const handleProgressEvents = async () => handlers.forEach((h) => h(state));
    const currentPollIntervalInMs = intervalInMs ?? DEFAULT_POLL_INTERVAL_IN_MS;
    const poller = {
        get operationState() {
            return state;
        },
        get result() {
            return state?.result;
        },
        get isDone() {
            return ["succeeded", "failed", "canceled"].includes(state?.status ?? "");
        },
        onProgress: (callback) => {
            const s = Symbol();
            handlers.set(s, callback);
            return () => handlers.delete(s);
        },
        serialize: async () => {
            await statePromise;
            return JSON.stringify({
                state,
            });
        },
        submitted: async () => {
            await statePromise;
        },
        pollUntilDone: async (pollOptions) => {
            resultPromise ??= (async () => {
                await statePromise;
                if (!state) {
                    throw new Error("Poller is not initialized");
                }
                const { abortSignal: inputAbortSignal } = pollOptions || {};
                function abortListener() {
                    abortController.abort();
                }
                const abortSignal = abortController.signal;
                if (inputAbortSignal?.aborted) {
                    abortController.abort();
                }
                else if (!abortSignal.aborted) {
                    inputAbortSignal?.addEventListener("abort", abortListener, { once: true });
                }
                try {
                    if (!poller.isDone) {
                        await poller.poll({ abortSignal });
                        while (!poller.isDone) {
                            await delay(currentPollIntervalInMs, { abortSignal });
                            await poller.poll({ abortSignal });
                        }
                    }
                }
                finally {
                    inputAbortSignal?.removeEventListener("abort", abortListener);
                }
                switch (state.status) {
                    case "succeeded":
                        return poller.result;
                    case "canceled":
                        throw new Error("Operation cancelled");
                    case "failed":
                        throw state.error ?? new Error("Operation failed");
                    case "notStarted":
                    case "running":
                        throw new Error("Polling completed without succeeding or failing");
                }
            })().finally(() => {
                resultPromise = undefined;
            });
            return resultPromise;
        },
        async poll(pollOptions) {
            // Check state before polling
            await statePromise;
            if (!state) {
                throw new Error("Poller is not initialized");
            }
            switch (state.status) {
                case "succeeded":
                    return state;
                case "canceled":
                    throw new Error("Operation was canceled");
                case "failed":
                    throw state.error ?? new Error("Operation failed");
            }
            // Poll
            if (pollOptions?.abortSignal?.aborted) {
                throw new Error("Operation aborted");
            }
            // Make sure we have a result to poll with
            if (!state.result) {
                throw new Error("Cannot poll with undefined result");
            }
            const result = await pollOperation(state.result);
            state = {
                result,
                status: getOperationStatus(result),
                error: getOperationError ? getOperationError(result) : undefined,
            };
            await handleProgressEvents();
            switch (state.status) {
                case "canceled":
                    throw new Error("Operation was canceled");
                case "failed":
                    throw state.error ?? new Error("Operation failed");
            }
            return state;
        },
        then(onfulfilled, onrejected) {
            return poller.pollUntilDone().then(onfulfilled, onrejected);
        },
        catch(onrejected) {
            return poller.pollUntilDone().catch(onrejected);
        },
        finally(onfinally) {
            return poller.pollUntilDone().finally(onfinally);
        },
        [Symbol.toStringTag]: "Poller",
    };
    return poller;
}
//# sourceMappingURL=poller.js.map