"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports._createThreadAndRunSend = _createThreadAndRunSend;
exports._createThreadAndRunDeserialize = _createThreadAndRunDeserialize;
exports.createThreadAndRun = createThreadAndRun;
exports._deleteAgentSend = _deleteAgentSend;
exports._deleteAgentDeserialize = _deleteAgentDeserialize;
exports.deleteAgent = deleteAgent;
exports._updateAgentSend = _updateAgentSend;
exports._updateAgentDeserialize = _updateAgentDeserialize;
exports.updateAgent = updateAgent;
exports._getAgentSend = _getAgentSend;
exports._getAgentDeserialize = _getAgentDeserialize;
exports.getAgent = getAgent;
exports._listAgentsSend = _listAgentsSend;
exports._listAgentsDeserialize = _listAgentsDeserialize;
exports.listAgents = listAgents;
exports._createAgentSend = _createAgentSend;
exports._createAgentDeserialize = _createAgentDeserialize;
exports.createAgent = createAgent;
exports.createRunStreaming = createRunStreaming;
exports.createThreadAndRunStreaming = createThreadAndRunStreaming;
exports.submitToolOutputsToRunStreaming = submitToolOutputsToRunStreaming;
const models_js_1 = require("../models/models.js");
const pagingHelpers_js_1 = require("../static-helpers/pagingHelpers.js");
const urlTemplate_js_1 = require("../static-helpers/urlTemplate.js");
const core_client_1 = require("@azure-rest/core-client");
const core_sse_1 = require("@azure/core-sse");
const core_util_1 = require("@azure/core-util");
const logger_js_1 = require("../logger.js");
const operations_js_1 = require("./runs/operations.js");
function _createThreadAndRunSend(context, assistantId, options = { requestOptions: {} }) {
    const path = (0, urlTemplate_js_1.expandUrlTemplate)("/threads/runs{?api-version}", {
        "api-version": context.apiVersion,
    }, {
        allowReserved: options?.requestOptions?.skipUrlEncoding,
    });
    return context.path(path).post({
        ...(0, core_client_1.operationOptionsToRequestParameters)(options),
        contentType: "application/json",
        headers: {
            accept: "application/json",
            ...options.requestOptions?.headers,
        },
        body: {
            assistant_id: assistantId,
            thread: !options?.thread
                ? options?.thread
                : (0, models_js_1.agentThreadCreationOptionsSerializer)(options?.thread),
            model: options?.model,
            instructions: options?.instructions,
            tools: !options?.tools ? options?.tools : (0, models_js_1.toolDefinitionUnionArraySerializer)(options?.tools),
            tool_resources: !options?.toolResources
                ? options?.toolResources
                : (0, models_js_1.toolResourcesSerializer)(options?.toolResources),
            stream: options?.stream,
            temperature: options?.temperature,
            top_p: options?.topP,
            max_prompt_tokens: options?.maxPromptTokens,
            max_completion_tokens: options?.maxCompletionTokens,
            truncation_strategy: !options?.truncationStrategy
                ? options?.truncationStrategy
                : (0, models_js_1.truncationObjectSerializer)(options?.truncationStrategy),
            tool_choice: !options?.toolChoice
                ? options?.toolChoice
                : (0, models_js_1.agentsToolChoiceOptionSerializer)(options?.toolChoice),
            response_format: !options?.responseFormat
                ? options?.responseFormat
                : (0, models_js_1.agentsResponseFormatOptionSerializer)(options?.responseFormat),
            parallel_tool_calls: options?.parallelToolCalls,
            metadata: options?.metadata,
        },
    });
}
async function _createThreadAndRunDeserialize(result) {
    const expectedStatuses = ["200"];
    if (!expectedStatuses.includes(result.status)) {
        const error = (0, core_client_1.createRestError)(result);
        error.details = (0, models_js_1.agentV1ErrorDeserializer)(result.body);
        throw error;
    }
    return (0, models_js_1.threadRunDeserializer)(result.body);
}
/** Creates a new agent thread and immediately starts a run using that new thread. */
function createThreadAndRun(context, assistantId, options = { requestOptions: {} }) {
    async function executeCreateThreadAndRun() {
        const result = await _createThreadAndRunSend(context, assistantId, options);
        return _createThreadAndRunDeserialize(result);
    }
    return {
        then: function (onFulfilled, onRejected) {
            return executeCreateThreadAndRun().then(onFulfilled, onRejected).catch(onRejected);
        },
        async stream() {
            return createThreadAndRunStreaming(context, assistantId, options);
        },
    };
}
function _deleteAgentSend(context, assistantId, options = { requestOptions: {} }) {
    const path = (0, urlTemplate_js_1.expandUrlTemplate)("/assistants/{assistantId}{?api-version}", {
        assistantId: assistantId,
        "api-version": context.apiVersion,
    }, {
        allowReserved: options?.requestOptions?.skipUrlEncoding,
    });
    return context.path(path).delete({
        ...(0, core_client_1.operationOptionsToRequestParameters)(options),
        headers: {
            accept: "application/json",
            ...options.requestOptions?.headers,
        },
    });
}
async function _deleteAgentDeserialize(result) {
    const expectedStatuses = ["200"];
    if (!expectedStatuses.includes(result.status)) {
        const error = (0, core_client_1.createRestError)(result);
        error.details = (0, models_js_1.agentV1ErrorDeserializer)(result.body);
        throw error;
    }
    return (0, models_js_1.agentDeletionStatusDeserializer)(result.body);
}
/** Deletes an agent. */
async function deleteAgent(context, assistantId, options = { requestOptions: {} }) {
    const result = await _deleteAgentSend(context, assistantId, options);
    return _deleteAgentDeserialize(result);
}
function _updateAgentSend(context, assistantId, options = { requestOptions: {} }) {
    const path = (0, urlTemplate_js_1.expandUrlTemplate)("/assistants/{assistantId}{?api-version}", {
        assistantId: assistantId,
        "api-version": context.apiVersion,
    }, {
        allowReserved: options?.requestOptions?.skipUrlEncoding,
    });
    return context.path(path).post({
        ...(0, core_client_1.operationOptionsToRequestParameters)(options),
        contentType: "application/json",
        headers: {
            accept: "application/json",
            ...options.requestOptions?.headers,
        },
        body: {
            model: options?.model,
            name: options?.name,
            description: options?.description,
            instructions: options?.instructions,
            tools: !options?.tools ? options?.tools : (0, models_js_1.toolDefinitionUnionArraySerializer)(options?.tools),
            tool_resources: !options?.toolResources
                ? options?.toolResources
                : (0, models_js_1.toolResourcesSerializer)(options?.toolResources),
            temperature: options?.temperature,
            top_p: options?.topP,
            response_format: !options?.responseFormat
                ? options?.responseFormat
                : (0, models_js_1.agentsResponseFormatOptionSerializer)(options?.responseFormat),
            metadata: options?.metadata,
        },
    });
}
async function _updateAgentDeserialize(result) {
    const expectedStatuses = ["200"];
    if (!expectedStatuses.includes(result.status)) {
        const error = (0, core_client_1.createRestError)(result);
        error.details = (0, models_js_1.agentV1ErrorDeserializer)(result.body);
        throw error;
    }
    return (0, models_js_1.agentDeserializer)(result.body);
}
/** Modifies an existing agent. */
async function updateAgent(context, assistantId, options = { requestOptions: {} }) {
    const result = await _updateAgentSend(context, assistantId, options);
    return _updateAgentDeserialize(result);
}
function _getAgentSend(context, assistantId, options = { requestOptions: {} }) {
    const path = (0, urlTemplate_js_1.expandUrlTemplate)("/assistants/{assistantId}{?api-version}", {
        assistantId: assistantId,
        "api-version": context.apiVersion,
    }, {
        allowReserved: options?.requestOptions?.skipUrlEncoding,
    });
    return context.path(path).get({
        ...(0, core_client_1.operationOptionsToRequestParameters)(options),
        headers: {
            accept: "application/json",
            ...options.requestOptions?.headers,
        },
    });
}
async function _getAgentDeserialize(result) {
    const expectedStatuses = ["200"];
    if (!expectedStatuses.includes(result.status)) {
        const error = (0, core_client_1.createRestError)(result);
        error.details = (0, models_js_1.agentV1ErrorDeserializer)(result.body);
        throw error;
    }
    return (0, models_js_1.agentDeserializer)(result.body);
}
/** Retrieves an existing agent. */
async function getAgent(context, assistantId, options = { requestOptions: {} }) {
    const result = await _getAgentSend(context, assistantId, options);
    return _getAgentDeserialize(result);
}
function _listAgentsSend(context, options = { requestOptions: {} }) {
    const path = (0, urlTemplate_js_1.expandUrlTemplate)("/assistants{?api-version,limit,order,after,before}", {
        "api-version": context.apiVersion,
        limit: options?.limit,
        order: options?.order,
        after: options?.after,
        before: options?.before,
    }, {
        allowReserved: options?.requestOptions?.skipUrlEncoding,
    });
    return context.path(path).get({
        ...(0, core_client_1.operationOptionsToRequestParameters)(options),
        headers: {
            accept: "application/json",
            ...options.requestOptions?.headers,
        },
    });
}
async function _listAgentsDeserialize(result) {
    const expectedStatuses = ["200"];
    if (!expectedStatuses.includes(result.status)) {
        const error = (0, core_client_1.createRestError)(result);
        error.details = (0, models_js_1.agentV1ErrorDeserializer)(result.body);
        throw error;
    }
    return (0, models_js_1._agentsPagedResultAgentDeserializer)(result.body);
}
/** Gets a list of agents that were previously created. */
function listAgents(context, options = { requestOptions: {} }) {
    return (0, pagingHelpers_js_1.buildPagedAsyncIterator)(context, () => _listAgentsSend(context, options), _listAgentsDeserialize, ["200"], { itemName: "data" });
}
function _createAgentSend(context, model, options = { requestOptions: {} }) {
    const path = (0, urlTemplate_js_1.expandUrlTemplate)("/assistants{?api-version}", {
        "api-version": context.apiVersion,
    }, {
        allowReserved: options?.requestOptions?.skipUrlEncoding,
    });
    return context.path(path).post({
        ...(0, core_client_1.operationOptionsToRequestParameters)(options),
        contentType: "application/json",
        headers: {
            accept: "application/json",
            ...options.requestOptions?.headers,
        },
        body: {
            model: model,
            name: options?.name,
            description: options?.description,
            instructions: options?.instructions,
            tools: !options?.tools ? options?.tools : (0, models_js_1.toolDefinitionUnionArraySerializer)(options?.tools),
            tool_resources: !options?.toolResources
                ? options?.toolResources
                : (0, models_js_1.toolResourcesSerializer)(options?.toolResources),
            temperature: options?.temperature,
            top_p: options?.topP,
            response_format: !options?.responseFormat
                ? options?.responseFormat
                : (0, models_js_1.agentsResponseFormatOptionSerializer)(options?.responseFormat),
            metadata: options?.metadata,
        },
    });
}
async function _createAgentDeserialize(result) {
    const expectedStatuses = ["200"];
    if (!expectedStatuses.includes(result.status)) {
        const error = (0, core_client_1.createRestError)(result);
        error.details = (0, models_js_1.agentV1ErrorDeserializer)(result.body);
        throw error;
    }
    return (0, models_js_1.agentDeserializer)(result.body);
}
/** Creates a new agent. */
async function createAgent(context, model, options = { requestOptions: {} }) {
    const result = await _createAgentSend(context, model, options);
    return _createAgentDeserialize(result);
}
function createAgentStream(stream) {
    const asyncIterator = toAsyncIterable(stream);
    const asyncDisposable = stream;
    return Object.assign(asyncIterator, asyncDisposable);
}
async function* toAsyncIterable(stream) {
    for await (const event of stream) {
        const data = deserializeEventData(event);
        yield { data: data, event: event.event };
    }
}
function deserializeEventData(event) {
    try {
        const jsonData = JSON.parse(event.data);
        if (Object.values(models_js_1.RunStepStreamEvent).includes(event.event)) {
            if (event.event === models_js_1.RunStepStreamEvent.ThreadRunStepDelta) {
                return (0, models_js_1.runStepDeltaChunkDeserializer)(jsonData);
            }
            return (0, models_js_1.runStepDeserializer)(jsonData);
        }
        if (Object.values(models_js_1.MessageStreamEvent).includes(event.event)) {
            if (event.event === models_js_1.MessageStreamEvent.ThreadMessageDelta) {
                return (0, models_js_1.messageDeltaChunkDeserializer)(jsonData);
            }
            return (0, models_js_1.threadMessageDeserializer)(jsonData);
        }
        if (Object.values(models_js_1.RunStreamEvent).includes(event.event)) {
            return (0, models_js_1.threadRunDeserializer)(jsonData);
        }
        return jsonData;
    }
    catch (ex) {
        logger_js_1.logger.error(`Failed to parse event data  ${event.event} - error: ${ex}`);
        return event.data;
    }
}
async function processStream(streamResponse) {
    const expectedStatuses = ["200"];
    const result = core_util_1.isNodeLike
        ? await streamResponse.asNodeStream()
        : await streamResponse.asBrowserStream();
    if (!expectedStatuses.includes(result.status)) {
        throw (0, core_client_1.createRestError)(result);
    }
    if (!result.body) {
        throw new Error("No body in response");
    }
    const stream = core_util_1.isNodeLike
        ? (0, core_sse_1.createSseStream)(result.body)
        : (0, core_sse_1.createSseStream)(result.body);
    return createAgentStream(stream);
}
/** Create a run and stream the events */
async function createRunStreaming(context, assistantId, threadId, options = { requestOptions: {} }) {
    const streamOptions = { ...options, stream: true };
    return processStream((0, operations_js_1._createRunSend)(context, threadId, assistantId, streamOptions));
}
/** Create a thread and run and stream the events */
async function createThreadAndRunStreaming(context, assistantId, options = { requestOptions: {} }) {
    const streamOptions = { ...options, stream: true };
    return processStream(_createThreadAndRunSend(context, assistantId, streamOptions));
}
async function submitToolOutputsToRunStreaming(context, threadId, runId, toolOutputs, options = { requestOptions: {} }) {
    const streamOptions = { ...options, stream: true };
    return processStream((0, operations_js_1._submitToolOutputsToRunSend)(context, threadId, runId, toolOutputs, streamOptions));
}
//# sourceMappingURL=operations.js.map