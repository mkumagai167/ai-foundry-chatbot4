// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { toolResourcesSerializer, toolDefinitionUnionArraySerializer, agentsResponseFormatOptionSerializer, agentDeserializer, agentV1ErrorDeserializer, _agentsPagedResultAgentDeserializer, agentDeletionStatusDeserializer, agentThreadCreationOptionsSerializer, truncationObjectSerializer, agentsToolChoiceOptionSerializer, threadRunDeserializer, MessageStreamEvent, RunStepStreamEvent, RunStreamEvent, messageDeltaChunkDeserializer, runStepDeltaChunkDeserializer, runStepDeserializer, threadMessageDeserializer, } from "../models/models.js";
import { buildPagedAsyncIterator } from "../static-helpers/pagingHelpers.js";
import { expandUrlTemplate } from "../static-helpers/urlTemplate.js";
import { createRestError, operationOptionsToRequestParameters } from "@azure-rest/core-client";
import { createSseStream } from "@azure/core-sse";
import { isNodeLike } from "@azure/core-util";
import { logger } from "../logger.js";
import { _createRunSend, _submitToolOutputsToRunSend } from "./runs/operations.js";
export function _createThreadAndRunSend(context, assistantId, options = { requestOptions: {} }) {
    const path = expandUrlTemplate("/threads/runs{?api-version}", {
        "api-version": context.apiVersion,
    }, {
        allowReserved: options?.requestOptions?.skipUrlEncoding,
    });
    return context.path(path).post({
        ...operationOptionsToRequestParameters(options),
        contentType: "application/json",
        headers: {
            accept: "application/json",
            ...options.requestOptions?.headers,
        },
        body: {
            assistant_id: assistantId,
            thread: !options?.thread
                ? options?.thread
                : agentThreadCreationOptionsSerializer(options?.thread),
            model: options?.model,
            instructions: options?.instructions,
            tools: !options?.tools ? options?.tools : toolDefinitionUnionArraySerializer(options?.tools),
            tool_resources: !options?.toolResources
                ? options?.toolResources
                : toolResourcesSerializer(options?.toolResources),
            stream: options?.stream,
            temperature: options?.temperature,
            top_p: options?.topP,
            max_prompt_tokens: options?.maxPromptTokens,
            max_completion_tokens: options?.maxCompletionTokens,
            truncation_strategy: !options?.truncationStrategy
                ? options?.truncationStrategy
                : truncationObjectSerializer(options?.truncationStrategy),
            tool_choice: !options?.toolChoice
                ? options?.toolChoice
                : agentsToolChoiceOptionSerializer(options?.toolChoice),
            response_format: !options?.responseFormat
                ? options?.responseFormat
                : agentsResponseFormatOptionSerializer(options?.responseFormat),
            parallel_tool_calls: options?.parallelToolCalls,
            metadata: options?.metadata,
        },
    });
}
export async function _createThreadAndRunDeserialize(result) {
    const expectedStatuses = ["200"];
    if (!expectedStatuses.includes(result.status)) {
        const error = createRestError(result);
        error.details = agentV1ErrorDeserializer(result.body);
        throw error;
    }
    return threadRunDeserializer(result.body);
}
/** Creates a new agent thread and immediately starts a run using that new thread. */
export function createThreadAndRun(context, assistantId, options = { requestOptions: {} }) {
    async function executeCreateThreadAndRun() {
        const result = await _createThreadAndRunSend(context, assistantId, options);
        return _createThreadAndRunDeserialize(result);
    }
    return {
        then: function (onFulfilled, onRejected) {
            return executeCreateThreadAndRun().then(onFulfilled, onRejected).catch(onRejected);
        },
        async stream() {
            return createThreadAndRunStreaming(context, assistantId, options);
        },
    };
}
export function _deleteAgentSend(context, assistantId, options = { requestOptions: {} }) {
    const path = expandUrlTemplate("/assistants/{assistantId}{?api-version}", {
        assistantId: assistantId,
        "api-version": context.apiVersion,
    }, {
        allowReserved: options?.requestOptions?.skipUrlEncoding,
    });
    return context.path(path).delete({
        ...operationOptionsToRequestParameters(options),
        headers: {
            accept: "application/json",
            ...options.requestOptions?.headers,
        },
    });
}
export async function _deleteAgentDeserialize(result) {
    const expectedStatuses = ["200"];
    if (!expectedStatuses.includes(result.status)) {
        const error = createRestError(result);
        error.details = agentV1ErrorDeserializer(result.body);
        throw error;
    }
    return agentDeletionStatusDeserializer(result.body);
}
/** Deletes an agent. */
export async function deleteAgent(context, assistantId, options = { requestOptions: {} }) {
    const result = await _deleteAgentSend(context, assistantId, options);
    return _deleteAgentDeserialize(result);
}
export function _updateAgentSend(context, assistantId, options = { requestOptions: {} }) {
    const path = expandUrlTemplate("/assistants/{assistantId}{?api-version}", {
        assistantId: assistantId,
        "api-version": context.apiVersion,
    }, {
        allowReserved: options?.requestOptions?.skipUrlEncoding,
    });
    return context.path(path).post({
        ...operationOptionsToRequestParameters(options),
        contentType: "application/json",
        headers: {
            accept: "application/json",
            ...options.requestOptions?.headers,
        },
        body: {
            model: options?.model,
            name: options?.name,
            description: options?.description,
            instructions: options?.instructions,
            tools: !options?.tools ? options?.tools : toolDefinitionUnionArraySerializer(options?.tools),
            tool_resources: !options?.toolResources
                ? options?.toolResources
                : toolResourcesSerializer(options?.toolResources),
            temperature: options?.temperature,
            top_p: options?.topP,
            response_format: !options?.responseFormat
                ? options?.responseFormat
                : agentsResponseFormatOptionSerializer(options?.responseFormat),
            metadata: options?.metadata,
        },
    });
}
export async function _updateAgentDeserialize(result) {
    const expectedStatuses = ["200"];
    if (!expectedStatuses.includes(result.status)) {
        const error = createRestError(result);
        error.details = agentV1ErrorDeserializer(result.body);
        throw error;
    }
    return agentDeserializer(result.body);
}
/** Modifies an existing agent. */
export async function updateAgent(context, assistantId, options = { requestOptions: {} }) {
    const result = await _updateAgentSend(context, assistantId, options);
    return _updateAgentDeserialize(result);
}
export function _getAgentSend(context, assistantId, options = { requestOptions: {} }) {
    const path = expandUrlTemplate("/assistants/{assistantId}{?api-version}", {
        assistantId: assistantId,
        "api-version": context.apiVersion,
    }, {
        allowReserved: options?.requestOptions?.skipUrlEncoding,
    });
    return context.path(path).get({
        ...operationOptionsToRequestParameters(options),
        headers: {
            accept: "application/json",
            ...options.requestOptions?.headers,
        },
    });
}
export async function _getAgentDeserialize(result) {
    const expectedStatuses = ["200"];
    if (!expectedStatuses.includes(result.status)) {
        const error = createRestError(result);
        error.details = agentV1ErrorDeserializer(result.body);
        throw error;
    }
    return agentDeserializer(result.body);
}
/** Retrieves an existing agent. */
export async function getAgent(context, assistantId, options = { requestOptions: {} }) {
    const result = await _getAgentSend(context, assistantId, options);
    return _getAgentDeserialize(result);
}
export function _listAgentsSend(context, options = { requestOptions: {} }) {
    const path = expandUrlTemplate("/assistants{?api-version,limit,order,after,before}", {
        "api-version": context.apiVersion,
        limit: options?.limit,
        order: options?.order,
        after: options?.after,
        before: options?.before,
    }, {
        allowReserved: options?.requestOptions?.skipUrlEncoding,
    });
    return context.path(path).get({
        ...operationOptionsToRequestParameters(options),
        headers: {
            accept: "application/json",
            ...options.requestOptions?.headers,
        },
    });
}
export async function _listAgentsDeserialize(result) {
    const expectedStatuses = ["200"];
    if (!expectedStatuses.includes(result.status)) {
        const error = createRestError(result);
        error.details = agentV1ErrorDeserializer(result.body);
        throw error;
    }
    return _agentsPagedResultAgentDeserializer(result.body);
}
/** Gets a list of agents that were previously created. */
export function listAgents(context, options = { requestOptions: {} }) {
    return buildPagedAsyncIterator(context, () => _listAgentsSend(context, options), _listAgentsDeserialize, ["200"], { itemName: "data" });
}
export function _createAgentSend(context, model, options = { requestOptions: {} }) {
    const path = expandUrlTemplate("/assistants{?api-version}", {
        "api-version": context.apiVersion,
    }, {
        allowReserved: options?.requestOptions?.skipUrlEncoding,
    });
    return context.path(path).post({
        ...operationOptionsToRequestParameters(options),
        contentType: "application/json",
        headers: {
            accept: "application/json",
            ...options.requestOptions?.headers,
        },
        body: {
            model: model,
            name: options?.name,
            description: options?.description,
            instructions: options?.instructions,
            tools: !options?.tools ? options?.tools : toolDefinitionUnionArraySerializer(options?.tools),
            tool_resources: !options?.toolResources
                ? options?.toolResources
                : toolResourcesSerializer(options?.toolResources),
            temperature: options?.temperature,
            top_p: options?.topP,
            response_format: !options?.responseFormat
                ? options?.responseFormat
                : agentsResponseFormatOptionSerializer(options?.responseFormat),
            metadata: options?.metadata,
        },
    });
}
export async function _createAgentDeserialize(result) {
    const expectedStatuses = ["200"];
    if (!expectedStatuses.includes(result.status)) {
        const error = createRestError(result);
        error.details = agentV1ErrorDeserializer(result.body);
        throw error;
    }
    return agentDeserializer(result.body);
}
/** Creates a new agent. */
export async function createAgent(context, model, options = { requestOptions: {} }) {
    const result = await _createAgentSend(context, model, options);
    return _createAgentDeserialize(result);
}
function createAgentStream(stream) {
    const asyncIterator = toAsyncIterable(stream);
    const asyncDisposable = stream;
    return Object.assign(asyncIterator, asyncDisposable);
}
async function* toAsyncIterable(stream) {
    for await (const event of stream) {
        const data = deserializeEventData(event);
        yield { data: data, event: event.event };
    }
}
function deserializeEventData(event) {
    try {
        const jsonData = JSON.parse(event.data);
        if (Object.values(RunStepStreamEvent).includes(event.event)) {
            if (event.event === RunStepStreamEvent.ThreadRunStepDelta) {
                return runStepDeltaChunkDeserializer(jsonData);
            }
            return runStepDeserializer(jsonData);
        }
        if (Object.values(MessageStreamEvent).includes(event.event)) {
            if (event.event === MessageStreamEvent.ThreadMessageDelta) {
                return messageDeltaChunkDeserializer(jsonData);
            }
            return threadMessageDeserializer(jsonData);
        }
        if (Object.values(RunStreamEvent).includes(event.event)) {
            return threadRunDeserializer(jsonData);
        }
        return jsonData;
    }
    catch (ex) {
        logger.error(`Failed to parse event data  ${event.event} - error: ${ex}`);
        return event.data;
    }
}
async function processStream(streamResponse) {
    const expectedStatuses = ["200"];
    const result = isNodeLike
        ? await streamResponse.asNodeStream()
        : await streamResponse.asBrowserStream();
    if (!expectedStatuses.includes(result.status)) {
        throw createRestError(result);
    }
    if (!result.body) {
        throw new Error("No body in response");
    }
    const stream = isNodeLike
        ? createSseStream(result.body)
        : createSseStream(result.body);
    return createAgentStream(stream);
}
/** Create a run and stream the events */
export async function createRunStreaming(context, assistantId, threadId, options = { requestOptions: {} }) {
    const streamOptions = { ...options, stream: true };
    return processStream(_createRunSend(context, threadId, assistantId, streamOptions));
}
/** Create a thread and run and stream the events */
export async function createThreadAndRunStreaming(context, assistantId, options = { requestOptions: {} }) {
    const streamOptions = { ...options, stream: true };
    return processStream(_createThreadAndRunSend(context, assistantId, streamOptions));
}
export async function submitToolOutputsToRunStreaming(context, threadId, runId, toolOutputs, options = { requestOptions: {} }) {
    const streamOptions = { ...options, stream: true };
    return processStream(_submitToolOutputsToRunSend(context, threadId, runId, toolOutputs, streamOptions));
}
//# sourceMappingURL=operations.js.map