{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { randomUUID } from \"@azure/core-util\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { bearerTokenAuthenticationPolicy, createEmptyPipeline, createHttpHeaders } from \"@azure/core-rest-pipeline\";\nimport { isNodeLike } from \"@azure/core-util\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential.js\";\nimport { BlobClient } from \"./Clients.js\";\nimport { Mutex } from \"./utils/Mutex.js\";\nimport { Pipeline } from \"./Pipeline.js\";\nimport { getURLPath, getURLPathAndQuery, iEqual } from \"./utils/utils.common.js\";\nimport { stringifyXML } from \"@azure/core-xml\";\nimport { HeaderConstants, BATCH_MAX_REQUEST, HTTP_VERSION_1_1, HTTP_LINE_ENDING, StorageOAuthScopes } from \"./utils/constants.js\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential.js\";\nimport { tracingClient } from \"./utils/tracing.js\";\nimport { authorizeRequestOnTenantChallenge, serializationPolicy } from \"@azure/core-client\";\nimport { storageSharedKeyCredentialPolicy } from \"./policies/StorageSharedKeyCredentialPolicyV2.js\";\n/**\n * A BlobBatch represents an aggregated set of operations on blobs.\n * Currently, only `delete` and `setAccessTier` are supported.\n */\nexport class BlobBatch {\n  batchRequest;\n  batch = \"batch\";\n  batchType;\n  constructor() {\n    this.batchRequest = new InnerBatchRequest();\n  }\n  /**\n   * Get the value of Content-Type for a batch request.\n   * The value must be multipart/mixed with a batch boundary.\n   * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252\n   */\n  getMultiPartContentType() {\n    return this.batchRequest.getMultipartContentType();\n  }\n  /**\n   * Get assembled HTTP request body for sub requests.\n   */\n  getHttpRequestBody() {\n    return this.batchRequest.getHttpRequestBody();\n  }\n  /**\n   * Get sub requests that are added into the batch request.\n   */\n  getSubRequests() {\n    return this.batchRequest.getSubRequests();\n  }\n  async addSubRequestInternal(subRequest, assembleSubRequestFunc) {\n    await Mutex.lock(this.batch);\n    try {\n      this.batchRequest.preAddSubRequest(subRequest);\n      await assembleSubRequestFunc();\n      this.batchRequest.postAddSubRequest(subRequest);\n    } finally {\n      await Mutex.unlock(this.batch);\n    }\n  }\n  setBatchType(batchType) {\n    if (!this.batchType) {\n      this.batchType = batchType;\n    }\n    if (this.batchType !== batchType) {\n      throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);\n    }\n  }\n  async deleteBlob(urlOrBlobClient, credentialOrOptions, options) {\n    let url;\n    let credential;\n    if (typeof urlOrBlobClient === \"string\" && (isNodeLike && credentialOrOptions instanceof StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential || isTokenCredential(credentialOrOptions))) {\n      // First overload\n      url = urlOrBlobClient;\n      credential = credentialOrOptions;\n    } else if (urlOrBlobClient instanceof BlobClient) {\n      // Second overload\n      url = urlOrBlobClient.url;\n      credential = urlOrBlobClient.credential;\n      options = credentialOrOptions;\n    } else {\n      throw new RangeError(\"Invalid arguments. Either url and credential, or BlobClient need be provided.\");\n    }\n    if (!options) {\n      options = {};\n    }\n    return tracingClient.withSpan(\"BatchDeleteRequest-addSubRequest\", options, async updatedOptions => {\n      this.setBatchType(\"delete\");\n      await this.addSubRequestInternal({\n        url: url,\n        credential: credential\n      }, async () => {\n        await new BlobClient(url, this.batchRequest.createPipeline(credential)).delete(updatedOptions);\n      });\n    });\n  }\n  async setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {\n    let url;\n    let credential;\n    let tier;\n    if (typeof urlOrBlobClient === \"string\" && (isNodeLike && credentialOrTier instanceof StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential || isTokenCredential(credentialOrTier))) {\n      // First overload\n      url = urlOrBlobClient;\n      credential = credentialOrTier;\n      tier = tierOrOptions;\n    } else if (urlOrBlobClient instanceof BlobClient) {\n      // Second overload\n      url = urlOrBlobClient.url;\n      credential = urlOrBlobClient.credential;\n      tier = credentialOrTier;\n      options = tierOrOptions;\n    } else {\n      throw new RangeError(\"Invalid arguments. Either url and credential, or BlobClient need be provided.\");\n    }\n    if (!options) {\n      options = {};\n    }\n    return tracingClient.withSpan(\"BatchSetTierRequest-addSubRequest\", options, async updatedOptions => {\n      this.setBatchType(\"setAccessTier\");\n      await this.addSubRequestInternal({\n        url: url,\n        credential: credential\n      }, async () => {\n        await new BlobClient(url, this.batchRequest.createPipeline(credential)).setAccessTier(tier, updatedOptions);\n      });\n    });\n  }\n}\n/**\n * Inner batch request class which is responsible for assembling and serializing sub requests.\n * See https://learn.microsoft.com/rest/api/storageservices/blob-batch#request-body for how requests are assembled.\n */\nclass InnerBatchRequest {\n  operationCount;\n  body;\n  subRequests;\n  boundary;\n  subRequestPrefix;\n  multipartContentType;\n  batchRequestEnding;\n  constructor() {\n    this.operationCount = 0;\n    this.body = \"\";\n    const tempGuid = randomUUID();\n    // batch_{batchid}\n    this.boundary = `batch_${tempGuid}`;\n    // --batch_{batchid}\n    // Content-Type: application/http\n    // Content-Transfer-Encoding: binary\n    this.subRequestPrefix = `--${this.boundary}${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TYPE}: application/http${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;\n    // multipart/mixed; boundary=batch_{batchid}\n    this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;\n    // --batch_{batchid}--\n    this.batchRequestEnding = `--${this.boundary}--`;\n    this.subRequests = new Map();\n  }\n  /**\n   * Create pipeline to assemble sub requests. The idea here is to use existing\n   * credential and serialization/deserialization components, with additional policies to\n   * filter unnecessary headers, assemble sub requests into request's body\n   * and intercept request from going to wire.\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   */\n  createPipeline(credential) {\n    const corePipeline = createEmptyPipeline();\n    corePipeline.addPolicy(serializationPolicy({\n      stringifyXML,\n      serializerOptions: {\n        xml: {\n          xmlCharKey: \"#\"\n        }\n      }\n    }), {\n      phase: \"Serialize\"\n    });\n    // Use batch header filter policy to exclude unnecessary headers\n    corePipeline.addPolicy(batchHeaderFilterPolicy());\n    // Use batch assemble policy to assemble request and intercept request from going to wire\n    corePipeline.addPolicy(batchRequestAssemblePolicy(this), {\n      afterPhase: \"Sign\"\n    });\n    if (isTokenCredential(credential)) {\n      corePipeline.addPolicy(bearerTokenAuthenticationPolicy({\n        credential,\n        scopes: StorageOAuthScopes,\n        challengeCallbacks: {\n          authorizeRequestOnChallenge: authorizeRequestOnTenantChallenge\n        }\n      }), {\n        phase: \"Sign\"\n      });\n    } else if (credential instanceof StorageSharedKeyCredential) {\n      corePipeline.addPolicy(storageSharedKeyCredentialPolicy({\n        accountName: credential.accountName,\n        accountKey: credential.accountKey\n      }), {\n        phase: \"Sign\"\n      });\n    }\n    const pipeline = new Pipeline([]);\n    // attach the v2 pipeline to this one\n    pipeline._credential = credential;\n    pipeline._corePipeline = corePipeline;\n    return pipeline;\n  }\n  appendSubRequestToBody(request) {\n    // Start to assemble sub request\n    this.body += [this.subRequestPrefix,\n    // sub request constant prefix\n    `${HeaderConstants.CONTENT_ID}: ${this.operationCount}`,\n    // sub request's content ID\n    \"\",\n    // empty line after sub request's content ID\n    `${request.method.toString()} ${getURLPathAndQuery(request.url)} ${HTTP_VERSION_1_1}${HTTP_LINE_ENDING}` // sub request start line with method\n    ].join(HTTP_LINE_ENDING);\n    for (const [name, value] of request.headers) {\n      this.body += `${name}: ${value}${HTTP_LINE_ENDING}`;\n    }\n    this.body += HTTP_LINE_ENDING; // sub request's headers need be ending with an empty line\n    // No body to assemble for current batch request support\n    // End to assemble sub request\n  }\n  preAddSubRequest(subRequest) {\n    if (this.operationCount >= BATCH_MAX_REQUEST) {\n      throw new RangeError(`Cannot exceed ${BATCH_MAX_REQUEST} sub requests in a single batch`);\n    }\n    // Fast fail if url for sub request is invalid\n    const path = getURLPath(subRequest.url);\n    if (!path || path === \"\") {\n      throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);\n    }\n  }\n  postAddSubRequest(subRequest) {\n    this.subRequests.set(this.operationCount, subRequest);\n    this.operationCount++;\n  }\n  // Return the http request body with assembling the ending line to the sub request body.\n  getHttpRequestBody() {\n    return `${this.body}${this.batchRequestEnding}${HTTP_LINE_ENDING}`;\n  }\n  getMultipartContentType() {\n    return this.multipartContentType;\n  }\n  getSubRequests() {\n    return this.subRequests;\n  }\n}\nfunction batchRequestAssemblePolicy(batchRequest) {\n  return {\n    name: \"batchRequestAssemblePolicy\",\n    async sendRequest(request) {\n      batchRequest.appendSubRequestToBody(request);\n      return {\n        request,\n        status: 200,\n        headers: createHttpHeaders()\n      };\n    }\n  };\n}\nfunction batchHeaderFilterPolicy() {\n  return {\n    name: \"batchHeaderFilterPolicy\",\n    async sendRequest(request, next) {\n      let xMsHeaderName = \"\";\n      for (const [name] of request.headers) {\n        if (iEqual(name, HeaderConstants.X_MS_VERSION)) {\n          xMsHeaderName = name;\n        }\n      }\n      if (xMsHeaderName !== \"\") {\n        request.headers.delete(xMsHeaderName); // The subrequests should not have the x-ms-version header.\n      }\n      return next(request);\n    }\n  };\n}","map":{"version":3,"names":["randomUUID","isTokenCredential","bearerTokenAuthenticationPolicy","createEmptyPipeline","createHttpHeaders","isNodeLike","AnonymousCredential","BlobClient","Mutex","Pipeline","getURLPath","getURLPathAndQuery","iEqual","stringifyXML","HeaderConstants","BATCH_MAX_REQUEST","HTTP_VERSION_1_1","HTTP_LINE_ENDING","StorageOAuthScopes","StorageSharedKeyCredential","tracingClient","authorizeRequestOnTenantChallenge","serializationPolicy","storageSharedKeyCredentialPolicy","BlobBatch","batchRequest","batch","batchType","constructor","InnerBatchRequest","getMultiPartContentType","getMultipartContentType","getHttpRequestBody","getSubRequests","addSubRequestInternal","subRequest","assembleSubRequestFunc","lock","preAddSubRequest","postAddSubRequest","unlock","setBatchType","RangeError","deleteBlob","urlOrBlobClient","credentialOrOptions","options","url","credential","withSpan","updatedOptions","createPipeline","delete","setBlobAccessTier","credentialOrTier","tierOrOptions","tier","setAccessTier","operationCount","body","subRequests","boundary","subRequestPrefix","multipartContentType","batchRequestEnding","tempGuid","CONTENT_TYPE","CONTENT_TRANSFER_ENCODING","Map","corePipeline","addPolicy","serializerOptions","xml","xmlCharKey","phase","batchHeaderFilterPolicy","batchRequestAssemblePolicy","afterPhase","scopes","challengeCallbacks","authorizeRequestOnChallenge","accountName","accountKey","pipeline","_credential","_corePipeline","appendSubRequestToBody","request","CONTENT_ID","method","toString","join","name","value","headers","path","set","sendRequest","status","next","xMsHeaderName","X_MS_VERSION"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@azure\\storage-blob\\src\\BlobBatch.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { randomUUID } from \"@azure/core-util\";\nimport type { TokenCredential } from \"@azure/core-auth\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport type {\n  PipelinePolicy,\n  PipelineRequest,\n  PipelineResponse,\n  SendRequest,\n} from \"@azure/core-rest-pipeline\";\nimport {\n  bearerTokenAuthenticationPolicy,\n  createEmptyPipeline,\n  createHttpHeaders,\n} from \"@azure/core-rest-pipeline\";\nimport { isNodeLike } from \"@azure/core-util\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential.js\";\nimport type { BlobDeleteOptions, BlobSetTierOptions } from \"./Clients.js\";\nimport { BlobClient } from \"./Clients.js\";\nimport type { AccessTier } from \"./generatedModels.js\";\nimport { Mutex } from \"./utils/Mutex.js\";\nimport { Pipeline } from \"./Pipeline.js\";\nimport { getURLPath, getURLPathAndQuery, iEqual } from \"./utils/utils.common.js\";\nimport { stringifyXML } from \"@azure/core-xml\";\nimport {\n  HeaderConstants,\n  BATCH_MAX_REQUEST,\n  HTTP_VERSION_1_1,\n  HTTP_LINE_ENDING,\n  StorageOAuthScopes,\n} from \"./utils/constants.js\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential.js\";\nimport { tracingClient } from \"./utils/tracing.js\";\nimport { authorizeRequestOnTenantChallenge, serializationPolicy } from \"@azure/core-client\";\nimport { storageSharedKeyCredentialPolicy } from \"./policies/StorageSharedKeyCredentialPolicyV2.js\";\n\n/**\n * A request associated with a batch operation.\n */\nexport interface BatchSubRequest {\n  /**\n   * The URL of the resource to request operation.\n   */\n  url: string;\n\n  /**\n   * The credential used for sub request.\n   * Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service.\n   * You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   */\n  credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;\n}\n\n/**\n * A BlobBatch represents an aggregated set of operations on blobs.\n * Currently, only `delete` and `setAccessTier` are supported.\n */\nexport class BlobBatch {\n  private batchRequest: InnerBatchRequest;\n  private readonly batch: string = \"batch\";\n  private batchType: \"delete\" | \"setAccessTier\" | undefined;\n\n  constructor() {\n    this.batchRequest = new InnerBatchRequest();\n  }\n\n  /**\n   * Get the value of Content-Type for a batch request.\n   * The value must be multipart/mixed with a batch boundary.\n   * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252\n   */\n  public getMultiPartContentType(): string {\n    return this.batchRequest.getMultipartContentType();\n  }\n\n  /**\n   * Get assembled HTTP request body for sub requests.\n   */\n  public getHttpRequestBody(): string {\n    return this.batchRequest.getHttpRequestBody();\n  }\n\n  /**\n   * Get sub requests that are added into the batch request.\n   */\n  public getSubRequests(): Map<number, BatchSubRequest> {\n    return this.batchRequest.getSubRequests();\n  }\n\n  private async addSubRequestInternal(\n    subRequest: BatchSubRequest,\n    assembleSubRequestFunc: () => Promise<void>,\n  ): Promise<void> {\n    await Mutex.lock(this.batch);\n\n    try {\n      this.batchRequest.preAddSubRequest(subRequest);\n      await assembleSubRequestFunc();\n      this.batchRequest.postAddSubRequest(subRequest);\n    } finally {\n      await Mutex.unlock(this.batch);\n    }\n  }\n\n  private setBatchType(batchType: \"delete\" | \"setAccessTier\"): void {\n    if (!this.batchType) {\n      this.batchType = batchType;\n    }\n    if (this.batchType !== batchType) {\n      throw new RangeError(\n        `BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`,\n      );\n    }\n  }\n\n  /**\n   * The deleteBlob operation marks the specified blob or snapshot for deletion.\n   * The blob is later deleted during garbage collection.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * Note that in order to delete a blob, you must delete all of its snapshots.\n   * You can delete both at the same time. See [delete operation details](https://learn.microsoft.com/rest/api/storageservices/delete-blob).\n   * The operation will be authenticated and authorized with specified credential.\n   * See [blob batch authorization details](https://learn.microsoft.com/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param url - The url of the blob resource to delete.\n   * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options -\n   */\n  public async deleteBlob(\n    url: string,\n    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    options?: BlobDeleteOptions,\n  ): Promise<void>;\n\n  /**\n   * The deleteBlob operation marks the specified blob or snapshot for deletion.\n   * The blob is later deleted during garbage collection.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * Note that in order to delete a blob, you must delete all of its snapshots.\n   * You can delete both at the same time. See [delete operation details](https://learn.microsoft.com/rest/api/storageservices/delete-blob).\n   * The operation will be authenticated and authorized with specified credential.\n   * See [blob batch authorization details](https://learn.microsoft.com/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param blobClient - The BlobClient.\n   * @param options -\n   */\n  public async deleteBlob(blobClient: BlobClient, options?: BlobDeleteOptions): Promise<void>;\n\n  public async deleteBlob(\n    urlOrBlobClient: string | BlobClient,\n    credentialOrOptions:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | BlobDeleteOptions\n      | undefined,\n    options?: BlobDeleteOptions,\n  ): Promise<void> {\n    let url: string;\n    let credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;\n\n    if (\n      typeof urlOrBlobClient === \"string\" &&\n      ((isNodeLike && credentialOrOptions instanceof StorageSharedKeyCredential) ||\n        credentialOrOptions instanceof AnonymousCredential ||\n        isTokenCredential(credentialOrOptions))\n    ) {\n      // First overload\n      url = urlOrBlobClient;\n      credential = credentialOrOptions;\n    } else if (urlOrBlobClient instanceof BlobClient) {\n      // Second overload\n      url = urlOrBlobClient.url;\n      credential = urlOrBlobClient.credential;\n      options = credentialOrOptions as BlobDeleteOptions;\n    } else {\n      throw new RangeError(\n        \"Invalid arguments. Either url and credential, or BlobClient need be provided.\",\n      );\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    return tracingClient.withSpan(\n      \"BatchDeleteRequest-addSubRequest\",\n      options,\n      async (updatedOptions) => {\n        this.setBatchType(\"delete\");\n        await this.addSubRequestInternal(\n          {\n            url: url,\n            credential: credential,\n          },\n          async () => {\n            await new BlobClient(url, this.batchRequest.createPipeline(credential)).delete(\n              updatedOptions,\n            );\n          },\n        );\n      },\n    );\n  }\n\n  /**\n   * The setBlobAccessTier operation sets the tier on a blob.\n   * The operation is allowed on block blobs in a blob storage or general purpose v2 account.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * A block blob's tier determines Hot/Cool/Archive storage type.\n   * This operation does not update the blob's ETag.\n   * For detailed information about block blob level tiering\n   * see [hot, cool, and archive access tiers](https://learn.microsoft.com/azure/storage/blobs/storage-blob-storage-tiers).\n   * The operation will be authenticated and authorized\n   * with specified credential. See [blob batch authorization details](https://learn.microsoft.com/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param url - The url of the blob resource to delete.\n   * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param tier -\n   * @param options -\n   */\n  public async setBlobAccessTier(\n    url: string,\n    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    tier: AccessTier,\n    options?: BlobSetTierOptions,\n  ): Promise<void>;\n\n  /**\n   * The setBlobAccessTier operation sets the tier on a blob.\n   * The operation is allowed on block blobs in a blob storage or general purpose v2 account.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * A block blob's tier determines Hot/Cool/Archive storage type.\n   * This operation does not update the blob's ETag.\n   * For detailed information about block blob level tiering\n   * see [hot, cool, and archive access tiers](https://learn.microsoft.com/azure/storage/blobs/storage-blob-storage-tiers).\n   * The operation will be authenticated and authorized\n   * with specified credential. See [blob batch authorization details](https://learn.microsoft.com/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param blobClient - The BlobClient.\n   * @param tier -\n   * @param options -\n   */\n  public async setBlobAccessTier(\n    blobClient: BlobClient,\n    tier: AccessTier,\n    options?: BlobSetTierOptions,\n  ): Promise<void>;\n\n  public async setBlobAccessTier(\n    urlOrBlobClient: string | BlobClient,\n    credentialOrTier:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | AccessTier,\n    tierOrOptions?: AccessTier | BlobSetTierOptions,\n    options?: BlobSetTierOptions,\n  ): Promise<void> {\n    let url: string;\n    let credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;\n    let tier: AccessTier;\n\n    if (\n      typeof urlOrBlobClient === \"string\" &&\n      ((isNodeLike && credentialOrTier instanceof StorageSharedKeyCredential) ||\n        credentialOrTier instanceof AnonymousCredential ||\n        isTokenCredential(credentialOrTier))\n    ) {\n      // First overload\n      url = urlOrBlobClient;\n      credential = credentialOrTier as\n        | StorageSharedKeyCredential\n        | AnonymousCredential\n        | TokenCredential;\n      tier = tierOrOptions as AccessTier;\n    } else if (urlOrBlobClient instanceof BlobClient) {\n      // Second overload\n      url = urlOrBlobClient.url;\n      credential = urlOrBlobClient.credential;\n      tier = credentialOrTier as AccessTier;\n      options = tierOrOptions as BlobSetTierOptions;\n    } else {\n      throw new RangeError(\n        \"Invalid arguments. Either url and credential, or BlobClient need be provided.\",\n      );\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    return tracingClient.withSpan(\n      \"BatchSetTierRequest-addSubRequest\",\n      options,\n      async (updatedOptions) => {\n        this.setBatchType(\"setAccessTier\");\n        await this.addSubRequestInternal(\n          {\n            url: url,\n            credential: credential,\n          },\n          async () => {\n            await new BlobClient(url, this.batchRequest.createPipeline(credential)).setAccessTier(\n              tier,\n              updatedOptions,\n            );\n          },\n        );\n      },\n    );\n  }\n}\n\n/**\n * Inner batch request class which is responsible for assembling and serializing sub requests.\n * See https://learn.microsoft.com/rest/api/storageservices/blob-batch#request-body for how requests are assembled.\n */\nclass InnerBatchRequest {\n  private operationCount: number;\n  private body: string;\n  private subRequests: Map<number, BatchSubRequest>;\n  private readonly boundary: string;\n  private readonly subRequestPrefix: string;\n  private readonly multipartContentType: string;\n  private readonly batchRequestEnding: string;\n\n  constructor() {\n    this.operationCount = 0;\n    this.body = \"\";\n\n    const tempGuid = randomUUID();\n\n    // batch_{batchid}\n    this.boundary = `batch_${tempGuid}`;\n    // --batch_{batchid}\n    // Content-Type: application/http\n    // Content-Transfer-Encoding: binary\n    this.subRequestPrefix = `--${this.boundary}${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TYPE}: application/http${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;\n    // multipart/mixed; boundary=batch_{batchid}\n    this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;\n    // --batch_{batchid}--\n    this.batchRequestEnding = `--${this.boundary}--`;\n\n    this.subRequests = new Map();\n  }\n\n  /**\n   * Create pipeline to assemble sub requests. The idea here is to use existing\n   * credential and serialization/deserialization components, with additional policies to\n   * filter unnecessary headers, assemble sub requests into request's body\n   * and intercept request from going to wire.\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   */\n  public createPipeline(\n    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n  ): Pipeline {\n    const corePipeline = createEmptyPipeline();\n    corePipeline.addPolicy(\n      serializationPolicy({\n        stringifyXML,\n        serializerOptions: {\n          xml: {\n            xmlCharKey: \"#\",\n          },\n        },\n      }),\n      { phase: \"Serialize\" },\n    );\n    // Use batch header filter policy to exclude unnecessary headers\n    corePipeline.addPolicy(batchHeaderFilterPolicy());\n    // Use batch assemble policy to assemble request and intercept request from going to wire\n    corePipeline.addPolicy(batchRequestAssemblePolicy(this), { afterPhase: \"Sign\" });\n    if (isTokenCredential(credential)) {\n      corePipeline.addPolicy(\n        bearerTokenAuthenticationPolicy({\n          credential,\n          scopes: StorageOAuthScopes,\n          challengeCallbacks: { authorizeRequestOnChallenge: authorizeRequestOnTenantChallenge },\n        }),\n        { phase: \"Sign\" },\n      );\n    } else if (credential instanceof StorageSharedKeyCredential) {\n      corePipeline.addPolicy(\n        storageSharedKeyCredentialPolicy({\n          accountName: credential.accountName,\n          accountKey: (credential as any).accountKey,\n        }),\n        { phase: \"Sign\" },\n      );\n    }\n    const pipeline = new Pipeline([]);\n    // attach the v2 pipeline to this one\n    (pipeline as any)._credential = credential;\n    (pipeline as any)._corePipeline = corePipeline;\n\n    return pipeline;\n  }\n\n  public appendSubRequestToBody(request: PipelineRequest) {\n    // Start to assemble sub request\n    this.body += [\n      this.subRequestPrefix, // sub request constant prefix\n      `${HeaderConstants.CONTENT_ID}: ${this.operationCount}`, // sub request's content ID\n      \"\", // empty line after sub request's content ID\n      `${request.method.toString()} ${getURLPathAndQuery(\n        request.url,\n      )} ${HTTP_VERSION_1_1}${HTTP_LINE_ENDING}`, // sub request start line with method\n    ].join(HTTP_LINE_ENDING);\n\n    for (const [name, value] of request.headers) {\n      this.body += `${name}: ${value}${HTTP_LINE_ENDING}`;\n    }\n\n    this.body += HTTP_LINE_ENDING; // sub request's headers need be ending with an empty line\n    // No body to assemble for current batch request support\n    // End to assemble sub request\n  }\n\n  public preAddSubRequest(subRequest: BatchSubRequest) {\n    if (this.operationCount >= BATCH_MAX_REQUEST) {\n      throw new RangeError(`Cannot exceed ${BATCH_MAX_REQUEST} sub requests in a single batch`);\n    }\n\n    // Fast fail if url for sub request is invalid\n    const path = getURLPath(subRequest.url);\n    if (!path || path === \"\") {\n      throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);\n    }\n  }\n\n  public postAddSubRequest(subRequest: BatchSubRequest) {\n    this.subRequests.set(this.operationCount, subRequest);\n    this.operationCount++;\n  }\n\n  // Return the http request body with assembling the ending line to the sub request body.\n  public getHttpRequestBody(): string {\n    return `${this.body}${this.batchRequestEnding}${HTTP_LINE_ENDING}`;\n  }\n\n  public getMultipartContentType(): string {\n    return this.multipartContentType;\n  }\n\n  public getSubRequests(): Map<number, BatchSubRequest> {\n    return this.subRequests;\n  }\n}\n\nfunction batchRequestAssemblePolicy(batchRequest: InnerBatchRequest): PipelinePolicy {\n  return {\n    name: \"batchRequestAssemblePolicy\",\n    async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {\n      batchRequest.appendSubRequestToBody(request);\n\n      return {\n        request,\n        status: 200,\n        headers: createHttpHeaders(),\n      };\n    },\n  };\n}\n\nfunction batchHeaderFilterPolicy(): PipelinePolicy {\n  return {\n    name: \"batchHeaderFilterPolicy\",\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      let xMsHeaderName = \"\";\n\n      for (const [name] of request.headers) {\n        if (iEqual(name, HeaderConstants.X_MS_VERSION)) {\n          xMsHeaderName = name;\n        }\n      }\n\n      if (xMsHeaderName !== \"\") {\n        request.headers.delete(xMsHeaderName); // The subrequests should not have the x-ms-version header.\n      }\n\n      return next(request);\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}