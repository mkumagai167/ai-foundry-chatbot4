{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport * as base64 from \"./base64.js\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./interfaces.js\";\nimport { isDuration, isValidUuid } from \"./utils.js\";\nclass SerializerImpl {\n  modelMappers;\n  isXML;\n  constructor(modelMappers = {}, isXML = false) {\n    this.modelMappers = modelMappers;\n    this.isXML = isXML;\n  }\n  /**\n   * @deprecated Removing the constraints validation on client side.\n   */\n  validateConstraints(mapper, value, objectName) {\n    const failValidation = (constraintName, constraintValue) => {\n      throw new Error(`\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`);\n    };\n    if (mapper.constraints && value !== undefined && value !== null) {\n      const {\n        ExclusiveMaximum,\n        ExclusiveMinimum,\n        InclusiveMaximum,\n        InclusiveMinimum,\n        MaxItems,\n        MaxLength,\n        MinItems,\n        MinLength,\n        MultipleOf,\n        Pattern,\n        UniqueItems\n      } = mapper.constraints;\n      if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n      if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n      if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n      if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n      if (MaxItems !== undefined && value.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n      if (MaxLength !== undefined && value.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n      if (MinItems !== undefined && value.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n      if (MinLength !== undefined && value.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n      if (MultipleOf !== undefined && value % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n      if (Pattern) {\n        const pattern = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n        if (typeof value !== \"string\" || value.match(pattern) === null) {\n          failValidation(\"Pattern\", Pattern);\n        }\n      }\n      if (UniqueItems && value.some((item, i, ar) => ar.indexOf(item) !== i)) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  }\n  /**\n   * Serialize the given object based on its metadata defined in the mapper\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object\n   *\n   * @param object - A valid Javascript object to be serialized\n   *\n   * @param objectName - Name of the serialized object\n   *\n   * @param options - additional options to serialization\n   *\n   * @returns A valid serialized Javascript object\n   */\n  serialize(mapper, object, objectName, options = {\n    xml: {}\n  }) {\n    const updatedOptions = {\n      xml: {\n        rootName: options.xml.rootName ?? \"\",\n        includeRoot: options.xml.includeRoot ?? false,\n        xmlCharKey: options.xml.xmlCharKey ?? XML_CHARKEY\n      }\n    };\n    let payload = {};\n    const mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName;\n    }\n    if (mapperType.match(/^Sequence$/i) !== null) {\n      payload = [];\n    }\n    if (mapper.isConstant) {\n      object = mapper.defaultValue;\n    }\n    // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n    const {\n      required,\n      nullable\n    } = mapper;\n    if (required && nullable && object === undefined) {\n      throw new Error(`${objectName} cannot be undefined.`);\n    }\n    if (required && !nullable && (object === undefined || object === null)) {\n      throw new Error(`${objectName} cannot be null or undefined.`);\n    }\n    if (!required && nullable === false && object === null) {\n      throw new Error(`${objectName} cannot be null.`);\n    }\n    if (object === undefined || object === null) {\n      payload = object;\n    } else {\n      if (mapperType.match(/^any$/i) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/i) !== null) {\n        const enumMapper = mapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = serializeByteArrayType(objectName, object);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = serializeBase64UrlType(objectName, object);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n      } else if (mapperType.match(/^Composite$/i) !== null) {\n        payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n      }\n    }\n    return payload;\n  }\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object\n   *\n   * @param responseBody - A valid Javascript entity to be deserialized\n   *\n   * @param objectName - Name of the deserialized object\n   *\n   * @param options - Controls behavior of XML parser and builder.\n   *\n   * @returns A valid deserialized Javascript object\n   */\n  deserialize(mapper, responseBody, objectName, options = {\n    xml: {}\n  }) {\n    const updatedOptions = {\n      xml: {\n        rootName: options.xml.rootName ?? \"\",\n        includeRoot: options.xml.includeRoot ?? false,\n        xmlCharKey: options.xml.xmlCharKey ?? XML_CHARKEY\n      },\n      ignoreUnknownProperties: options.ignoreUnknownProperties ?? false\n    };\n    if (responseBody === undefined || responseBody === null) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      }\n      // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n      if (mapper.defaultValue !== undefined) {\n        responseBody = mapper.defaultValue;\n      }\n      return responseBody;\n    }\n    let payload;\n    const mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName;\n    }\n    if (mapperType.match(/^Composite$/i) !== null) {\n      payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);\n    } else {\n      if (this.isXML) {\n        const xmlCharKey = updatedOptions.xml.xmlCharKey;\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n         * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n         */\n        if (responseBody[XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {\n          responseBody = responseBody[xmlCharKey];\n        }\n      }\n      if (mapperType.match(/^Number$/i) !== null) {\n        payload = parseFloat(responseBody);\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/i) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n        payload = new Date(responseBody);\n      } else if (mapperType.match(/^UnixTime$/i) !== null) {\n        payload = unixTimeToDate(responseBody);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = base64.decodeString(responseBody);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = base64UrlToByteArray(responseBody);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);\n      }\n    }\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n    return payload;\n  }\n}\n/**\n * Method that creates and returns a Serializer.\n * @param modelMappers - Known models to map\n * @param isXML - If XML should be supported\n */\nexport function createSerializer(modelMappers = {}, isXML = false) {\n  return new SerializerImpl(modelMappers, isXML);\n}\nfunction trimEnd(str, ch) {\n  let len = str.length;\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n  return str.substr(0, len);\n}\nfunction bufferToBase64Url(buffer) {\n  if (!buffer) {\n    return undefined;\n  }\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n  }\n  // Uint8Array to Base64.\n  const str = base64.encodeByteArray(buffer);\n  // Base64 to Base64Url.\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction base64UrlToByteArray(str) {\n  if (!str) {\n    return undefined;\n  }\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  }\n  // Base64Url to Base64.\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Base64 to Uint8Array.\n  return base64.decodeString(str);\n}\nfunction splitSerializeName(prop) {\n  const classes = [];\n  let partialclass = \"\";\n  if (prop) {\n    const subwords = prop.split(\".\");\n    for (const item of subwords) {\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n  return classes;\n}\nfunction dateToUnixTime(d) {\n  if (!d) {\n    return undefined;\n  }\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d);\n  }\n  return Math.floor(d.getTime() / 1000);\n}\nfunction unixTimeToDate(n) {\n  if (!n) {\n    return undefined;\n  }\n  return new Date(n * 1000);\n}\nfunction serializeBasicTypes(typeName, objectName, value) {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/i) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(`${objectName} with value ${value} must be of type number.`);\n      }\n    } else if (typeName.match(/^String$/i) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n      }\n    } else if (typeName.match(/^Uuid$/i) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && isValidUuid(value))) {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string and a valid uuid.`);\n      }\n    } else if (typeName.match(/^Boolean$/i) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n      }\n    } else if (typeName.match(/^Stream$/i) !== null) {\n      const objectType = typeof value;\n      if (objectType !== \"string\" && typeof value.pipe !== \"function\" &&\n      // NodeJS.ReadableStream\n      typeof value.tee !== \"function\" &&\n      // browser ReadableStream\n      !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) &&\n      // File objects count as a type of Blob, so we want to use instanceof explicitly\n      !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob) && objectType !== \"function\") {\n        throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);\n      }\n    }\n  }\n  return value;\n}\nfunction serializeEnumType(objectName, allowedValues, value) {\n  if (!allowedValues) {\n    throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);\n  }\n  const isPresent = allowedValues.some(item => {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n    return item === value;\n  });\n  if (!isPresent) {\n    throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);\n  }\n  return value;\n}\nfunction serializeByteArrayType(objectName, value) {\n  if (value !== undefined && value !== null) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    value = base64.encodeByteArray(value);\n  }\n  return value;\n}\nfunction serializeBase64UrlType(objectName, value) {\n  if (value !== undefined && value !== null) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    value = bufferToBase64Url(value);\n  }\n  return value;\n}\nfunction serializeDateTypes(typeName, value, objectName) {\n  if (value !== undefined && value !== null) {\n    if (typeName.match(/^Date$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n      }\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` + `for it to be serialized in UnixTime/Epoch format.`);\n      }\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/i) !== null) {\n      if (!isDuration(value)) {\n        throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`);\n      }\n    }\n  }\n  return value;\n}\nfunction serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {\n  if (!Array.isArray(object)) {\n    throw new Error(`${objectName} must be of type Array.`);\n  }\n  let elementType = mapper.type.element;\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(`element\" metadata for an Array must be defined in the ` + `mapper and it must of type \"object\" in ${objectName}.`);\n  }\n  // Quirk: Composite mappers referenced by `element` might\n  // not have *all* properties declared (like uberParent),\n  // so let's try to look up the full definition by name.\n  if (elementType.type.name === \"Composite\" && elementType.type.className) {\n    elementType = serializer.modelMappers[elementType.type.className] ?? elementType;\n  }\n  const tempArray = [];\n  for (let i = 0; i < object.length; i++) {\n    const serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n    if (isXml && elementType.xmlNamespace) {\n      const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : \"xmlns\";\n      if (elementType.type.name === \"Composite\") {\n        tempArray[i] = {\n          ...serializedValue\n        };\n        tempArray[i][XML_ATTRKEY] = {\n          [xmlnsKey]: elementType.xmlNamespace\n        };\n      } else {\n        tempArray[i] = {};\n        tempArray[i][options.xml.xmlCharKey] = serializedValue;\n        tempArray[i][XML_ATTRKEY] = {\n          [xmlnsKey]: elementType.xmlNamespace\n        };\n      }\n    } else {\n      tempArray[i] = serializedValue;\n    }\n  }\n  return tempArray;\n}\nfunction serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {\n  if (typeof object !== \"object\") {\n    throw new Error(`${objectName} must be of type object.`);\n  }\n  const valueType = mapper.type.value;\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(`\"value\" metadata for a Dictionary must be defined in the ` + `mapper and it must of type \"object\" in ${objectName}.`);\n  }\n  const tempDictionary = {};\n  for (const key of Object.keys(object)) {\n    const serializedValue = serializer.serialize(valueType, object[key], objectName, options);\n    // If the element needs an XML namespace we need to add it within the $ property\n    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n  }\n  // Add the namespace to the root element if needed\n  if (isXml && mapper.xmlNamespace) {\n    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n    const result = tempDictionary;\n    result[XML_ATTRKEY] = {\n      [xmlnsKey]: mapper.xmlNamespace\n    };\n    return result;\n  }\n  return tempDictionary;\n}\n/**\n * Resolves the additionalProperties property from a referenced mapper\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveAdditionalProperties(serializer, mapper, objectName) {\n  const additionalProperties = mapper.type.additionalProperties;\n  if (!additionalProperties && mapper.type.className) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    return modelMapper?.type.additionalProperties;\n  }\n  return additionalProperties;\n}\n/**\n * Finds the mapper referenced by className\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveReferencedMapper(serializer, mapper, objectName) {\n  const className = mapper.type.className;\n  if (!className) {\n    throw new Error(`Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(mapper, undefined, 2)}\".`);\n  }\n  return serializer.modelMappers[className];\n}\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n */\nfunction resolveModelProperties(serializer, mapper, objectName) {\n  let modelProps = mapper.type.modelProperties;\n  if (!modelProps) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    if (!modelMapper) {\n      throw new Error(`mapper() cannot be null or undefined for model \"${mapper.type.className}\".`);\n    }\n    modelProps = modelMapper?.type.modelProperties;\n    if (!modelProps) {\n      throw new Error(`modelProperties cannot be null or undefined in the ` + `mapper \"${JSON.stringify(modelMapper)}\" of type \"${mapper.type.className}\" for object \"${objectName}\".`);\n    }\n  }\n  return modelProps;\n}\nfunction serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n  if (object !== undefined && object !== null) {\n    const payload = {};\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n    for (const key of Object.keys(modelProps)) {\n      const propertyMapper = modelProps[key];\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n      let propName;\n      let parentObject = payload;\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        const paths = splitSerializeName(propertyMapper.serializedName);\n        propName = paths.pop();\n        for (const pathName of paths) {\n          const childObject = parentObject[pathName];\n          if ((childObject === undefined || childObject === null) && (object[key] !== undefined && object[key] !== null || propertyMapper.defaultValue !== undefined)) {\n            parentObject[pathName] = {};\n          }\n          parentObject = parentObject[pathName];\n        }\n      }\n      if (parentObject !== undefined && parentObject !== null) {\n        if (isXml && mapper.xmlNamespace) {\n          const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n          parentObject[XML_ATTRKEY] = {\n            ...parentObject[XML_ATTRKEY],\n            [xmlnsKey]: mapper.xmlNamespace\n          };\n        }\n        const propertyObjectName = propertyMapper.serializedName !== \"\" ? objectName + \".\" + propertyMapper.serializedName : objectName;\n        let toSerialize = object[key];\n        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === undefined || toSerialize === null)) {\n          toSerialize = mapper.serializedName;\n        }\n        const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);\n        if (serializedValue !== undefined && propName !== undefined && propName !== null) {\n          const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n          if (isXml && propertyMapper.xmlIsAttribute) {\n            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n            parentObject[XML_ATTRKEY][propName] = serializedValue;\n          } else if (isXml && propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = {\n              [propertyMapper.xmlElementName]: value\n            };\n          } else {\n            parentObject[propName] = value;\n          }\n        }\n      }\n    }\n    const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n    if (additionalPropertiesMapper) {\n      const propNames = Object.keys(modelProps);\n      for (const clientPropName in object) {\n        const isAdditionalProperty = propNames.every(pn => pn !== clientPropName);\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '[\"' + clientPropName + '\"]', options);\n        }\n      }\n    }\n    return payload;\n  }\n  return object;\n}\nfunction getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {\n  if (!isXml || !propertyMapper.xmlNamespace) {\n    return serializedValue;\n  }\n  const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : \"xmlns\";\n  const xmlNamespace = {\n    [xmlnsKey]: propertyMapper.xmlNamespace\n  };\n  if ([\"Composite\"].includes(propertyMapper.type.name)) {\n    if (serializedValue[XML_ATTRKEY]) {\n      return serializedValue;\n    } else {\n      const result = {\n        ...serializedValue\n      };\n      result[XML_ATTRKEY] = xmlNamespace;\n      return result;\n    }\n  }\n  const result = {};\n  result[options.xml.xmlCharKey] = serializedValue;\n  result[XML_ATTRKEY] = xmlNamespace;\n  return result;\n}\nfunction isSpecialXmlProperty(propertyName, options) {\n  return [XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);\n}\nfunction deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {\n  const xmlCharKey = options.xml.xmlCharKey ?? XML_CHARKEY;\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n  const modelProps = resolveModelProperties(serializer, mapper, objectName);\n  let instance = {};\n  const handledPropertyNames = [];\n  for (const key of Object.keys(modelProps)) {\n    const propertyMapper = modelProps[key];\n    const paths = splitSerializeName(modelProps[key].serializedName);\n    handledPropertyNames.push(paths[0]);\n    const {\n      serializedName,\n      xmlName,\n      xmlElementName\n    } = propertyMapper;\n    let propertyObjectName = objectName;\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n    const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;\n    if (headerCollectionPrefix) {\n      const dictionary = {};\n      for (const headerKey of Object.keys(responseBody)) {\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);\n        }\n        handledPropertyNames.push(headerKey);\n      }\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n        instance[key] = serializer.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);\n      } else if (propertyMapper.xmlIsMsText) {\n        if (responseBody[xmlCharKey] !== undefined) {\n          instance[key] = responseBody[xmlCharKey];\n        } else if (typeof responseBody === \"string\") {\n          // The special case where xml parser parses \"<Name>content</Name>\" into JSON of\n          //   `{ name: \"content\"}` instead of `{ name: { \"_\": \"content\" }}`\n          instance[key] = responseBody;\n        }\n      } else {\n        const propertyName = xmlElementName || xmlName || serializedName;\n        if (propertyMapper.xmlIsWrapped) {\n          /* a list of <xmlElementName> wrapped by <xmlName>\n            For the xml example below\n              <Cors>\n                <CorsRule>...</CorsRule>\n                <CorsRule>...</CorsRule>\n              </Cors>\n            the responseBody has\n              {\n                Cors: {\n                  CorsRule: [{...}, {...}]\n                }\n              }\n            xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n          */\n          const wrapped = responseBody[xmlName];\n          const elementList = wrapped?.[xmlElementName] ?? [];\n          instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);\n          handledPropertyNames.push(xmlName);\n        } else {\n          const property = responseBody[propertyName];\n          instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);\n          handledPropertyNames.push(propertyName);\n        }\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      let propertyInstance;\n      let res = responseBody;\n      // traversing the object step by step.\n      let steps = 0;\n      for (const item of paths) {\n        if (!res) break;\n        steps++;\n        res = res[item];\n      }\n      // only accept null when reaching the last position of object otherwise it would be undefined\n      if (res === null && steps < paths.length) {\n        res = undefined;\n      }\n      propertyInstance = res;\n      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n      // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n      if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === undefined || propertyInstance === null)) {\n        propertyInstance = mapper.serializedName;\n      }\n      let serializedValue;\n      // paging\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n        // Copy over any properties that have already been added into the instance, where they do\n        // not exist on the newly de-serialized array\n        for (const [k, v] of Object.entries(instance)) {\n          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {\n            arrayInstance[k] = v;\n          }\n        }\n        instance = arrayInstance;\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n        instance[key] = serializedValue;\n      }\n    }\n  }\n  const additionalPropertiesMapper = mapper.type.additionalProperties;\n  if (additionalPropertiesMapper) {\n    const isAdditionalProperty = responsePropName => {\n      for (const clientPropName in modelProps) {\n        const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n      return true;\n    };\n    for (const responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '[\"' + responsePropName + '\"]', options);\n      }\n    }\n  } else if (responseBody && !options.ignoreUnknownProperties) {\n    for (const key of Object.keys(responseBody)) {\n      if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n  return instance;\n}\nfunction deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {\n  /* jshint validthis: true */\n  const value = mapper.type.value;\n  if (!value || typeof value !== \"object\") {\n    throw new Error(`\"value\" metadata for a Dictionary must be defined in the ` + `mapper and it must of type \"object\" in ${objectName}`);\n  }\n  if (responseBody) {\n    const tempDictionary = {};\n    for (const key of Object.keys(responseBody)) {\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n    }\n    return tempDictionary;\n  }\n  return responseBody;\n}\nfunction deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {\n  let element = mapper.type.element;\n  if (!element || typeof element !== \"object\") {\n    throw new Error(`element\" metadata for an Array must be defined in the ` + `mapper and it must of type \"object\" in ${objectName}`);\n  }\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n    // Quirk: Composite mappers referenced by `element` might\n    // not have *all* properties declared (like uberParent),\n    // so let's try to look up the full definition by name.\n    if (element.type.name === \"Composite\" && element.type.className) {\n      element = serializer.modelMappers[element.type.className] ?? element;\n    }\n    const tempArray = [];\n    for (let i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);\n    }\n    return tempArray;\n  }\n  return responseBody;\n}\nfunction getIndexDiscriminator(discriminators, discriminatorValue, typeName) {\n  const typeNamesToCheck = [typeName];\n  while (typeNamesToCheck.length) {\n    const currentName = typeNamesToCheck.shift();\n    const indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + \".\" + discriminatorValue;\n    if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {\n      return discriminators[indexDiscriminator];\n    } else {\n      for (const [name, mapper] of Object.entries(discriminators)) {\n        if (name.startsWith(currentName + \".\") && mapper.type.uberParent === currentName && mapper.type.className) {\n          typeNamesToCheck.push(mapper.type.className);\n        }\n      }\n    }\n  }\n  return undefined;\n}\nfunction getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {\n  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n  if (polymorphicDiscriminator) {\n    let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n    if (discriminatorName) {\n      // The serializedName might have \\\\, which we just want to ignore\n      if (polymorphicPropertyName === \"serializedName\") {\n        discriminatorName = discriminatorName.replace(/\\\\/gi, \"\");\n      }\n      const discriminatorValue = object[discriminatorName];\n      const typeName = mapper.type.uberParent ?? mapper.type.className;\n      if (typeof discriminatorValue === \"string\" && typeName) {\n        const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n  return mapper;\n}\nfunction getPolymorphicDiscriminatorRecursively(serializer, mapper) {\n  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);\n}\nfunction getPolymorphicDiscriminatorSafely(serializer, typeName) {\n  return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;\n}\n/**\n * Known types of Mappers\n */\nexport const MapperTypeNames = {\n  Base64Url: \"Base64Url\",\n  Boolean: \"Boolean\",\n  ByteArray: \"ByteArray\",\n  Composite: \"Composite\",\n  Date: \"Date\",\n  DateTime: \"DateTime\",\n  DateTimeRfc1123: \"DateTimeRfc1123\",\n  Dictionary: \"Dictionary\",\n  Enum: \"Enum\",\n  Number: \"Number\",\n  Object: \"Object\",\n  Sequence: \"Sequence\",\n  String: \"String\",\n  Stream: \"Stream\",\n  TimeSpan: \"TimeSpan\",\n  UnixTime: \"UnixTime\"\n};","map":{"version":3,"names":["base64","XML_ATTRKEY","XML_CHARKEY","isDuration","isValidUuid","SerializerImpl","modelMappers","isXML","constructor","validateConstraints","mapper","value","objectName","failValidation","constraintName","constraintValue","Error","constraints","undefined","ExclusiveMaximum","ExclusiveMinimum","InclusiveMaximum","InclusiveMinimum","MaxItems","MaxLength","MinItems","MinLength","MultipleOf","Pattern","UniqueItems","length","pattern","RegExp","match","some","item","i","ar","indexOf","serialize","object","options","xml","updatedOptions","rootName","includeRoot","xmlCharKey","payload","mapperType","type","name","serializedName","isConstant","defaultValue","required","nullable","serializeBasicTypes","enumMapper","serializeEnumType","allowedValues","serializeDateTypes","serializeByteArrayType","serializeBase64UrlType","serializeSequenceType","Boolean","serializeDictionaryType","serializeCompositeType","deserialize","responseBody","ignoreUnknownProperties","xmlIsWrapped","deserializeCompositeType","parseFloat","isNaN","Date","unixTimeToDate","decodeString","base64UrlToByteArray","deserializeSequenceType","deserializeDictionaryType","createSerializer","trimEnd","str","ch","len","substr","bufferToBase64Url","buffer","Uint8Array","encodeByteArray","replace","valueOf","splitSerializeName","prop","classes","partialclass","subwords","split","charAt","push","dateToUnixTime","d","Math","floor","getTime","n","typeName","objectType","pipe","tee","ArrayBuffer","isView","Blob","isPresent","toLowerCase","JSON","stringify","parse","toISOString","substring","toUTCString","serializer","isXml","Array","isArray","elementType","element","className","tempArray","serializedValue","xmlNamespace","xmlnsKey","xmlNamespacePrefix","valueType","tempDictionary","key","Object","keys","getXmlObjectValue","result","resolveAdditionalProperties","additionalProperties","modelMapper","resolveReferencedMapper","resolveModelProperties","modelProps","modelProperties","getPolymorphicDiscriminatorRecursively","getPolymorphicMapper","propertyMapper","readOnly","propName","parentObject","xmlName","xmlElementName","paths","pop","pathName","childObject","propertyObjectName","toSerialize","polymorphicDiscriminator","clientName","xmlIsAttribute","additionalPropertiesMapper","propNames","clientPropName","isAdditionalProperty","every","pn","includes","isSpecialXmlProperty","propertyName","instance","handledPropertyNames","headerCollectionPrefix","dictionary","headerKey","startsWith","xmlIsMsText","wrapped","elementList","property","propertyInstance","res","steps","arrayInstance","k","v","entries","prototype","hasOwnProperty","call","responsePropName","getIndexDiscriminator","discriminators","discriminatorValue","typeNamesToCheck","currentName","shift","indexDiscriminator","uberParent","polymorphicPropertyName","discriminatorName","polymorphicMapper","getPolymorphicDiscriminatorSafely","MapperTypeNames","Base64Url","ByteArray","Composite","DateTime","DateTimeRfc1123","Dictionary","Enum","Number","Sequence","String","Stream","TimeSpan","UnixTime"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@azure\\core-client\\src\\serializer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport * as base64 from \"./base64.js\";\nimport type {\n  BaseMapper,\n  CompositeMapper,\n  DictionaryMapper,\n  EnumMapper,\n  Mapper,\n  MapperConstraints,\n  PolymorphicDiscriminator,\n  RequiredSerializerOptions,\n  SequenceMapper,\n  Serializer,\n  SerializerOptions,\n} from \"./interfaces.js\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./interfaces.js\";\nimport { isDuration, isValidUuid } from \"./utils.js\";\n\nclass SerializerImpl implements Serializer {\n  constructor(\n    public readonly modelMappers: { [key: string]: any } = {},\n    public readonly isXML: boolean = false,\n  ) {}\n\n  /**\n   * @deprecated Removing the constraints validation on client side.\n   */\n  validateConstraints(mapper: Mapper, value: any, objectName: string): void {\n    const failValidation = (\n      constraintName: keyof MapperConstraints,\n      constraintValue: any,\n    ): never => {\n      throw new Error(\n        `\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`,\n      );\n    };\n    if (mapper.constraints && value !== undefined && value !== null) {\n      const {\n        ExclusiveMaximum,\n        ExclusiveMinimum,\n        InclusiveMaximum,\n        InclusiveMinimum,\n        MaxItems,\n        MaxLength,\n        MinItems,\n        MinLength,\n        MultipleOf,\n        Pattern,\n        UniqueItems,\n      } = mapper.constraints;\n      if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n      if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n      if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n      if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n      if (MaxItems !== undefined && value.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n      if (MaxLength !== undefined && value.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n      if (MinItems !== undefined && value.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n      if (MinLength !== undefined && value.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n      if (MultipleOf !== undefined && value % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n      if (Pattern) {\n        const pattern: RegExp = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n        if (typeof value !== \"string\" || value.match(pattern) === null) {\n          failValidation(\"Pattern\", Pattern);\n        }\n      }\n      if (\n        UniqueItems &&\n        value.some((item: any, i: number, ar: Array<any>) => ar.indexOf(item) !== i)\n      ) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  }\n\n  /**\n   * Serialize the given object based on its metadata defined in the mapper\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object\n   *\n   * @param object - A valid Javascript object to be serialized\n   *\n   * @param objectName - Name of the serialized object\n   *\n   * @param options - additional options to serialization\n   *\n   * @returns A valid serialized Javascript object\n   */\n  serialize(\n    mapper: Mapper,\n    object: any,\n    objectName?: string,\n    options: SerializerOptions = { xml: {} },\n  ): any {\n    const updatedOptions: RequiredSerializerOptions = {\n      xml: {\n        rootName: options.xml.rootName ?? \"\",\n        includeRoot: options.xml.includeRoot ?? false,\n        xmlCharKey: options.xml.xmlCharKey ?? XML_CHARKEY,\n      },\n    };\n    let payload: any = {};\n    const mapperType = mapper.type.name as string;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n    if (mapperType.match(/^Sequence$/i) !== null) {\n      payload = [];\n    }\n\n    if (mapper.isConstant) {\n      object = mapper.defaultValue;\n    }\n\n    // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n\n    const { required, nullable } = mapper;\n\n    if (required && nullable && object === undefined) {\n      throw new Error(`${objectName} cannot be undefined.`);\n    }\n    if (required && !nullable && (object === undefined || object === null)) {\n      throw new Error(`${objectName} cannot be null or undefined.`);\n    }\n    if (!required && nullable === false && object === null) {\n      throw new Error(`${objectName} cannot be null.`);\n    }\n\n    if (object === undefined || object === null) {\n      payload = object;\n    } else {\n      if (mapperType.match(/^any$/i) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/i) !== null) {\n        const enumMapper = mapper as EnumMapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (\n        mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null\n      ) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = serializeByteArrayType(objectName, object);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = serializeBase64UrlType(objectName, object);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = serializeSequenceType(\n          this,\n          mapper as SequenceMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions,\n        );\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = serializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions,\n        );\n      } else if (mapperType.match(/^Composite$/i) !== null) {\n        payload = serializeCompositeType(\n          this,\n          mapper as CompositeMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions,\n        );\n      }\n    }\n    return payload;\n  }\n\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object\n   *\n   * @param responseBody - A valid Javascript entity to be deserialized\n   *\n   * @param objectName - Name of the deserialized object\n   *\n   * @param options - Controls behavior of XML parser and builder.\n   *\n   * @returns A valid deserialized Javascript object\n   */\n  deserialize(\n    mapper: Mapper,\n    responseBody: any,\n    objectName: string,\n    options: SerializerOptions = { xml: {} },\n  ): any {\n    const updatedOptions: RequiredSerializerOptions = {\n      xml: {\n        rootName: options.xml.rootName ?? \"\",\n        includeRoot: options.xml.includeRoot ?? false,\n        xmlCharKey: options.xml.xmlCharKey ?? XML_CHARKEY,\n      },\n      ignoreUnknownProperties: options.ignoreUnknownProperties ?? false,\n    };\n    if (responseBody === undefined || responseBody === null) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      }\n      // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n      if (mapper.defaultValue !== undefined) {\n        responseBody = mapper.defaultValue;\n      }\n      return responseBody;\n    }\n\n    let payload: any;\n    const mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n\n    if (mapperType.match(/^Composite$/i) !== null) {\n      payload = deserializeCompositeType(\n        this,\n        mapper as CompositeMapper,\n        responseBody,\n        objectName,\n        updatedOptions,\n      );\n    } else {\n      if (this.isXML) {\n        const xmlCharKey = updatedOptions.xml.xmlCharKey;\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n         * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n         */\n        if (responseBody[XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {\n          responseBody = responseBody[xmlCharKey];\n        }\n      }\n\n      if (mapperType.match(/^Number$/i) !== null) {\n        payload = parseFloat(responseBody);\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/i) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n        payload = new Date(responseBody);\n      } else if (mapperType.match(/^UnixTime$/i) !== null) {\n        payload = unixTimeToDate(responseBody);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = base64.decodeString(responseBody);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = base64UrlToByteArray(responseBody);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = deserializeSequenceType(\n          this,\n          mapper as SequenceMapper,\n          responseBody,\n          objectName,\n          updatedOptions,\n        );\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = deserializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          responseBody,\n          objectName,\n          updatedOptions,\n        );\n      }\n    }\n\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n\n    return payload;\n  }\n}\n\n/**\n * Method that creates and returns a Serializer.\n * @param modelMappers - Known models to map\n * @param isXML - If XML should be supported\n */\nexport function createSerializer(\n  modelMappers: { [key: string]: any } = {},\n  isXML: boolean = false,\n): Serializer {\n  return new SerializerImpl(modelMappers, isXML);\n}\n\nfunction trimEnd(str: string, ch: string): string {\n  let len = str.length;\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n  return str.substr(0, len);\n}\n\nfunction bufferToBase64Url(buffer: Uint8Array): string | undefined {\n  if (!buffer) {\n    return undefined;\n  }\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n  }\n  // Uint8Array to Base64.\n  const str = base64.encodeByteArray(buffer);\n  // Base64 to Base64Url.\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\nfunction base64UrlToByteArray(str: string): Uint8Array | undefined {\n  if (!str) {\n    return undefined;\n  }\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  }\n  // Base64Url to Base64.\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Base64 to Uint8Array.\n  return base64.decodeString(str);\n}\n\nfunction splitSerializeName(prop: string | undefined): string[] {\n  const classes: string[] = [];\n  let partialclass = \"\";\n  if (prop) {\n    const subwords = prop.split(\".\");\n\n    for (const item of subwords) {\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n\n  return classes;\n}\n\nfunction dateToUnixTime(d: string | Date): number | undefined {\n  if (!d) {\n    return undefined;\n  }\n\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d as string);\n  }\n  return Math.floor((d as Date).getTime() / 1000);\n}\n\nfunction unixTimeToDate(n: number): Date | undefined {\n  if (!n) {\n    return undefined;\n  }\n  return new Date(n * 1000);\n}\n\nfunction serializeBasicTypes(typeName: string, objectName: string, value: any): any {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/i) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(`${objectName} with value ${value} must be of type number.`);\n      }\n    } else if (typeName.match(/^String$/i) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n      }\n    } else if (typeName.match(/^Uuid$/i) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && isValidUuid(value))) {\n        throw new Error(\n          `${objectName} with value \"${value}\" must be of type string and a valid uuid.`,\n        );\n      }\n    } else if (typeName.match(/^Boolean$/i) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n      }\n    } else if (typeName.match(/^Stream$/i) !== null) {\n      const objectType = typeof value;\n      if (\n        objectType !== \"string\" &&\n        typeof value.pipe !== \"function\" && // NodeJS.ReadableStream\n        typeof value.tee !== \"function\" && // browser ReadableStream\n        !(value instanceof ArrayBuffer) &&\n        !ArrayBuffer.isView(value) &&\n        // File objects count as a type of Blob, so we want to use instanceof explicitly\n        !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob) &&\n        objectType !== \"function\"\n      ) {\n        throw new Error(\n          `${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`,\n        );\n      }\n    }\n  }\n  return value;\n}\n\nfunction serializeEnumType(objectName: string, allowedValues: Array<any>, value: any): any {\n  if (!allowedValues) {\n    throw new Error(\n      `Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`,\n    );\n  }\n  const isPresent = allowedValues.some((item) => {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n    return item === value;\n  });\n  if (!isPresent) {\n    throw new Error(\n      `${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(\n        allowedValues,\n      )}.`,\n    );\n  }\n  return value;\n}\n\nfunction serializeByteArrayType(objectName: string, value: any): any {\n  if (value !== undefined && value !== null) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    value = base64.encodeByteArray(value);\n  }\n  return value;\n}\n\nfunction serializeBase64UrlType(objectName: string, value: any): any {\n  if (value !== undefined && value !== null) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    value = bufferToBase64Url(value);\n  }\n  return value;\n}\n\nfunction serializeDateTypes(typeName: string, value: any, objectName: string): any {\n  if (value !== undefined && value !== null) {\n    if (typeName.match(/^Date$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value =\n        value instanceof Date\n          ? value.toISOString().substring(0, 10)\n          : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n      }\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(\n          `${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +\n            `for it to be serialized in UnixTime/Epoch format.`,\n        );\n      }\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/i) !== null) {\n      if (!isDuration(value)) {\n        throw new Error(\n          `${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`,\n        );\n      }\n    }\n  }\n  return value;\n}\n\nfunction serializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: RequiredSerializerOptions,\n): any {\n  if (!Array.isArray(object)) {\n    throw new Error(`${objectName} must be of type Array.`);\n  }\n  let elementType = mapper.type.element;\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`,\n    );\n  }\n  // Quirk: Composite mappers referenced by `element` might\n  // not have *all* properties declared (like uberParent),\n  // so let's try to look up the full definition by name.\n  if (elementType.type.name === \"Composite\" && elementType.type.className) {\n    elementType = serializer.modelMappers[elementType.type.className] ?? elementType;\n  }\n  const tempArray = [];\n  for (let i = 0; i < object.length; i++) {\n    const serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n    if (isXml && elementType.xmlNamespace) {\n      const xmlnsKey = elementType.xmlNamespacePrefix\n        ? `xmlns:${elementType.xmlNamespacePrefix}`\n        : \"xmlns\";\n      if (elementType.type.name === \"Composite\") {\n        tempArray[i] = { ...serializedValue };\n        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n      } else {\n        tempArray[i] = {};\n        tempArray[i][options.xml.xmlCharKey] = serializedValue;\n        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n      }\n    } else {\n      tempArray[i] = serializedValue;\n    }\n  }\n  return tempArray;\n}\n\nfunction serializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: RequiredSerializerOptions,\n): any {\n  if (typeof object !== \"object\") {\n    throw new Error(`${objectName} must be of type object.`);\n  }\n  const valueType = mapper.type.value;\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`,\n    );\n  }\n  const tempDictionary: { [key: string]: any } = {};\n  for (const key of Object.keys(object)) {\n    const serializedValue = serializer.serialize(valueType, object[key], objectName, options);\n    // If the element needs an XML namespace we need to add it within the $ property\n    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n  }\n\n  // Add the namespace to the root element if needed\n  if (isXml && mapper.xmlNamespace) {\n    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n    const result = tempDictionary;\n    result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };\n    return result;\n  }\n\n  return tempDictionary;\n}\n\n/**\n * Resolves the additionalProperties property from a referenced mapper\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveAdditionalProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string,\n): SequenceMapper | BaseMapper | CompositeMapper | DictionaryMapper | EnumMapper | undefined {\n  const additionalProperties = mapper.type.additionalProperties;\n\n  if (!additionalProperties && mapper.type.className) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    return modelMapper?.type.additionalProperties;\n  }\n\n  return additionalProperties;\n}\n\n/**\n * Finds the mapper referenced by className\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveReferencedMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string,\n): CompositeMapper | undefined {\n  const className = mapper.type.className;\n  if (!className) {\n    throw new Error(\n      `Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(\n        mapper,\n        undefined,\n        2,\n      )}\".`,\n    );\n  }\n\n  return serializer.modelMappers[className];\n}\n\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n */\nfunction resolveModelProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string,\n): { [propertyName: string]: Mapper } {\n  let modelProps = mapper.type.modelProperties;\n  if (!modelProps) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    if (!modelMapper) {\n      throw new Error(`mapper() cannot be null or undefined for model \"${mapper.type.className}\".`);\n    }\n    modelProps = modelMapper?.type.modelProperties;\n    if (!modelProps) {\n      throw new Error(\n        `modelProperties cannot be null or undefined in the ` +\n          `mapper \"${JSON.stringify(modelMapper)}\" of type \"${\n            mapper.type.className\n          }\" for object \"${objectName}\".`,\n      );\n    }\n  }\n\n  return modelProps;\n}\n\nfunction serializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: RequiredSerializerOptions,\n): any {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n\n  if (object !== undefined && object !== null) {\n    const payload: any = {};\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n    for (const key of Object.keys(modelProps)) {\n      const propertyMapper = modelProps[key];\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n\n      let propName: string | undefined;\n      let parentObject: any = payload;\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        const paths = splitSerializeName(propertyMapper.serializedName!);\n        propName = paths.pop();\n\n        for (const pathName of paths) {\n          const childObject = parentObject[pathName];\n          if (\n            (childObject === undefined || childObject === null) &&\n            ((object[key] !== undefined && object[key] !== null) ||\n              propertyMapper.defaultValue !== undefined)\n          ) {\n            parentObject[pathName] = {};\n          }\n          parentObject = parentObject[pathName];\n        }\n      }\n\n      if (parentObject !== undefined && parentObject !== null) {\n        if (isXml && mapper.xmlNamespace) {\n          const xmlnsKey = mapper.xmlNamespacePrefix\n            ? `xmlns:${mapper.xmlNamespacePrefix}`\n            : \"xmlns\";\n          parentObject[XML_ATTRKEY] = {\n            ...parentObject[XML_ATTRKEY],\n            [xmlnsKey]: mapper.xmlNamespace,\n          };\n        }\n        const propertyObjectName =\n          propertyMapper.serializedName !== \"\"\n            ? objectName + \".\" + propertyMapper.serializedName\n            : objectName;\n\n        let toSerialize = object[key];\n        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n        if (\n          polymorphicDiscriminator &&\n          polymorphicDiscriminator.clientName === key &&\n          (toSerialize === undefined || toSerialize === null)\n        ) {\n          toSerialize = mapper.serializedName;\n        }\n\n        const serializedValue = serializer.serialize(\n          propertyMapper,\n          toSerialize,\n          propertyObjectName,\n          options,\n        );\n        if (serializedValue !== undefined && propName !== undefined && propName !== null) {\n          const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n          if (isXml && propertyMapper.xmlIsAttribute) {\n            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n            parentObject[XML_ATTRKEY][propName] = serializedValue;\n          } else if (isXml && propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = { [propertyMapper.xmlElementName!]: value };\n          } else {\n            parentObject[propName] = value;\n          }\n        }\n      }\n    }\n\n    const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n    if (additionalPropertiesMapper) {\n      const propNames = Object.keys(modelProps);\n      for (const clientPropName in object) {\n        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(\n            additionalPropertiesMapper,\n            object[clientPropName],\n            objectName + '[\"' + clientPropName + '\"]',\n            options,\n          );\n        }\n      }\n    }\n\n    return payload;\n  }\n  return object;\n}\n\nfunction getXmlObjectValue(\n  propertyMapper: Mapper,\n  serializedValue: any,\n  isXml: boolean,\n  options: RequiredSerializerOptions,\n): any {\n  if (!isXml || !propertyMapper.xmlNamespace) {\n    return serializedValue;\n  }\n\n  const xmlnsKey = propertyMapper.xmlNamespacePrefix\n    ? `xmlns:${propertyMapper.xmlNamespacePrefix}`\n    : \"xmlns\";\n  const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };\n\n  if ([\"Composite\"].includes(propertyMapper.type.name)) {\n    if (serializedValue[XML_ATTRKEY]) {\n      return serializedValue;\n    } else {\n      const result: any = { ...serializedValue };\n      result[XML_ATTRKEY] = xmlNamespace;\n      return result;\n    }\n  }\n  const result: any = {};\n  result[options.xml.xmlCharKey] = serializedValue;\n  result[XML_ATTRKEY] = xmlNamespace;\n  return result;\n}\n\nfunction isSpecialXmlProperty(propertyName: string, options: RequiredSerializerOptions): boolean {\n  return [XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);\n}\n\nfunction deserializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  responseBody: any,\n  objectName: string,\n  options: RequiredSerializerOptions,\n): any {\n  const xmlCharKey = options.xml.xmlCharKey ?? XML_CHARKEY;\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n\n  const modelProps = resolveModelProperties(serializer, mapper, objectName);\n  let instance: { [key: string]: any } = {};\n  const handledPropertyNames: string[] = [];\n\n  for (const key of Object.keys(modelProps)) {\n    const propertyMapper = modelProps[key];\n    const paths = splitSerializeName(modelProps[key].serializedName!);\n    handledPropertyNames.push(paths[0]);\n    const { serializedName, xmlName, xmlElementName } = propertyMapper;\n    let propertyObjectName = objectName;\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n\n    const headerCollectionPrefix = (propertyMapper as DictionaryMapper).headerCollectionPrefix;\n    if (headerCollectionPrefix) {\n      const dictionary: any = {};\n      for (const headerKey of Object.keys(responseBody)) {\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(\n            (propertyMapper as DictionaryMapper).type.value,\n            responseBody[headerKey],\n            propertyObjectName,\n            options,\n          );\n        }\n\n        handledPropertyNames.push(headerKey);\n      }\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n        instance[key] = serializer.deserialize(\n          propertyMapper,\n          responseBody[XML_ATTRKEY][xmlName!],\n          propertyObjectName,\n          options,\n        );\n      } else if (propertyMapper.xmlIsMsText) {\n        if (responseBody[xmlCharKey] !== undefined) {\n          instance[key] = responseBody[xmlCharKey];\n        } else if (typeof responseBody === \"string\") {\n          // The special case where xml parser parses \"<Name>content</Name>\" into JSON of\n          //   `{ name: \"content\"}` instead of `{ name: { \"_\": \"content\" }}`\n          instance[key] = responseBody;\n        }\n      } else {\n        const propertyName = xmlElementName || xmlName || serializedName;\n        if (propertyMapper.xmlIsWrapped) {\n          /* a list of <xmlElementName> wrapped by <xmlName>\n            For the xml example below\n              <Cors>\n                <CorsRule>...</CorsRule>\n                <CorsRule>...</CorsRule>\n              </Cors>\n            the responseBody has\n              {\n                Cors: {\n                  CorsRule: [{...}, {...}]\n                }\n              }\n            xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n          */\n          const wrapped = responseBody[xmlName!];\n          const elementList = wrapped?.[xmlElementName!] ?? [];\n          instance[key] = serializer.deserialize(\n            propertyMapper,\n            elementList,\n            propertyObjectName,\n            options,\n          );\n          handledPropertyNames.push(xmlName!);\n        } else {\n          const property = responseBody[propertyName!];\n          instance[key] = serializer.deserialize(\n            propertyMapper,\n            property,\n            propertyObjectName,\n            options,\n          );\n          handledPropertyNames.push(propertyName!);\n        }\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      let propertyInstance;\n      let res = responseBody;\n      // traversing the object step by step.\n      let steps = 0;\n      for (const item of paths) {\n        if (!res) break;\n        steps++;\n        res = res[item];\n      }\n      // only accept null when reaching the last position of object otherwise it would be undefined\n      if (res === null && steps < paths.length) {\n        res = undefined;\n      }\n      propertyInstance = res;\n      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n      // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n      if (\n        polymorphicDiscriminator &&\n        key === polymorphicDiscriminator.clientName &&\n        (propertyInstance === undefined || propertyInstance === null)\n      ) {\n        propertyInstance = mapper.serializedName;\n      }\n\n      let serializedValue;\n      // paging\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        const arrayInstance = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName,\n          options,\n        );\n        // Copy over any properties that have already been added into the instance, where they do\n        // not exist on the newly de-serialized array\n        for (const [k, v] of Object.entries(instance)) {\n          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {\n            arrayInstance[k] = v;\n          }\n        }\n        instance = arrayInstance;\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName,\n          options,\n        );\n        instance[key] = serializedValue;\n      }\n    }\n  }\n\n  const additionalPropertiesMapper = mapper.type.additionalProperties;\n  if (additionalPropertiesMapper) {\n    const isAdditionalProperty = (responsePropName: string): boolean => {\n      for (const clientPropName in modelProps) {\n        const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    for (const responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(\n          additionalPropertiesMapper,\n          responseBody[responsePropName],\n          objectName + '[\"' + responsePropName + '\"]',\n          options,\n        );\n      }\n    }\n  } else if (responseBody && !options.ignoreUnknownProperties) {\n    for (const key of Object.keys(responseBody)) {\n      if (\n        instance[key] === undefined &&\n        !handledPropertyNames.includes(key) &&\n        !isSpecialXmlProperty(key, options)\n      ) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n\n  return instance;\n}\n\nfunction deserializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  responseBody: any,\n  objectName: string,\n  options: RequiredSerializerOptions,\n): any {\n  /* jshint validthis: true */\n  const value = mapper.type.value;\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`,\n    );\n  }\n  if (responseBody) {\n    const tempDictionary: { [key: string]: any } = {};\n    for (const key of Object.keys(responseBody)) {\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n    }\n    return tempDictionary;\n  }\n  return responseBody;\n}\n\nfunction deserializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  responseBody: any,\n  objectName: string,\n  options: RequiredSerializerOptions,\n): any {\n  let element = mapper.type.element;\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`,\n    );\n  }\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n\n    // Quirk: Composite mappers referenced by `element` might\n    // not have *all* properties declared (like uberParent),\n    // so let's try to look up the full definition by name.\n    if (element.type.name === \"Composite\" && element.type.className) {\n      element = serializer.modelMappers[element.type.className] ?? element;\n    }\n\n    const tempArray = [];\n    for (let i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(\n        element,\n        responseBody[i],\n        `${objectName}[${i}]`,\n        options,\n      );\n    }\n    return tempArray;\n  }\n  return responseBody;\n}\n\nfunction getIndexDiscriminator(\n  discriminators: Record<string, CompositeMapper>,\n  discriminatorValue: string,\n  typeName: string,\n): CompositeMapper | undefined {\n  const typeNamesToCheck = [typeName];\n  while (typeNamesToCheck.length) {\n    const currentName = typeNamesToCheck.shift();\n    const indexDiscriminator =\n      discriminatorValue === currentName\n        ? discriminatorValue\n        : currentName + \".\" + discriminatorValue;\n    if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {\n      return discriminators[indexDiscriminator];\n    } else {\n      for (const [name, mapper] of Object.entries(discriminators)) {\n        if (\n          name.startsWith(currentName + \".\") &&\n          mapper.type.uberParent === currentName &&\n          mapper.type.className\n        ) {\n          typeNamesToCheck.push(mapper.type.className);\n        }\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction getPolymorphicMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  polymorphicPropertyName: \"clientName\" | \"serializedName\",\n): CompositeMapper {\n  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n\n  if (polymorphicDiscriminator) {\n    let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n    if (discriminatorName) {\n      // The serializedName might have \\\\, which we just want to ignore\n      if (polymorphicPropertyName === \"serializedName\") {\n        discriminatorName = discriminatorName.replace(/\\\\/gi, \"\");\n      }\n      const discriminatorValue = object[discriminatorName];\n      const typeName = mapper.type.uberParent ?? mapper.type.className;\n\n      if (typeof discriminatorValue === \"string\" && typeName) {\n        const polymorphicMapper = getIndexDiscriminator(\n          serializer.modelMappers.discriminators,\n          discriminatorValue,\n          typeName,\n        );\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n  return mapper;\n}\n\nfunction getPolymorphicDiscriminatorRecursively(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n): PolymorphicDiscriminator | undefined {\n  return (\n    mapper.type.polymorphicDiscriminator ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.className)\n  );\n}\n\nfunction getPolymorphicDiscriminatorSafely(\n  serializer: Serializer,\n  typeName?: string,\n): PolymorphicDiscriminator | undefined {\n  return (\n    typeName &&\n    serializer.modelMappers[typeName] &&\n    serializer.modelMappers[typeName].type.polymorphicDiscriminator\n  );\n}\n\n/**\n * Known types of Mappers\n */\nexport const MapperTypeNames = {\n  Base64Url: \"Base64Url\",\n  Boolean: \"Boolean\",\n  ByteArray: \"ByteArray\",\n  Composite: \"Composite\",\n  Date: \"Date\",\n  DateTime: \"DateTime\",\n  DateTimeRfc1123: \"DateTimeRfc1123\",\n  Dictionary: \"Dictionary\",\n  Enum: \"Enum\",\n  Number: \"Number\",\n  Object: \"Object\",\n  Sequence: \"Sequence\",\n  String: \"String\",\n  Stream: \"Stream\",\n  TimeSpan: \"TimeSpan\",\n  UnixTime: \"UnixTime\",\n} as const;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}