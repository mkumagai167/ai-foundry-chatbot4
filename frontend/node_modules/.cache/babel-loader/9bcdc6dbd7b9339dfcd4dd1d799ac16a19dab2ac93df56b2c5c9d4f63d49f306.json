{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createHttpHeaders } from \"@azure/core-rest-pipeline\";\nimport { toHttpHeadersLike } from \"@azure/core-http-compat\";\nimport { HTTP_VERSION_1_1, HTTP_LINE_ENDING, HeaderConstants, HTTPURLConnection } from \"./utils/constants.js\";\nimport { getBodyAsText } from \"./BatchUtils.js\";\nimport { logger } from \"./log.js\";\nconst HTTP_HEADER_DELIMITER = \": \";\nconst SPACE_DELIMITER = \" \";\nconst NOT_FOUND = -1;\n/**\n * Util class for parsing batch response.\n */\nexport class BatchResponseParser {\n  batchResponse;\n  responseBatchBoundary;\n  perResponsePrefix;\n  batchResponseEnding;\n  subRequests;\n  constructor(batchResponse, subRequests) {\n    if (!batchResponse || !batchResponse.contentType) {\n      // In special case(reported), server may return invalid content-type which could not be parsed.\n      throw new RangeError(\"batchResponse is malformed or doesn't contain valid content-type.\");\n    }\n    if (!subRequests || subRequests.size === 0) {\n      // This should be prevent during coding.\n      throw new RangeError(\"Invalid state: subRequests is not provided or size is 0.\");\n    }\n    this.batchResponse = batchResponse;\n    this.subRequests = subRequests;\n    this.responseBatchBoundary = this.batchResponse.contentType.split(\"=\")[1];\n    this.perResponsePrefix = `--${this.responseBatchBoundary}${HTTP_LINE_ENDING}`;\n    this.batchResponseEnding = `--${this.responseBatchBoundary}--`;\n  }\n  // For example of response, please refer to https://learn.microsoft.com/rest/api/storageservices/blob-batch#response\n  async parseBatchResponse() {\n    // When logic reach here, suppose batch request has already succeeded with 202, so we can further parse\n    // sub request's response.\n    if (this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED) {\n      throw new Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`);\n    }\n    const responseBodyAsText = await getBodyAsText(this.batchResponse);\n    const subResponses = responseBodyAsText.split(this.batchResponseEnding)[0] // string after ending is useless\n    .split(this.perResponsePrefix).slice(1); // string before first response boundary is useless\n    const subResponseCount = subResponses.length;\n    // Defensive coding in case of potential error parsing.\n    // Note: subResponseCount == 1 is special case where sub request is invalid.\n    // We try to prevent such cases through early validation, e.g. validate sub request count >= 1.\n    // While in unexpected sub request invalid case, we allow sub response to be parsed and return to user.\n    if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) {\n      throw new Error(\"Invalid state: sub responses' count is not equal to sub requests' count.\");\n    }\n    const deserializedSubResponses = new Array(subResponseCount);\n    let subResponsesSucceededCount = 0;\n    let subResponsesFailedCount = 0;\n    // Parse sub subResponses.\n    for (let index = 0; index < subResponseCount; index++) {\n      const subResponse = subResponses[index];\n      const deserializedSubResponse = {};\n      deserializedSubResponse.headers = toHttpHeadersLike(createHttpHeaders());\n      const responseLines = subResponse.split(`${HTTP_LINE_ENDING}`);\n      let subRespHeaderStartFound = false;\n      let subRespHeaderEndFound = false;\n      let subRespFailed = false;\n      let contentId = NOT_FOUND;\n      for (const responseLine of responseLines) {\n        if (!subRespHeaderStartFound) {\n          // Convention line to indicate content ID\n          if (responseLine.startsWith(HeaderConstants.CONTENT_ID)) {\n            contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);\n          }\n          // Http version line with status code indicates the start of sub request's response.\n          // Example: HTTP/1.1 202 Accepted\n          if (responseLine.startsWith(HTTP_VERSION_1_1)) {\n            subRespHeaderStartFound = true;\n            const tokens = responseLine.split(SPACE_DELIMITER);\n            deserializedSubResponse.status = parseInt(tokens[1]);\n            deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);\n          }\n          continue; // Skip convention headers not specifically for sub request i.e. Content-Type: application/http and Content-ID: *\n        }\n        if (responseLine.trim() === \"\") {\n          // Sub response's header start line already found, and the first empty line indicates header end line found.\n          if (!subRespHeaderEndFound) {\n            subRespHeaderEndFound = true;\n          }\n          continue; // Skip empty line\n        }\n        // Note: when code reach here, it indicates subRespHeaderStartFound == true\n        if (!subRespHeaderEndFound) {\n          if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {\n            // Defensive coding to prevent from missing valuable lines.\n            throw new Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);\n          }\n          // Parse headers of sub response.\n          const tokens = responseLine.split(HTTP_HEADER_DELIMITER);\n          deserializedSubResponse.headers.set(tokens[0], tokens[1]);\n          if (tokens[0] === HeaderConstants.X_MS_ERROR_CODE) {\n            deserializedSubResponse.errorCode = tokens[1];\n            subRespFailed = true;\n          }\n        } else {\n          // Assemble body of sub response.\n          if (!deserializedSubResponse.bodyAsText) {\n            deserializedSubResponse.bodyAsText = \"\";\n          }\n          deserializedSubResponse.bodyAsText += responseLine;\n        }\n      } // Inner for end\n      // The response will contain the Content-ID header for each corresponding subrequest response to use for tracking.\n      // The Content-IDs are set to a valid index in the subrequests we sent. In the status code 202 path, we could expect it\n      // to be 1-1 mapping from the [0, subRequests.size) to the Content-IDs returned. If not, we simply don't return that\n      // unexpected subResponse in the parsed reponse and we can always look it up in the raw response for debugging purpose.\n      if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && deserializedSubResponses[contentId] === undefined) {\n        deserializedSubResponse._request = this.subRequests.get(contentId);\n        deserializedSubResponses[contentId] = deserializedSubResponse;\n      } else {\n        logger.error(`subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);\n      }\n      if (subRespFailed) {\n        subResponsesFailedCount++;\n      } else {\n        subResponsesSucceededCount++;\n      }\n    }\n    return {\n      subResponses: deserializedSubResponses,\n      subResponsesSucceededCount: subResponsesSucceededCount,\n      subResponsesFailedCount: subResponsesFailedCount\n    };\n  }\n}","map":{"version":3,"names":["createHttpHeaders","toHttpHeadersLike","HTTP_VERSION_1_1","HTTP_LINE_ENDING","HeaderConstants","HTTPURLConnection","getBodyAsText","logger","HTTP_HEADER_DELIMITER","SPACE_DELIMITER","NOT_FOUND","BatchResponseParser","batchResponse","responseBatchBoundary","perResponsePrefix","batchResponseEnding","subRequests","constructor","contentType","RangeError","size","split","parseBatchResponse","_response","status","HTTP_ACCEPTED","Error","responseBodyAsText","subResponses","slice","subResponseCount","length","deserializedSubResponses","Array","subResponsesSucceededCount","subResponsesFailedCount","index","subResponse","deserializedSubResponse","headers","responseLines","subRespHeaderStartFound","subRespHeaderEndFound","subRespFailed","contentId","responseLine","startsWith","CONTENT_ID","parseInt","tokens","statusMessage","join","trim","indexOf","set","X_MS_ERROR_CODE","errorCode","bodyAsText","Number","isInteger","undefined","_request","get","error"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@azure\\storage-blob\\src\\BatchResponseParser.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { createHttpHeaders } from \"@azure/core-rest-pipeline\";\nimport { toHttpHeadersLike } from \"@azure/core-http-compat\";\n\nimport type { ServiceSubmitBatchResponseModel } from \"./generatedModels.js\";\nimport {\n  HTTP_VERSION_1_1,\n  HTTP_LINE_ENDING,\n  HeaderConstants,\n  HTTPURLConnection,\n} from \"./utils/constants.js\";\nimport { getBodyAsText } from \"./BatchUtils.js\";\nimport type { BatchSubRequest } from \"./BlobBatch.js\";\nimport type { BatchSubResponse, ParsedBatchResponse } from \"./BatchResponse.js\";\nimport { logger } from \"./log.js\";\n\nconst HTTP_HEADER_DELIMITER = \": \";\nconst SPACE_DELIMITER = \" \";\nconst NOT_FOUND = -1;\n\n/**\n * Util class for parsing batch response.\n */\nexport class BatchResponseParser {\n  private readonly batchResponse: ServiceSubmitBatchResponseModel;\n  private readonly responseBatchBoundary: string;\n  private readonly perResponsePrefix: string;\n  private readonly batchResponseEnding: string;\n  private readonly subRequests: Map<number, BatchSubRequest>;\n\n  constructor(\n    batchResponse: ServiceSubmitBatchResponseModel,\n    subRequests: Map<number, BatchSubRequest>,\n  ) {\n    if (!batchResponse || !batchResponse.contentType) {\n      // In special case(reported), server may return invalid content-type which could not be parsed.\n      throw new RangeError(\"batchResponse is malformed or doesn't contain valid content-type.\");\n    }\n\n    if (!subRequests || subRequests.size === 0) {\n      // This should be prevent during coding.\n      throw new RangeError(\"Invalid state: subRequests is not provided or size is 0.\");\n    }\n\n    this.batchResponse = batchResponse;\n    this.subRequests = subRequests;\n    this.responseBatchBoundary = this.batchResponse.contentType!.split(\"=\")[1];\n    this.perResponsePrefix = `--${this.responseBatchBoundary}${HTTP_LINE_ENDING}`;\n    this.batchResponseEnding = `--${this.responseBatchBoundary}--`;\n  }\n\n  // For example of response, please refer to https://learn.microsoft.com/rest/api/storageservices/blob-batch#response\n  public async parseBatchResponse(): Promise<ParsedBatchResponse> {\n    // When logic reach here, suppose batch request has already succeeded with 202, so we can further parse\n    // sub request's response.\n    if (this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED) {\n      throw new Error(\n        `Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`,\n      );\n    }\n\n    const responseBodyAsText = await getBodyAsText(this.batchResponse);\n\n    const subResponses = responseBodyAsText\n      .split(this.batchResponseEnding)[0] // string after ending is useless\n      .split(this.perResponsePrefix)\n      .slice(1); // string before first response boundary is useless\n    const subResponseCount = subResponses.length;\n\n    // Defensive coding in case of potential error parsing.\n    // Note: subResponseCount == 1 is special case where sub request is invalid.\n    // We try to prevent such cases through early validation, e.g. validate sub request count >= 1.\n    // While in unexpected sub request invalid case, we allow sub response to be parsed and return to user.\n    if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) {\n      throw new Error(\"Invalid state: sub responses' count is not equal to sub requests' count.\");\n    }\n\n    const deserializedSubResponses: Array<BatchSubResponse> = new Array(subResponseCount);\n    let subResponsesSucceededCount: number = 0;\n    let subResponsesFailedCount: number = 0;\n\n    // Parse sub subResponses.\n    for (let index = 0; index < subResponseCount; index++) {\n      const subResponse = subResponses[index];\n      const deserializedSubResponse = {} as BatchSubResponse;\n      deserializedSubResponse.headers = toHttpHeadersLike(createHttpHeaders());\n\n      const responseLines = subResponse.split(`${HTTP_LINE_ENDING}`);\n      let subRespHeaderStartFound = false;\n      let subRespHeaderEndFound = false;\n      let subRespFailed = false;\n      let contentId = NOT_FOUND;\n\n      for (const responseLine of responseLines) {\n        if (!subRespHeaderStartFound) {\n          // Convention line to indicate content ID\n          if (responseLine.startsWith(HeaderConstants.CONTENT_ID)) {\n            contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);\n          }\n\n          // Http version line with status code indicates the start of sub request's response.\n          // Example: HTTP/1.1 202 Accepted\n          if (responseLine.startsWith(HTTP_VERSION_1_1)) {\n            subRespHeaderStartFound = true;\n\n            const tokens = responseLine.split(SPACE_DELIMITER);\n            deserializedSubResponse.status = parseInt(tokens[1]);\n            deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);\n          }\n\n          continue; // Skip convention headers not specifically for sub request i.e. Content-Type: application/http and Content-ID: *\n        }\n\n        if (responseLine.trim() === \"\") {\n          // Sub response's header start line already found, and the first empty line indicates header end line found.\n          if (!subRespHeaderEndFound) {\n            subRespHeaderEndFound = true;\n          }\n\n          continue; // Skip empty line\n        }\n\n        // Note: when code reach here, it indicates subRespHeaderStartFound == true\n        if (!subRespHeaderEndFound) {\n          if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {\n            // Defensive coding to prevent from missing valuable lines.\n            throw new Error(\n              `Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`,\n            );\n          }\n\n          // Parse headers of sub response.\n          const tokens = responseLine.split(HTTP_HEADER_DELIMITER);\n          deserializedSubResponse.headers.set(tokens[0], tokens[1]);\n          if (tokens[0] === HeaderConstants.X_MS_ERROR_CODE) {\n            deserializedSubResponse.errorCode = tokens[1];\n            subRespFailed = true;\n          }\n        } else {\n          // Assemble body of sub response.\n          if (!deserializedSubResponse.bodyAsText) {\n            deserializedSubResponse.bodyAsText = \"\";\n          }\n\n          deserializedSubResponse.bodyAsText += responseLine;\n        }\n      } // Inner for end\n\n      // The response will contain the Content-ID header for each corresponding subrequest response to use for tracking.\n      // The Content-IDs are set to a valid index in the subrequests we sent. In the status code 202 path, we could expect it\n      // to be 1-1 mapping from the [0, subRequests.size) to the Content-IDs returned. If not, we simply don't return that\n      // unexpected subResponse in the parsed reponse and we can always look it up in the raw response for debugging purpose.\n      if (\n        contentId !== NOT_FOUND &&\n        Number.isInteger(contentId) &&\n        contentId >= 0 &&\n        contentId < this.subRequests.size &&\n        deserializedSubResponses[contentId] === undefined\n      ) {\n        deserializedSubResponse._request = this.subRequests.get(contentId)!;\n        deserializedSubResponses[contentId] = deserializedSubResponse;\n      } else {\n        logger.error(\n          `subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`,\n        );\n      }\n\n      if (subRespFailed) {\n        subResponsesFailedCount++;\n      } else {\n        subResponsesSucceededCount++;\n      }\n    }\n\n    return {\n      subResponses: deserializedSubResponses,\n      subResponsesSucceededCount: subResponsesSucceededCount,\n      subResponsesFailedCount: subResponsesFailedCount,\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}