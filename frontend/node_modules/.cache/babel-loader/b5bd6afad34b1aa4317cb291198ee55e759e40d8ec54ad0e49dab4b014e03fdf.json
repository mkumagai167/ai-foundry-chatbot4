{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { RestError } from \"../restError.js\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\nimport { stringToUint8Array } from \"../util/bytesEncoding.js\";\nimport { isBinaryBody } from \"../util/typeGuards.js\";\n/**\n * Get value of a header in the part descriptor ignoring case\n */\nfunction getHeaderValue(descriptor, headerName) {\n  if (descriptor.headers) {\n    const actualHeaderName = Object.keys(descriptor.headers).find(x => x.toLowerCase() === headerName.toLowerCase());\n    if (actualHeaderName) {\n      return descriptor.headers[actualHeaderName];\n    }\n  }\n  return undefined;\n}\nfunction getPartContentType(descriptor) {\n  const contentTypeHeader = getHeaderValue(descriptor, \"content-type\");\n  if (contentTypeHeader) {\n    return contentTypeHeader;\n  }\n  // Special value of null means content type is to be omitted\n  if (descriptor.contentType === null) {\n    return undefined;\n  }\n  if (descriptor.contentType) {\n    return descriptor.contentType;\n  }\n  const {\n    body\n  } = descriptor;\n  if (body === null || body === undefined) {\n    return undefined;\n  }\n  if (typeof body === \"string\" || typeof body === \"number\" || typeof body === \"boolean\") {\n    return \"text/plain; charset=UTF-8\";\n  }\n  if (body instanceof Blob) {\n    return body.type || \"application/octet-stream\";\n  }\n  if (isBinaryBody(body)) {\n    return \"application/octet-stream\";\n  }\n  // arbitrary non-text object -> generic JSON content type by default. We will try to JSON.stringify the body.\n  return \"application/json\";\n}\n/**\n * Enclose value in quotes and escape special characters, for use in the Content-Disposition header\n */\nfunction escapeDispositionField(value) {\n  return JSON.stringify(value);\n}\nfunction getContentDisposition(descriptor) {\n  const contentDispositionHeader = getHeaderValue(descriptor, \"content-disposition\");\n  if (contentDispositionHeader) {\n    return contentDispositionHeader;\n  }\n  if (descriptor.dispositionType === undefined && descriptor.name === undefined && descriptor.filename === undefined) {\n    return undefined;\n  }\n  const dispositionType = descriptor.dispositionType ?? \"form-data\";\n  let disposition = dispositionType;\n  if (descriptor.name) {\n    disposition += `; name=${escapeDispositionField(descriptor.name)}`;\n  }\n  let filename = undefined;\n  if (descriptor.filename) {\n    filename = descriptor.filename;\n  } else if (typeof File !== \"undefined\" && descriptor.body instanceof File) {\n    const filenameFromFile = descriptor.body.name;\n    if (filenameFromFile !== \"\") {\n      filename = filenameFromFile;\n    }\n  }\n  if (filename) {\n    disposition += `; filename=${escapeDispositionField(filename)}`;\n  }\n  return disposition;\n}\nfunction normalizeBody(body, contentType) {\n  if (body === undefined) {\n    // zero-length body\n    return new Uint8Array([]);\n  }\n  // binary and primitives should go straight on the wire regardless of content type\n  if (isBinaryBody(body)) {\n    return body;\n  }\n  if (typeof body === \"string\" || typeof body === \"number\" || typeof body === \"boolean\") {\n    return stringToUint8Array(String(body), \"utf-8\");\n  }\n  // stringify objects for JSON-ish content types e.g. application/json, application/merge-patch+json, application/vnd.oci.manifest.v1+json, application.json; charset=UTF-8\n  if (contentType && /application\\/(.+\\+)?json(;.+)?/i.test(String(contentType))) {\n    return stringToUint8Array(JSON.stringify(body), \"utf-8\");\n  }\n  throw new RestError(`Unsupported body/content-type combination: ${body}, ${contentType}`);\n}\nexport function buildBodyPart(descriptor) {\n  const contentType = getPartContentType(descriptor);\n  const contentDisposition = getContentDisposition(descriptor);\n  const headers = createHttpHeaders(descriptor.headers ?? {});\n  if (contentType) {\n    headers.set(\"content-type\", contentType);\n  }\n  if (contentDisposition) {\n    headers.set(\"content-disposition\", contentDisposition);\n  }\n  const body = normalizeBody(descriptor.body, contentType);\n  return {\n    headers,\n    body\n  };\n}\nexport function buildMultipartBody(parts) {\n  return {\n    parts: parts.map(buildBodyPart)\n  };\n}","map":{"version":3,"names":["RestError","createHttpHeaders","stringToUint8Array","isBinaryBody","getHeaderValue","descriptor","headerName","headers","actualHeaderName","Object","keys","find","x","toLowerCase","undefined","getPartContentType","contentTypeHeader","contentType","body","Blob","type","escapeDispositionField","value","JSON","stringify","getContentDisposition","contentDispositionHeader","dispositionType","name","filename","disposition","File","filenameFromFile","normalizeBody","Uint8Array","String","test","buildBodyPart","contentDisposition","set","buildMultipartBody","parts","map"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@typespec\\ts-http-runtime\\src\\client\\multipart.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { BodyPart, MultipartRequestBody, RawHttpHeadersInput } from \"../interfaces.js\";\nimport { RestError } from \"../restError.js\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\nimport { stringToUint8Array } from \"../util/bytesEncoding.js\";\nimport { isBinaryBody } from \"../util/typeGuards.js\";\n\n/**\n * Describes a single part in a multipart body.\n */\nexport interface PartDescriptor {\n  /**\n   * Content type of this part. If set, this value will be used to set the Content-Type MIME header for this part, although explicitly\n   * setting the Content-Type header in the headers bag will override this value. If set to `null`, no content type will be inferred from\n   * the body field. Otherwise, the value of the Content-Type MIME header will be inferred based on the type of the body.\n   */\n  contentType?: string | null;\n\n  /**\n   * The disposition type of this part (for example, \"form-data\" for parts making up a multipart/form-data request). If set, this value\n   * will be used to set the Content-Disposition MIME header for this part, in addition to the `name` and `filename` properties.\n   * If the `name` or `filename` properties are set while `dispositionType` is left undefined, `dispositionType` will default to \"form-data\".\n   *\n   * Explicitly setting the Content-Disposition header in the headers bag will override this value.\n   */\n  dispositionType?: string;\n\n  /**\n   * The field name associated with this part. This value will be used to construct the Content-Disposition header,\n   * along with the `dispositionType` and `filename` properties, if the header has not been set in the `headers` bag.\n   */\n  name?: string;\n\n  /**\n   * The file name of the content if it is a file. This value will be used to construct the Content-Disposition header,\n   * along with the `dispositionType` and `name` properties, if the header has not been set in the `headers` bag.\n   */\n  filename?: string;\n\n  /**\n   * The multipart headers for this part of the multipart body. Values of the Content-Type and Content-Disposition headers set in the headers bag\n   * will take precedence over those computed from the request body or the contentType, dispositionType, name, and filename fields on this object.\n   */\n  headers?: RawHttpHeadersInput;\n\n  /**\n   * The body of this part of the multipart request.\n   */\n  body?: unknown;\n}\n\ntype MultipartBodyType = BodyPart[\"body\"];\n\ntype HeaderValue = RawHttpHeadersInput[string];\n\n/**\n * Get value of a header in the part descriptor ignoring case\n */\nfunction getHeaderValue(descriptor: PartDescriptor, headerName: string): HeaderValue | undefined {\n  if (descriptor.headers) {\n    const actualHeaderName = Object.keys(descriptor.headers).find(\n      (x) => x.toLowerCase() === headerName.toLowerCase(),\n    );\n    if (actualHeaderName) {\n      return descriptor.headers[actualHeaderName];\n    }\n  }\n\n  return undefined;\n}\n\nfunction getPartContentType(descriptor: PartDescriptor): HeaderValue | undefined {\n  const contentTypeHeader = getHeaderValue(descriptor, \"content-type\");\n  if (contentTypeHeader) {\n    return contentTypeHeader;\n  }\n\n  // Special value of null means content type is to be omitted\n  if (descriptor.contentType === null) {\n    return undefined;\n  }\n\n  if (descriptor.contentType) {\n    return descriptor.contentType;\n  }\n\n  const { body } = descriptor;\n\n  if (body === null || body === undefined) {\n    return undefined;\n  }\n\n  if (typeof body === \"string\" || typeof body === \"number\" || typeof body === \"boolean\") {\n    return \"text/plain; charset=UTF-8\";\n  }\n\n  if (body instanceof Blob) {\n    return body.type || \"application/octet-stream\";\n  }\n\n  if (isBinaryBody(body)) {\n    return \"application/octet-stream\";\n  }\n\n  // arbitrary non-text object -> generic JSON content type by default. We will try to JSON.stringify the body.\n  return \"application/json\";\n}\n\n/**\n * Enclose value in quotes and escape special characters, for use in the Content-Disposition header\n */\nfunction escapeDispositionField(value: string): string {\n  return JSON.stringify(value);\n}\n\nfunction getContentDisposition(descriptor: PartDescriptor): HeaderValue | undefined {\n  const contentDispositionHeader = getHeaderValue(descriptor, \"content-disposition\");\n  if (contentDispositionHeader) {\n    return contentDispositionHeader;\n  }\n\n  if (\n    descriptor.dispositionType === undefined &&\n    descriptor.name === undefined &&\n    descriptor.filename === undefined\n  ) {\n    return undefined;\n  }\n\n  const dispositionType = descriptor.dispositionType ?? \"form-data\";\n\n  let disposition = dispositionType;\n  if (descriptor.name) {\n    disposition += `; name=${escapeDispositionField(descriptor.name)}`;\n  }\n\n  let filename: string | undefined = undefined;\n  if (descriptor.filename) {\n    filename = descriptor.filename;\n  } else if (typeof File !== \"undefined\" && descriptor.body instanceof File) {\n    const filenameFromFile = (descriptor.body as File).name;\n    if (filenameFromFile !== \"\") {\n      filename = filenameFromFile;\n    }\n  }\n\n  if (filename) {\n    disposition += `; filename=${escapeDispositionField(filename)}`;\n  }\n\n  return disposition;\n}\n\nfunction normalizeBody(body?: unknown, contentType?: HeaderValue): MultipartBodyType {\n  if (body === undefined) {\n    // zero-length body\n    return new Uint8Array([]);\n  }\n\n  // binary and primitives should go straight on the wire regardless of content type\n  if (isBinaryBody(body)) {\n    return body;\n  }\n  if (typeof body === \"string\" || typeof body === \"number\" || typeof body === \"boolean\") {\n    return stringToUint8Array(String(body), \"utf-8\");\n  }\n\n  // stringify objects for JSON-ish content types e.g. application/json, application/merge-patch+json, application/vnd.oci.manifest.v1+json, application.json; charset=UTF-8\n  if (contentType && /application\\/(.+\\+)?json(;.+)?/i.test(String(contentType))) {\n    return stringToUint8Array(JSON.stringify(body), \"utf-8\");\n  }\n\n  throw new RestError(`Unsupported body/content-type combination: ${body}, ${contentType}`);\n}\n\nexport function buildBodyPart(descriptor: PartDescriptor): BodyPart {\n  const contentType = getPartContentType(descriptor);\n  const contentDisposition = getContentDisposition(descriptor);\n  const headers = createHttpHeaders(descriptor.headers ?? {});\n\n  if (contentType) {\n    headers.set(\"content-type\", contentType);\n  }\n  if (contentDisposition) {\n    headers.set(\"content-disposition\", contentDisposition);\n  }\n\n  const body = normalizeBody(descriptor.body, contentType);\n\n  return {\n    headers,\n    body,\n  };\n}\n\nexport function buildMultipartBody(parts: PartDescriptor[]): MultipartRequestBody {\n  return { parts: parts.map(buildBodyPart) };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}