{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n// In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\nimport { EventEmitter } from \"events\";\n/**\n * States for Batch.\n */\nvar BatchStates;\n(function (BatchStates) {\n  BatchStates[BatchStates[\"Good\"] = 0] = \"Good\";\n  BatchStates[BatchStates[\"Error\"] = 1] = \"Error\";\n})(BatchStates || (BatchStates = {}));\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n */\nexport class Batch {\n  /**\n   * Concurrency. Must be lager than 0.\n   */\n  concurrency;\n  /**\n   * Number of active operations under execution.\n   */\n  actives = 0;\n  /**\n   * Number of completed operations under execution.\n   */\n  completed = 0;\n  /**\n   * Offset of next operation to be executed.\n   */\n  offset = 0;\n  /**\n   * Operation array to be executed.\n   */\n  operations = [];\n  /**\n   * States of Batch. When an error happens, state will turn into error.\n   * Batch will stop execute left operations.\n   */\n  state = BatchStates.Good;\n  /**\n   * A private emitter used to pass events inside this class.\n   */\n  emitter;\n  /**\n   * Creates an instance of Batch.\n   * @param concurrency -\n   */\n  constructor(concurrency = 5) {\n    if (concurrency < 1) {\n      throw new RangeError(\"concurrency must be larger than 0\");\n    }\n    this.concurrency = concurrency;\n    this.emitter = new EventEmitter();\n  }\n  /**\n   * Add a operation into queue.\n   *\n   * @param operation -\n   */\n  addOperation(operation) {\n    this.operations.push(async () => {\n      try {\n        this.actives++;\n        await operation();\n        this.actives--;\n        this.completed++;\n        this.parallelExecute();\n      } catch (error) {\n        this.emitter.emit(\"error\", error);\n      }\n    });\n  }\n  /**\n   * Start execute operations in the queue.\n   *\n   */\n  async do() {\n    if (this.operations.length === 0) {\n      return Promise.resolve();\n    }\n    this.parallelExecute();\n    return new Promise((resolve, reject) => {\n      this.emitter.on(\"finish\", resolve);\n      this.emitter.on(\"error\", error => {\n        this.state = BatchStates.Error;\n        reject(error);\n      });\n    });\n  }\n  /**\n   * Get next operation to be executed. Return null when reaching ends.\n   *\n   */\n  nextOperation() {\n    if (this.offset < this.operations.length) {\n      return this.operations[this.offset++];\n    }\n    return null;\n  }\n  /**\n   * Start execute operations. One one the most important difference between\n   * this method with do() is that do() wraps as an sync method.\n   *\n   */\n  parallelExecute() {\n    if (this.state === BatchStates.Error) {\n      return;\n    }\n    if (this.completed >= this.operations.length) {\n      this.emitter.emit(\"finish\");\n      return;\n    }\n    while (this.actives < this.concurrency) {\n      const operation = this.nextOperation();\n      if (operation) {\n        operation();\n      } else {\n        return;\n      }\n    }\n  }\n}","map":{"version":3,"names":["EventEmitter","BatchStates","Batch","concurrency","actives","completed","offset","operations","state","Good","emitter","constructor","RangeError","addOperation","operation","push","parallelExecute","error","emit","do","length","Promise","resolve","reject","on","Error","nextOperation"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@azure\\storage-blob\\src\\utils\\Batch.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n// In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\nimport { EventEmitter } from \"events\";\n\n/**\n * Operation is an async function to be executed and managed by Batch.\n */\nexport declare type Operation = () => Promise<any>;\n\n/**\n * States for Batch.\n */\nenum BatchStates {\n  Good,\n  Error,\n}\n\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n */\nexport class Batch {\n  /**\n   * Concurrency. Must be lager than 0.\n   */\n  private concurrency: number;\n\n  /**\n   * Number of active operations under execution.\n   */\n  private actives: number = 0;\n\n  /**\n   * Number of completed operations under execution.\n   */\n  private completed: number = 0;\n\n  /**\n   * Offset of next operation to be executed.\n   */\n  private offset: number = 0;\n\n  /**\n   * Operation array to be executed.\n   */\n  private operations: Operation[] = [];\n\n  /**\n   * States of Batch. When an error happens, state will turn into error.\n   * Batch will stop execute left operations.\n   */\n  private state: BatchStates = BatchStates.Good;\n\n  /**\n   * A private emitter used to pass events inside this class.\n   */\n  private emitter: EventEmitter;\n\n  /**\n   * Creates an instance of Batch.\n   * @param concurrency -\n   */\n  public constructor(concurrency: number = 5) {\n    if (concurrency < 1) {\n      throw new RangeError(\"concurrency must be larger than 0\");\n    }\n    this.concurrency = concurrency;\n    this.emitter = new EventEmitter();\n  }\n\n  /**\n   * Add a operation into queue.\n   *\n   * @param operation -\n   */\n  public addOperation(operation: Operation): void {\n    this.operations.push(async () => {\n      try {\n        this.actives++;\n        await operation();\n        this.actives--;\n        this.completed++;\n        this.parallelExecute();\n      } catch (error: any) {\n        this.emitter.emit(\"error\", error);\n      }\n    });\n  }\n\n  /**\n   * Start execute operations in the queue.\n   *\n   */\n  public async do(): Promise<void> {\n    if (this.operations.length === 0) {\n      return Promise.resolve();\n    }\n\n    this.parallelExecute();\n\n    return new Promise<void>((resolve, reject) => {\n      this.emitter.on(\"finish\", resolve);\n\n      this.emitter.on(\"error\", (error) => {\n        this.state = BatchStates.Error;\n        reject(error);\n      });\n    });\n  }\n\n  /**\n   * Get next operation to be executed. Return null when reaching ends.\n   *\n   */\n  private nextOperation(): Operation | null {\n    if (this.offset < this.operations.length) {\n      return this.operations[this.offset++];\n    }\n    return null;\n  }\n\n  /**\n   * Start execute operations. One one the most important difference between\n   * this method with do() is that do() wraps as an sync method.\n   *\n   */\n  private parallelExecute(): void {\n    if (this.state === BatchStates.Error) {\n      return;\n    }\n\n    if (this.completed >= this.operations.length) {\n      this.emitter.emit(\"finish\");\n      return;\n    }\n\n    while (this.actives < this.concurrency) {\n      const operation = this.nextOperation();\n      if (operation) {\n        operation();\n      } else {\n        return;\n      }\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AAEA;AACA;AACA,SAASA,YAAY,QAAQ,QAAQ;AAOrC;;;AAGA,IAAKC,WAGJ;AAHD,WAAKA,WAAW;EACdA,WAAA,CAAAA,WAAA,sBAAI;EACJA,WAAA,CAAAA,WAAA,wBAAK;AACP,CAAC,EAHIA,WAAW,KAAXA,WAAW;AAKhB;;;;;AAKA,OAAM,MAAOC,KAAK;EAChB;;;EAGQC,WAAW;EAEnB;;;EAGQC,OAAO,GAAW,CAAC;EAE3B;;;EAGQC,SAAS,GAAW,CAAC;EAE7B;;;EAGQC,MAAM,GAAW,CAAC;EAE1B;;;EAGQC,UAAU,GAAgB,EAAE;EAEpC;;;;EAIQC,KAAK,GAAgBP,WAAW,CAACQ,IAAI;EAE7C;;;EAGQC,OAAO;EAEf;;;;EAIAC,YAAmBR,WAAA,GAAsB,CAAC;IACxC,IAAIA,WAAW,GAAG,CAAC,EAAE;MACnB,MAAM,IAAIS,UAAU,CAAC,mCAAmC,CAAC;IAC3D;IACA,IAAI,CAACT,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACO,OAAO,GAAG,IAAIV,YAAY,EAAE;EACnC;EAEA;;;;;EAKOa,YAAYA,CAACC,SAAoB;IACtC,IAAI,CAACP,UAAU,CAACQ,IAAI,CAAC,YAAW;MAC9B,IAAI;QACF,IAAI,CAACX,OAAO,EAAE;QACd,MAAMU,SAAS,EAAE;QACjB,IAAI,CAACV,OAAO,EAAE;QACd,IAAI,CAACC,SAAS,EAAE;QAChB,IAAI,CAACW,eAAe,EAAE;MACxB,CAAC,CAAC,OAAOC,KAAU,EAAE;QACnB,IAAI,CAACP,OAAO,CAACQ,IAAI,CAAC,OAAO,EAAED,KAAK,CAAC;MACnC;IACF,CAAC,CAAC;EACJ;EAEA;;;;EAIO,MAAME,EAAEA,CAAA;IACb,IAAI,IAAI,CAACZ,UAAU,CAACa,MAAM,KAAK,CAAC,EAAE;MAChC,OAAOC,OAAO,CAACC,OAAO,EAAE;IAC1B;IAEA,IAAI,CAACN,eAAe,EAAE;IAEtB,OAAO,IAAIK,OAAO,CAAO,CAACC,OAAO,EAAEC,MAAM,KAAI;MAC3C,IAAI,CAACb,OAAO,CAACc,EAAE,CAAC,QAAQ,EAAEF,OAAO,CAAC;MAElC,IAAI,CAACZ,OAAO,CAACc,EAAE,CAAC,OAAO,EAAGP,KAAK,IAAI;QACjC,IAAI,CAACT,KAAK,GAAGP,WAAW,CAACwB,KAAK;QAC9BF,MAAM,CAACN,KAAK,CAAC;MACf,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA;;;;EAIQS,aAAaA,CAAA;IACnB,IAAI,IAAI,CAACpB,MAAM,GAAG,IAAI,CAACC,UAAU,CAACa,MAAM,EAAE;MACxC,OAAO,IAAI,CAACb,UAAU,CAAC,IAAI,CAACD,MAAM,EAAE,CAAC;IACvC;IACA,OAAO,IAAI;EACb;EAEA;;;;;EAKQU,eAAeA,CAAA;IACrB,IAAI,IAAI,CAACR,KAAK,KAAKP,WAAW,CAACwB,KAAK,EAAE;MACpC;IACF;IAEA,IAAI,IAAI,CAACpB,SAAS,IAAI,IAAI,CAACE,UAAU,CAACa,MAAM,EAAE;MAC5C,IAAI,CAACV,OAAO,CAACQ,IAAI,CAAC,QAAQ,CAAC;MAC3B;IACF;IAEA,OAAO,IAAI,CAACd,OAAO,GAAG,IAAI,CAACD,WAAW,EAAE;MACtC,MAAMW,SAAS,GAAG,IAAI,CAACY,aAAa,EAAE;MACtC,IAAIZ,SAAS,EAAE;QACbA,SAAS,EAAE;MACb,CAAC,MAAM;QACL;MACF;IACF;EACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}