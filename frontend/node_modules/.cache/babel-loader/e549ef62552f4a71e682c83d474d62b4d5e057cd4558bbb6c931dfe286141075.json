{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { delay } from \"../util/helpers.js\";\nimport { AbortError } from \"../abort-controller/AbortError.js\";\nimport { createClientLogger } from \"../logger/logger.js\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\nconst retryPolicyLogger = createClientLogger(\"ts-http-runtime retryPolicy\");\n/**\n * The programmatic identifier of the retryPolicy.\n */\nconst retryPolicyName = \"retryPolicy\";\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(strategies, options = {\n  maxRetries: DEFAULT_RETRY_POLICY_COUNT\n}) {\n  const logger = options.logger || retryPolicyLogger;\n  return {\n    name: retryPolicyName,\n    async sendRequest(request, next) {\n      let response;\n      let responseError;\n      let retryCount = -1;\n      retryRequest: while (true) {\n        retryCount += 1;\n        response = undefined;\n        responseError = undefined;\n        try {\n          logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n          response = await next(request);\n          logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n        } catch (e) {\n          logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);\n          // RestErrors are valid targets for the retry strategies.\n          // If none of the retry strategies can work with them, they will be thrown later in this policy.\n          // If the received error is not a RestError, it is immediately thrown.\n          responseError = e;\n          if (!e || responseError.name !== \"RestError\") {\n            throw e;\n          }\n          response = responseError.response;\n        }\n        if (request.abortSignal?.aborted) {\n          logger.error(`Retry ${retryCount}: Request aborted.`);\n          const abortError = new AbortError();\n          throw abortError;\n        }\n        if (retryCount >= (options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT)) {\n          logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);\n          if (responseError) {\n            throw responseError;\n          } else if (response) {\n            return response;\n          } else {\n            throw new Error(\"Maximum retries reached with no response or error to throw\");\n          }\n        }\n        logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n        strategiesLoop: for (const strategy of strategies) {\n          const strategyLogger = strategy.logger || logger;\n          strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n          const modifiers = strategy.retry({\n            retryCount,\n            response,\n            responseError\n          });\n          if (modifiers.skipStrategy) {\n            strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n            continue strategiesLoop;\n          }\n          const {\n            errorToThrow,\n            retryAfterInMs,\n            redirectTo\n          } = modifiers;\n          if (errorToThrow) {\n            strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);\n            throw errorToThrow;\n          }\n          if (retryAfterInMs || retryAfterInMs === 0) {\n            strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);\n            await delay(retryAfterInMs, undefined, {\n              abortSignal: request.abortSignal\n            });\n            continue retryRequest;\n          }\n          if (redirectTo) {\n            strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);\n            request.url = redirectTo;\n            continue retryRequest;\n          }\n        }\n        if (responseError) {\n          logger.info(`None of the retry strategies could work with the received error. Throwing it.`);\n          throw responseError;\n        }\n        if (response) {\n          logger.info(`None of the retry strategies could work with the received response. Returning it.`);\n          return response;\n        }\n        // If all the retries skip and there's no response,\n        // we're still in the retry loop, so a new request will be sent\n        // until `maxRetries` is reached.\n      }\n    }\n  };\n}","map":{"version":3,"names":["delay","AbortError","createClientLogger","DEFAULT_RETRY_POLICY_COUNT","retryPolicyLogger","retryPolicyName","retryPolicy","strategies","options","maxRetries","logger","name","sendRequest","request","next","response","responseError","retryCount","retryRequest","undefined","info","requestId","e","error","abortSignal","aborted","abortError","Error","length","strategiesLoop","strategy","strategyLogger","modifiers","retry","skipStrategy","errorToThrow","retryAfterInMs","redirectTo","url"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@typespec\\ts-http-runtime\\src\\policies\\retryPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { delay } from \"../util/helpers.js\";\nimport type { RetryStrategy } from \"../retryStrategies/retryStrategy.js\";\nimport type { RestError } from \"../restError.js\";\nimport { AbortError } from \"../abort-controller/AbortError.js\";\nimport type { TypeSpecRuntimeLogger } from \"../logger/logger.js\";\nimport { createClientLogger } from \"../logger/logger.js\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\n\nconst retryPolicyLogger = createClientLogger(\"ts-http-runtime retryPolicy\");\n\n/**\n * The programmatic identifier of the retryPolicy.\n */\nconst retryPolicyName = \"retryPolicy\";\n\n/**\n * Options to the {@link retryPolicy}\n */\nexport interface RetryPolicyOptions {\n  /**\n   * Maximum number of retries. If not specified, it will limit to 3 retries.\n   */\n  maxRetries?: number;\n  /**\n   * Logger. If it's not provided, a default logger is used.\n   */\n  logger?: TypeSpecRuntimeLogger;\n}\n\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(\n  strategies: RetryStrategy[],\n  options: RetryPolicyOptions = { maxRetries: DEFAULT_RETRY_POLICY_COUNT },\n): PipelinePolicy {\n  const logger = options.logger || retryPolicyLogger;\n  return {\n    name: retryPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      let response: PipelineResponse | undefined;\n      let responseError: RestError | undefined;\n      let retryCount = -1;\n\n      retryRequest: while (true) {\n        retryCount += 1;\n        response = undefined;\n        responseError = undefined;\n\n        try {\n          logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n          response = await next(request);\n          logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n        } catch (e: any) {\n          logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);\n\n          // RestErrors are valid targets for the retry strategies.\n          // If none of the retry strategies can work with them, they will be thrown later in this policy.\n          // If the received error is not a RestError, it is immediately thrown.\n          responseError = e as RestError;\n          if (!e || responseError.name !== \"RestError\") {\n            throw e;\n          }\n\n          response = responseError.response;\n        }\n\n        if (request.abortSignal?.aborted) {\n          logger.error(`Retry ${retryCount}: Request aborted.`);\n          const abortError = new AbortError();\n          throw abortError;\n        }\n\n        if (retryCount >= (options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT)) {\n          logger.info(\n            `Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`,\n          );\n          if (responseError) {\n            throw responseError;\n          } else if (response) {\n            return response;\n          } else {\n            throw new Error(\"Maximum retries reached with no response or error to throw\");\n          }\n        }\n\n        logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n\n        strategiesLoop: for (const strategy of strategies) {\n          const strategyLogger = strategy.logger || logger;\n          strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n\n          const modifiers = strategy.retry({\n            retryCount,\n            response,\n            responseError,\n          });\n\n          if (modifiers.skipStrategy) {\n            strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n            continue strategiesLoop;\n          }\n\n          const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;\n\n          if (errorToThrow) {\n            strategyLogger.error(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`,\n              errorToThrow,\n            );\n            throw errorToThrow;\n          }\n\n          if (retryAfterInMs || retryAfterInMs === 0) {\n            strategyLogger.info(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`,\n            );\n            await delay(retryAfterInMs, undefined, { abortSignal: request.abortSignal });\n            continue retryRequest;\n          }\n\n          if (redirectTo) {\n            strategyLogger.info(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`,\n            );\n            request.url = redirectTo;\n            continue retryRequest;\n          }\n        }\n\n        if (responseError) {\n          logger.info(\n            `None of the retry strategies could work with the received error. Throwing it.`,\n          );\n          throw responseError;\n        }\n        if (response) {\n          logger.info(\n            `None of the retry strategies could work with the received response. Returning it.`,\n          );\n          return response;\n        }\n\n        // If all the retries skip and there's no response,\n        // we're still in the retry loop, so a new request will be sent\n        // until `maxRetries` is reached.\n      }\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}