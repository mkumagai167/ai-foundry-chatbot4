{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport debug from \"./debug.js\";\nconst TYPESPEC_RUNTIME_LOG_LEVELS = [\"verbose\", \"info\", \"warning\", \"error\"];\nconst levelMap = {\n  verbose: 400,\n  info: 300,\n  warning: 200,\n  error: 100\n};\nfunction patchLogMethod(parent, child) {\n  child.log = (...args) => {\n    parent.log(...args);\n  };\n}\nfunction isTypeSpecRuntimeLogLevel(level) {\n  return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level);\n}\n/**\n * Creates a logger context base on the provided options.\n * @param options - The options for creating a logger context.\n * @returns The logger context.\n */\nexport function createLoggerContext(options) {\n  const registeredLoggers = new Set();\n  const logLevelFromEnv = typeof process !== \"undefined\" && process.env && process.env[options.logLevelEnvVarName] || undefined;\n  let logLevel;\n  const clientLogger = debug(options.namespace);\n  clientLogger.log = (...args) => {\n    debug.log(...args);\n  };\n  function contextSetLogLevel(level) {\n    if (level && !isTypeSpecRuntimeLogLevel(level)) {\n      throw new Error(`Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(\",\")}`);\n    }\n    logLevel = level;\n    const enabledNamespaces = [];\n    for (const logger of registeredLoggers) {\n      if (shouldEnable(logger)) {\n        enabledNamespaces.push(logger.namespace);\n      }\n    }\n    debug.enable(enabledNamespaces.join(\",\"));\n  }\n  if (logLevelFromEnv) {\n    // avoid calling setLogLevel because we don't want a mis-set environment variable to crash\n    if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {\n      contextSetLogLevel(logLevelFromEnv);\n    } else {\n      console.error(`${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(\", \")}.`);\n    }\n  }\n  function shouldEnable(logger) {\n    return Boolean(logLevel && levelMap[logger.level] <= levelMap[logLevel]);\n  }\n  function createLogger(parent, level) {\n    const logger = Object.assign(parent.extend(level), {\n      level\n    });\n    patchLogMethod(parent, logger);\n    if (shouldEnable(logger)) {\n      const enabledNamespaces = debug.disable();\n      debug.enable(enabledNamespaces + \",\" + logger.namespace);\n    }\n    registeredLoggers.add(logger);\n    return logger;\n  }\n  function contextGetLogLevel() {\n    return logLevel;\n  }\n  function contextCreateClientLogger(namespace) {\n    const clientRootLogger = clientLogger.extend(namespace);\n    patchLogMethod(clientLogger, clientRootLogger);\n    return {\n      error: createLogger(clientRootLogger, \"error\"),\n      warning: createLogger(clientRootLogger, \"warning\"),\n      info: createLogger(clientRootLogger, \"info\"),\n      verbose: createLogger(clientRootLogger, \"verbose\")\n    };\n  }\n  return {\n    setLogLevel: contextSetLogLevel,\n    getLogLevel: contextGetLogLevel,\n    createClientLogger: contextCreateClientLogger,\n    logger: clientLogger\n  };\n}\nconst context = createLoggerContext({\n  logLevelEnvVarName: \"TYPESPEC_RUNTIME_LOG_LEVEL\",\n  namespace: \"typeSpecRuntime\"\n});\n/**\n * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.\n * @param level - The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const TypeSpecRuntimeLogger = context.logger;\n/**\n * Retrieves the currently specified log level.\n */\nexport function setLogLevel(logLevel) {\n  context.setLogLevel(logLevel);\n}\n/**\n * Retrieves the currently specified log level.\n */\nexport function getLogLevel() {\n  return context.getLogLevel();\n}\n/**\n * Creates a logger for use by the SDKs that inherits from `TypeSpecRuntimeLogger`.\n * @param namespace - The name of the SDK package.\n * @hidden\n */\nexport function createClientLogger(namespace) {\n  return context.createClientLogger(namespace);\n}","map":{"version":3,"names":["debug","TYPESPEC_RUNTIME_LOG_LEVELS","levelMap","verbose","info","warning","error","patchLogMethod","parent","child","log","args","isTypeSpecRuntimeLogLevel","level","includes","createLoggerContext","options","registeredLoggers","Set","logLevelFromEnv","process","env","logLevelEnvVarName","undefined","logLevel","clientLogger","namespace","contextSetLogLevel","Error","join","enabledNamespaces","logger","shouldEnable","push","enable","console","Boolean","createLogger","Object","assign","extend","disable","add","contextGetLogLevel","contextCreateClientLogger","clientRootLogger","setLogLevel","getLogLevel","createClientLogger","context","TypeSpecRuntimeLogger"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@typespec\\ts-http-runtime\\src\\logger\\logger.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport debug from \"./debug.js\";\n\nimport type { Debugger } from \"./debug.js\";\nexport type { Debugger };\n\n/**\n * The log levels supported by the logger.\n * The log levels in order of most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport type TypeSpecRuntimeLogLevel = \"verbose\" | \"info\" | \"warning\" | \"error\";\n\n/**\n * A TypeSpecRuntimeClientLogger is a function that can log to an appropriate severity level.\n */\nexport type TypeSpecRuntimeClientLogger = Debugger;\n\n/**\n * Defines the methods available on the SDK-facing logger.\n */\nexport interface TypeSpecRuntimeLogger {\n  /**\n   * Used for failures the program is unlikely to recover from,\n   * such as Out of Memory.\n   */\n  error: Debugger;\n  /**\n   * Used when a function fails to perform its intended task.\n   * Usually this means the function will throw an exception.\n   * Not used for self-healing events (e.g. automatic retry)\n   */\n  warning: Debugger;\n  /**\n   * Used when a function operates normally.\n   */\n  info: Debugger;\n  /**\n   * Used for detailed troubleshooting scenarios. This is\n   * intended for use by developers / system administrators\n   * for diagnosing specific failures.\n   */\n  verbose: Debugger;\n}\n\n/**\n * todo doc\n */\nexport interface LoggerContext {\n  /**\n   * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.\n   * @param level - The log level to enable for logging.\n   * Options from most verbose to least verbose are:\n   * - verbose\n   * - info\n   * - warning\n   * - error\n   */\n  setLogLevel(logLevel?: TypeSpecRuntimeLogLevel): void;\n\n  /**\n   * Retrieves the currently specified log level.\n   */\n  getLogLevel(): TypeSpecRuntimeLogLevel | undefined;\n\n  /**\n   * Creates a logger for use by the SDKs that inherits from `TypeSpecRuntimeLogger`.\n   * @param namespace - The name of the SDK package.\n   * @hidden\n   */\n  createClientLogger(namespace: string): TypeSpecRuntimeLogger;\n\n  /**\n   * The TypeSpecRuntimeClientLogger provides a mechanism for overriding where logs are output to.\n   * By default, logs are sent to stderr.\n   * Override the `log` method to redirect logs to another location.\n   */\n  logger: TypeSpecRuntimeClientLogger;\n}\n\n/**\n * Option for creating a TypeSpecRuntimeLoggerContext.\n */\nexport interface CreateLoggerContextOptions {\n  /**\n   * The name of the environment variable to check for the log level.\n   */\n  logLevelEnvVarName: string;\n\n  /**\n   * The namespace of the logger.\n   */\n  namespace: string;\n}\n\nconst TYPESPEC_RUNTIME_LOG_LEVELS = [\"verbose\", \"info\", \"warning\", \"error\"];\n\ntype DebuggerWithLogLevel = Debugger & { level: TypeSpecRuntimeLogLevel };\n\nconst levelMap = {\n  verbose: 400,\n  info: 300,\n  warning: 200,\n  error: 100,\n};\n\nfunction patchLogMethod(\n  parent: TypeSpecRuntimeClientLogger,\n  child: TypeSpecRuntimeClientLogger | DebuggerWithLogLevel,\n): void {\n  child.log = (...args) => {\n    parent.log(...args);\n  };\n}\n\nfunction isTypeSpecRuntimeLogLevel(level: string): level is TypeSpecRuntimeLogLevel {\n  return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level as any);\n}\n\n/**\n * Creates a logger context base on the provided options.\n * @param options - The options for creating a logger context.\n * @returns The logger context.\n */\nexport function createLoggerContext(options: CreateLoggerContextOptions): LoggerContext {\n  const registeredLoggers = new Set<DebuggerWithLogLevel>();\n  const logLevelFromEnv =\n    (typeof process !== \"undefined\" && process.env && process.env[options.logLevelEnvVarName]) ||\n    undefined;\n\n  let logLevel: TypeSpecRuntimeLogLevel | undefined;\n\n  const clientLogger: TypeSpecRuntimeClientLogger = debug(options.namespace);\n  clientLogger.log = (...args) => {\n    debug.log(...args);\n  };\n\n  function contextSetLogLevel(level?: TypeSpecRuntimeLogLevel): void {\n    if (level && !isTypeSpecRuntimeLogLevel(level)) {\n      throw new Error(\n        `Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(\",\")}`,\n      );\n    }\n    logLevel = level;\n\n    const enabledNamespaces = [];\n    for (const logger of registeredLoggers) {\n      if (shouldEnable(logger)) {\n        enabledNamespaces.push(logger.namespace);\n      }\n    }\n\n    debug.enable(enabledNamespaces.join(\",\"));\n  }\n\n  if (logLevelFromEnv) {\n    // avoid calling setLogLevel because we don't want a mis-set environment variable to crash\n    if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {\n      contextSetLogLevel(logLevelFromEnv);\n    } else {\n      console.error(\n        `${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(\n          \", \",\n        )}.`,\n      );\n    }\n  }\n\n  function shouldEnable(logger: DebuggerWithLogLevel): boolean {\n    return Boolean(logLevel && levelMap[logger.level] <= levelMap[logLevel]);\n  }\n\n  function createLogger(\n    parent: TypeSpecRuntimeClientLogger,\n    level: TypeSpecRuntimeLogLevel,\n  ): DebuggerWithLogLevel {\n    const logger: DebuggerWithLogLevel = Object.assign(parent.extend(level), {\n      level,\n    });\n\n    patchLogMethod(parent, logger);\n\n    if (shouldEnable(logger)) {\n      const enabledNamespaces = debug.disable();\n      debug.enable(enabledNamespaces + \",\" + logger.namespace);\n    }\n\n    registeredLoggers.add(logger);\n\n    return logger;\n  }\n\n  function contextGetLogLevel(): TypeSpecRuntimeLogLevel | undefined {\n    return logLevel;\n  }\n\n  function contextCreateClientLogger(namespace: string): TypeSpecRuntimeLogger {\n    const clientRootLogger: TypeSpecRuntimeClientLogger = clientLogger.extend(namespace);\n    patchLogMethod(clientLogger, clientRootLogger);\n    return {\n      error: createLogger(clientRootLogger, \"error\"),\n      warning: createLogger(clientRootLogger, \"warning\"),\n      info: createLogger(clientRootLogger, \"info\"),\n      verbose: createLogger(clientRootLogger, \"verbose\"),\n    };\n  }\n\n  return {\n    setLogLevel: contextSetLogLevel,\n    getLogLevel: contextGetLogLevel,\n    createClientLogger: contextCreateClientLogger,\n    logger: clientLogger,\n  };\n}\n\nconst context = createLoggerContext({\n  logLevelEnvVarName: \"TYPESPEC_RUNTIME_LOG_LEVEL\",\n  namespace: \"typeSpecRuntime\",\n});\n\n/**\n * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.\n * @param level - The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const TypeSpecRuntimeLogger: TypeSpecRuntimeClientLogger = context.logger;\n\n/**\n * Retrieves the currently specified log level.\n */\nexport function setLogLevel(logLevel?: TypeSpecRuntimeLogLevel): void {\n  context.setLogLevel(logLevel);\n}\n\n/**\n * Retrieves the currently specified log level.\n */\nexport function getLogLevel(): TypeSpecRuntimeLogLevel | undefined {\n  return context.getLogLevel();\n}\n\n/**\n * Creates a logger for use by the SDKs that inherits from `TypeSpecRuntimeLogger`.\n * @param namespace - The name of the SDK package.\n * @hidden\n */\nexport function createClientLogger(namespace: string): TypeSpecRuntimeLogger {\n  return context.createClientLogger(namespace);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}