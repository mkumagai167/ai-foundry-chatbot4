{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AbortError } from \"./abort-controller/AbortError.js\";\nimport { RestError } from \"./restError.js\";\nimport { createHttpHeaders } from \"./httpHeaders.js\";\nimport { isNodeReadableStream, isWebReadableStream } from \"./util/typeGuards.js\";\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body) {\n  // File objects count as a type of Blob, so we want to use instanceof explicitly\n  return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient {\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  async sendRequest(request) {\n    const url = new URL(request.url);\n    const isInsecure = url.protocol !== \"https:\";\n    if (isInsecure && !request.allowInsecureConnection) {\n      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n    }\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n    try {\n      return await makeRequest(request);\n    } catch (e) {\n      throw getError(e, request);\n    }\n  }\n}\n/**\n * Sends a request\n */\nasync function makeRequest(request) {\n  const {\n    abortController,\n    abortControllerCleanup\n  } = setupAbortSignal(request);\n  try {\n    const headers = buildFetchHeaders(request.headers);\n    const {\n      streaming,\n      body: requestBody\n    } = buildRequestBody(request);\n    const requestInit = {\n      body: requestBody,\n      method: request.method,\n      headers: headers,\n      signal: abortController.signal,\n      // Cloudflare doesn't implement the full Fetch API spec\n      // because of some of it doesn't make sense in the edge.\n      // See https://github.com/cloudflare/workerd/issues/902\n      ...(\"credentials\" in Request.prototype ? {\n        credentials: request.withCredentials ? \"include\" : \"same-origin\"\n      } : {}),\n      ...(\"cache\" in Request.prototype ? {\n        cache: \"no-store\"\n      } : {})\n    };\n    // According to https://fetch.spec.whatwg.org/#fetch-method,\n    // init.duplex must be set when body is a ReadableStream object.\n    // currently \"half\" is the only valid value.\n    if (streaming) {\n      requestInit.duplex = \"half\";\n    }\n    /**\n     * Developers of the future:\n     * Do not set redirect: \"manual\" as part\n     * of request options.\n     * It will not work as you expect.\n     */\n    const response = await fetch(request.url, {\n      ...requestInit,\n      ...request.requestOverrides\n    });\n    // If we're uploading a blob, we need to fire the progress event manually\n    if (isBlob(request.body) && request.onUploadProgress) {\n      request.onUploadProgress({\n        loadedBytes: request.body.size\n      });\n    }\n    return buildPipelineResponse(response, request, abortControllerCleanup);\n  } catch (e) {\n    abortControllerCleanup?.();\n    throw e;\n  }\n}\n/**\n * Creates a pipeline response from a Fetch response;\n */\nasync function buildPipelineResponse(httpResponse, request, abortControllerCleanup) {\n  const headers = buildPipelineHeaders(httpResponse);\n  const response = {\n    request,\n    headers,\n    status: httpResponse.status\n  };\n  const bodyStream = isWebReadableStream(httpResponse.body) ? buildBodyStream(httpResponse.body, {\n    onProgress: request.onDownloadProgress,\n    onEnd: abortControllerCleanup\n  }) : httpResponse.body;\n  if (\n  // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n  request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) || request.streamResponseStatusCodes?.has(response.status)) {\n    if (request.enableBrowserStreams) {\n      response.browserStreamBody = bodyStream ?? undefined;\n    } else {\n      const responseStream = new Response(bodyStream);\n      response.blobBody = responseStream.blob();\n      abortControllerCleanup?.();\n    }\n  } else {\n    const responseStream = new Response(bodyStream);\n    response.bodyAsText = await responseStream.text();\n    abortControllerCleanup?.();\n  }\n  return response;\n}\nfunction setupAbortSignal(request) {\n  const abortController = new AbortController();\n  // Cleanup function\n  let abortControllerCleanup;\n  /**\n   * Attach an abort listener to the request\n   */\n  let abortListener;\n  if (request.abortSignal) {\n    if (request.abortSignal.aborted) {\n      throw new AbortError(\"The operation was aborted. Request has already been canceled.\");\n    }\n    abortListener = event => {\n      if (event.type === \"abort\") {\n        abortController.abort();\n      }\n    };\n    request.abortSignal.addEventListener(\"abort\", abortListener);\n    abortControllerCleanup = () => {\n      if (abortListener) {\n        request.abortSignal?.removeEventListener(\"abort\", abortListener);\n      }\n    };\n  }\n  // If a timeout was passed, call the abort signal once the time elapses\n  if (request.timeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n    }, request.timeout);\n  }\n  return {\n    abortController,\n    abortControllerCleanup\n  };\n}\n/**\n * Gets the specific error\n */\n// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\nfunction getError(e, request) {\n  if (e && e?.name === \"AbortError\") {\n    return e;\n  } else {\n    return new RestError(`Error sending request: ${e.message}`, {\n      code: e?.code ?? RestError.REQUEST_SEND_ERROR,\n      request\n    });\n  }\n}\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders) {\n  const headers = new Headers();\n  for (const [name, value] of pipelineHeaders) {\n    headers.append(name, value);\n  }\n  return headers;\n}\nfunction buildPipelineHeaders(httpResponse) {\n  const responseHeaders = createHttpHeaders();\n  for (const [name, value] of httpResponse.headers) {\n    responseHeaders.set(name, value);\n  }\n  return responseHeaders;\n}\nfunction buildRequestBody(request) {\n  const body = typeof request.body === \"function\" ? request.body() : request.body;\n  if (isNodeReadableStream(body)) {\n    throw new Error(\"Node streams are not supported in browser environment.\");\n  }\n  return isWebReadableStream(body) ? {\n    streaming: true,\n    body: buildBodyStream(body, {\n      onProgress: request.onUploadProgress\n    })\n  } : {\n    streaming: false,\n    body\n  };\n}\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(readableStream, options = {}) {\n  let loadedBytes = 0;\n  const {\n    onProgress,\n    onEnd\n  } = options;\n  // If the current browser supports pipeThrough we use a TransformStream\n  // to report progress\n  if (isTransformStreamSupported(readableStream)) {\n    return readableStream.pipeThrough(new TransformStream({\n      transform(chunk, controller) {\n        if (chunk === null) {\n          controller.terminate();\n          return;\n        }\n        controller.enqueue(chunk);\n        loadedBytes += chunk.length;\n        if (onProgress) {\n          onProgress({\n            loadedBytes\n          });\n        }\n      },\n      flush() {\n        onEnd?.();\n      }\n    }));\n  } else {\n    // If we can't use transform streams, wrap the original stream in a new readable stream\n    // and use pull to enqueue each chunk and report progress.\n    const reader = readableStream.getReader();\n    return new ReadableStream({\n      async pull(controller) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        // When no more data needs to be consumed, break the reading\n        if (done || !value) {\n          onEnd?.();\n          // Close the stream\n          controller.close();\n          reader.releaseLock();\n          return;\n        }\n        loadedBytes += value?.length ?? 0;\n        // Enqueue the next data chunk into our target stream\n        controller.enqueue(value);\n        if (onProgress) {\n          onProgress({\n            loadedBytes\n          });\n        }\n      },\n      cancel(reason) {\n        onEnd?.();\n        return reader.cancel(reason);\n      }\n    });\n  }\n}\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient() {\n  return new FetchHttpClient();\n}\nfunction isTransformStreamSupported(readableStream) {\n  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}","map":{"version":3,"names":["AbortError","RestError","createHttpHeaders","isNodeReadableStream","isWebReadableStream","isBlob","body","Blob","FetchHttpClient","sendRequest","request","url","URL","isInsecure","protocol","allowInsecureConnection","Error","proxySettings","makeRequest","e","getError","abortController","abortControllerCleanup","setupAbortSignal","headers","buildFetchHeaders","streaming","requestBody","buildRequestBody","requestInit","method","signal","Request","prototype","credentials","withCredentials","cache","duplex","response","fetch","requestOverrides","onUploadProgress","loadedBytes","size","buildPipelineResponse","httpResponse","buildPipelineHeaders","status","bodyStream","buildBodyStream","onProgress","onDownloadProgress","onEnd","streamResponseStatusCodes","has","Number","POSITIVE_INFINITY","enableBrowserStreams","browserStreamBody","undefined","responseStream","Response","blobBody","blob","bodyAsText","text","AbortController","abortListener","abortSignal","aborted","event","type","abort","addEventListener","removeEventListener","timeout","setTimeout","name","message","code","REQUEST_SEND_ERROR","pipelineHeaders","Headers","value","append","responseHeaders","set","readableStream","options","isTransformStreamSupported","pipeThrough","TransformStream","transform","chunk","controller","terminate","enqueue","length","flush","reader","getReader","ReadableStream","pull","done","read","close","releaseLock","cancel","reason","createFetchHttpClient","self"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@typespec\\ts-http-runtime\\src\\fetchHttpClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortError } from \"./abort-controller/AbortError.js\";\nimport type {\n  HttpClient,\n  HttpHeaders as PipelineHeaders,\n  PipelineRequest,\n  PipelineResponse,\n  TransferProgressEvent,\n} from \"./interfaces.js\";\nimport { RestError } from \"./restError.js\";\nimport { createHttpHeaders } from \"./httpHeaders.js\";\nimport { isNodeReadableStream, isWebReadableStream } from \"./util/typeGuards.js\";\n\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body: unknown): body is Blob {\n  // File objects count as a type of Blob, so we want to use instanceof explicitly\n  return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient implements HttpClient {\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  public async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {\n    const url = new URL(request.url);\n    const isInsecure = url.protocol !== \"https:\";\n\n    if (isInsecure && !request.allowInsecureConnection) {\n      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n    }\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    try {\n      return await makeRequest(request);\n    } catch (e: any) {\n      throw getError(e, request);\n    }\n  }\n}\n\n/**\n * Sends a request\n */\nasync function makeRequest(request: PipelineRequest): Promise<PipelineResponse> {\n  const { abortController, abortControllerCleanup } = setupAbortSignal(request);\n  try {\n    const headers = buildFetchHeaders(request.headers);\n    const { streaming, body: requestBody } = buildRequestBody(request);\n    const requestInit: RequestInit = {\n      body: requestBody,\n      method: request.method,\n      headers: headers,\n      signal: abortController.signal,\n      // Cloudflare doesn't implement the full Fetch API spec\n      // because of some of it doesn't make sense in the edge.\n      // See https://github.com/cloudflare/workerd/issues/902\n      ...(\"credentials\" in Request.prototype\n        ? { credentials: request.withCredentials ? \"include\" : \"same-origin\" }\n        : {}),\n      ...(\"cache\" in Request.prototype ? { cache: \"no-store\" } : {}),\n    };\n\n    // According to https://fetch.spec.whatwg.org/#fetch-method,\n    // init.duplex must be set when body is a ReadableStream object.\n    // currently \"half\" is the only valid value.\n    if (streaming) {\n      (requestInit as any).duplex = \"half\";\n    }\n    /**\n     * Developers of the future:\n     * Do not set redirect: \"manual\" as part\n     * of request options.\n     * It will not work as you expect.\n     */\n    const response = await fetch(request.url, {\n      ...requestInit,\n      ...request.requestOverrides,\n    });\n    // If we're uploading a blob, we need to fire the progress event manually\n    if (isBlob(request.body) && request.onUploadProgress) {\n      request.onUploadProgress({ loadedBytes: request.body.size });\n    }\n    return buildPipelineResponse(response, request, abortControllerCleanup);\n  } catch (e) {\n    abortControllerCleanup?.();\n    throw e;\n  }\n}\n\n/**\n * Creates a pipeline response from a Fetch response;\n */\nasync function buildPipelineResponse(\n  httpResponse: Response,\n  request: PipelineRequest,\n  abortControllerCleanup?: () => void,\n): Promise<PipelineResponse> {\n  const headers = buildPipelineHeaders(httpResponse);\n  const response: PipelineResponse = {\n    request,\n    headers,\n    status: httpResponse.status,\n  };\n\n  const bodyStream = isWebReadableStream(httpResponse.body)\n    ? buildBodyStream(httpResponse.body, {\n        onProgress: request.onDownloadProgress,\n        onEnd: abortControllerCleanup,\n      })\n    : httpResponse.body;\n\n  if (\n    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) ||\n    request.streamResponseStatusCodes?.has(response.status)\n  ) {\n    if (request.enableBrowserStreams) {\n      response.browserStreamBody = bodyStream ?? undefined;\n    } else {\n      const responseStream = new Response(bodyStream);\n      response.blobBody = responseStream.blob();\n      abortControllerCleanup?.();\n    }\n  } else {\n    const responseStream = new Response(bodyStream);\n\n    response.bodyAsText = await responseStream.text();\n    abortControllerCleanup?.();\n  }\n\n  return response;\n}\n\nfunction setupAbortSignal(request: PipelineRequest): {\n  abortController: AbortController;\n  abortControllerCleanup: (() => void) | undefined;\n} {\n  const abortController = new AbortController();\n\n  // Cleanup function\n  let abortControllerCleanup: (() => void) | undefined;\n\n  /**\n   * Attach an abort listener to the request\n   */\n  let abortListener: ((event: any) => void) | undefined;\n  if (request.abortSignal) {\n    if (request.abortSignal.aborted) {\n      throw new AbortError(\"The operation was aborted. Request has already been canceled.\");\n    }\n\n    abortListener = (event: Event) => {\n      if (event.type === \"abort\") {\n        abortController.abort();\n      }\n    };\n    request.abortSignal.addEventListener(\"abort\", abortListener);\n    abortControllerCleanup = () => {\n      if (abortListener) {\n        request.abortSignal?.removeEventListener(\"abort\", abortListener);\n      }\n    };\n  }\n\n  // If a timeout was passed, call the abort signal once the time elapses\n  if (request.timeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n    }, request.timeout);\n  }\n\n  return { abortController, abortControllerCleanup };\n}\n\n/**\n * Gets the specific error\n */\n// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\nfunction getError(e: RestError, request: PipelineRequest): RestError {\n  if (e && e?.name === \"AbortError\") {\n    return e;\n  } else {\n    return new RestError(`Error sending request: ${e.message}`, {\n      code: e?.code ?? RestError.REQUEST_SEND_ERROR,\n      request,\n    });\n  }\n}\n\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders: PipelineHeaders): Headers {\n  const headers = new Headers();\n  for (const [name, value] of pipelineHeaders) {\n    headers.append(name, value);\n  }\n\n  return headers;\n}\n\nfunction buildPipelineHeaders(httpResponse: Response): PipelineHeaders {\n  const responseHeaders = createHttpHeaders();\n  for (const [name, value] of httpResponse.headers) {\n    responseHeaders.set(name, value);\n  }\n\n  return responseHeaders;\n}\n\ninterface BuildRequestBodyResponse {\n  body:\n    | string\n    | Blob\n    | ReadableStream<Uint8Array>\n    | ArrayBuffer\n    | ArrayBufferView\n    | FormData\n    | null\n    | undefined;\n  streaming: boolean;\n}\n\nfunction buildRequestBody(request: PipelineRequest): BuildRequestBodyResponse {\n  const body = typeof request.body === \"function\" ? request.body() : request.body;\n  if (isNodeReadableStream(body)) {\n    throw new Error(\"Node streams are not supported in browser environment.\");\n  }\n\n  return isWebReadableStream(body)\n    ? { streaming: true, body: buildBodyStream(body, { onProgress: request.onUploadProgress }) }\n    : { streaming: false, body };\n}\n\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(\n  readableStream: ReadableStream<Uint8Array>,\n  options: { onProgress?: (progress: TransferProgressEvent) => void; onEnd?: () => void } = {},\n): ReadableStream<Uint8Array> {\n  let loadedBytes = 0;\n  const { onProgress, onEnd } = options;\n\n  // If the current browser supports pipeThrough we use a TransformStream\n  // to report progress\n  if (isTransformStreamSupported(readableStream)) {\n    return readableStream.pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          if (chunk === null) {\n            controller.terminate();\n            return;\n          }\n\n          controller.enqueue(chunk);\n          loadedBytes += chunk.length;\n          if (onProgress) {\n            onProgress({ loadedBytes });\n          }\n        },\n        flush() {\n          onEnd?.();\n        },\n      }),\n    );\n  } else {\n    // If we can't use transform streams, wrap the original stream in a new readable stream\n    // and use pull to enqueue each chunk and report progress.\n    const reader = readableStream.getReader();\n    return new ReadableStream({\n      async pull(controller) {\n        const { done, value } = await reader.read();\n        // When no more data needs to be consumed, break the reading\n        if (done || !value) {\n          onEnd?.();\n          // Close the stream\n          controller.close();\n          reader.releaseLock();\n          return;\n        }\n\n        loadedBytes += value?.length ?? 0;\n\n        // Enqueue the next data chunk into our target stream\n        controller.enqueue(value);\n\n        if (onProgress) {\n          onProgress({ loadedBytes });\n        }\n      },\n      cancel(reason?: string) {\n        onEnd?.();\n        return reader.cancel(reason);\n      },\n    });\n  }\n}\n\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient(): HttpClient {\n  return new FetchHttpClient();\n}\n\nfunction isTransformStreamSupported(readableStream: ReadableStream): boolean {\n  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}