{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { convertHttpClient, createRequestPolicyFactoryPolicy } from \"@azure/core-http-compat\";\nimport { bearerTokenAuthenticationPolicy, decompressResponsePolicyName } from \"@azure/core-rest-pipeline\";\nimport { authorizeRequestOnTenantChallenge, createClientPipeline } from \"@azure/core-client\";\nimport { parseXML, stringifyXML } from \"@azure/core-xml\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { logger } from \"./log.js\";\nimport { StorageRetryPolicyFactory } from \"./StorageRetryPolicyFactory.js\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential.js\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential.js\";\nimport { StorageOAuthScopes, StorageBlobLoggingAllowedHeaderNames, StorageBlobLoggingAllowedQueryParameters, SDK_VERSION } from \"./utils/constants.js\";\nimport { getCachedDefaultHttpClient } from \"@azure/storage-common\";\nimport { storageBrowserPolicy } from \"./policies/StorageBrowserPolicyV2.js\";\nimport { storageRetryPolicy } from \"./policies/StorageRetryPolicyV2.js\";\nimport { storageSharedKeyCredentialPolicy } from \"./policies/StorageSharedKeyCredentialPolicyV2.js\";\nimport { StorageBrowserPolicyFactory } from \"./StorageBrowserPolicyFactory.js\";\nimport { storageCorrectContentLengthPolicy } from \"./policies/StorageCorrectContentLengthPolicy.js\";\n// Export following interfaces and types for customers who want to implement their\n// own RequestPolicy or HTTPClient\nexport { StorageOAuthScopes };\n/**\n * A helper to decide if a given argument satisfies the Pipeline contract\n * @param pipeline - An argument that may be a Pipeline\n * @returns true when the argument satisfies the Pipeline contract\n */\nexport function isPipelineLike(pipeline) {\n  if (!pipeline || typeof pipeline !== \"object\") {\n    return false;\n  }\n  const castPipeline = pipeline;\n  return Array.isArray(castPipeline.factories) && typeof castPipeline.options === \"object\" && typeof castPipeline.toServiceClientOptions === \"function\";\n}\n/**\n * A Pipeline class containing HTTP request policies.\n * You can create a default Pipeline by calling {@link newPipeline}.\n * Or you can create a Pipeline with your own policies by the constructor of Pipeline.\n *\n * Refer to {@link newPipeline} and provided policies before implementing your\n * customized Pipeline.\n */\nexport class Pipeline {\n  /**\n   * A list of chained request policy factories.\n   */\n  factories;\n  /**\n   * Configures pipeline logger and HTTP client.\n   */\n  options;\n  /**\n   * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.\n   *\n   * @param factories -\n   * @param options -\n   */\n  constructor(factories, options = {}) {\n    this.factories = factories;\n    this.options = options;\n  }\n  /**\n   * Transfer Pipeline object to ServiceClientOptions object which is required by\n   * ServiceClient constructor.\n   *\n   * @returns The ServiceClientOptions object from this Pipeline.\n   */\n  toServiceClientOptions() {\n    return {\n      httpClient: this.options.httpClient,\n      requestPolicyFactories: this.factories\n    };\n  }\n}\n/**\n * Creates a new Pipeline object with Credential provided.\n *\n * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n * @param pipelineOptions - Optional. Options.\n * @returns A new Pipeline object.\n */\nexport function newPipeline(credential, pipelineOptions = {}) {\n  if (!credential) {\n    credential = new AnonymousCredential();\n  }\n  const pipeline = new Pipeline([], pipelineOptions);\n  pipeline._credential = credential;\n  return pipeline;\n}\nfunction processDownlevelPipeline(pipeline) {\n  const knownFactoryFunctions = [isAnonymousCredential, isStorageSharedKeyCredential, isCoreHttpBearerTokenFactory, isStorageBrowserPolicyFactory, isStorageRetryPolicyFactory, isStorageTelemetryPolicyFactory, isCoreHttpPolicyFactory];\n  if (pipeline.factories.length) {\n    const novelFactories = pipeline.factories.filter(factory => {\n      return !knownFactoryFunctions.some(knownFactory => knownFactory(factory));\n    });\n    if (novelFactories.length) {\n      const hasInjector = novelFactories.some(factory => isInjectorPolicyFactory(factory));\n      // if there are any left over, wrap in a requestPolicyFactoryPolicy\n      return {\n        wrappedPolicies: createRequestPolicyFactoryPolicy(novelFactories),\n        afterRetry: hasInjector\n      };\n    }\n  }\n  return undefined;\n}\nexport function getCoreClientOptions(pipeline) {\n  const {\n    httpClient: v1Client,\n    ...restOptions\n  } = pipeline.options;\n  let httpClient = pipeline._coreHttpClient;\n  if (!httpClient) {\n    httpClient = v1Client ? convertHttpClient(v1Client) : getCachedDefaultHttpClient();\n    pipeline._coreHttpClient = httpClient;\n  }\n  let corePipeline = pipeline._corePipeline;\n  if (!corePipeline) {\n    const packageDetails = `azsdk-js-azure-storage-blob/${SDK_VERSION}`;\n    const userAgentPrefix = restOptions.userAgentOptions && restOptions.userAgentOptions.userAgentPrefix ? `${restOptions.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;\n    corePipeline = createClientPipeline({\n      ...restOptions,\n      loggingOptions: {\n        additionalAllowedHeaderNames: StorageBlobLoggingAllowedHeaderNames,\n        additionalAllowedQueryParameters: StorageBlobLoggingAllowedQueryParameters,\n        logger: logger.info\n      },\n      userAgentOptions: {\n        userAgentPrefix\n      },\n      serializationOptions: {\n        stringifyXML,\n        serializerOptions: {\n          xml: {\n            // Use customized XML char key of \"#\" so we can deserialize metadata\n            // with \"_\" key\n            xmlCharKey: \"#\"\n          }\n        }\n      },\n      deserializationOptions: {\n        parseXML,\n        serializerOptions: {\n          xml: {\n            // Use customized XML char key of \"#\" so we can deserialize metadata\n            // with \"_\" key\n            xmlCharKey: \"#\"\n          }\n        }\n      }\n    });\n    corePipeline.removePolicy({\n      phase: \"Retry\"\n    });\n    corePipeline.removePolicy({\n      name: decompressResponsePolicyName\n    });\n    corePipeline.addPolicy(storageCorrectContentLengthPolicy());\n    corePipeline.addPolicy(storageRetryPolicy(restOptions.retryOptions), {\n      phase: \"Retry\"\n    });\n    corePipeline.addPolicy(storageBrowserPolicy());\n    const downlevelResults = processDownlevelPipeline(pipeline);\n    if (downlevelResults) {\n      corePipeline.addPolicy(downlevelResults.wrappedPolicies, downlevelResults.afterRetry ? {\n        afterPhase: \"Retry\"\n      } : undefined);\n    }\n    const credential = getCredentialFromPipeline(pipeline);\n    if (isTokenCredential(credential)) {\n      corePipeline.addPolicy(bearerTokenAuthenticationPolicy({\n        credential,\n        scopes: restOptions.audience ?? StorageOAuthScopes,\n        challengeCallbacks: {\n          authorizeRequestOnChallenge: authorizeRequestOnTenantChallenge\n        }\n      }), {\n        phase: \"Sign\"\n      });\n    } else if (credential instanceof StorageSharedKeyCredential) {\n      corePipeline.addPolicy(storageSharedKeyCredentialPolicy({\n        accountName: credential.accountName,\n        accountKey: credential.accountKey\n      }), {\n        phase: \"Sign\"\n      });\n    }\n    pipeline._corePipeline = corePipeline;\n  }\n  return {\n    ...restOptions,\n    allowInsecureConnection: true,\n    httpClient,\n    pipeline: corePipeline\n  };\n}\nexport function getCredentialFromPipeline(pipeline) {\n  // see if we squirreled one away on the type itself\n  if (pipeline._credential) {\n    return pipeline._credential;\n  }\n  // if it came from another package, loop over the factories and look for one like before\n  let credential = new AnonymousCredential();\n  for (const factory of pipeline.factories) {\n    if (isTokenCredential(factory.credential)) {\n      // Only works if the factory has been attached a \"credential\" property.\n      // We do that in newPipeline() when using TokenCredential.\n      credential = factory.credential;\n    } else if (isStorageSharedKeyCredential(factory)) {\n      return factory;\n    }\n  }\n  return credential;\n}\nfunction isStorageSharedKeyCredential(factory) {\n  if (factory instanceof StorageSharedKeyCredential) {\n    return true;\n  }\n  return factory.constructor.name === \"StorageSharedKeyCredential\";\n}\nfunction isAnonymousCredential(factory) {\n  if (factory instanceof AnonymousCredential) {\n    return true;\n  }\n  return factory.constructor.name === \"AnonymousCredential\";\n}\nfunction isCoreHttpBearerTokenFactory(factory) {\n  return isTokenCredential(factory.credential);\n}\nfunction isStorageBrowserPolicyFactory(factory) {\n  if (factory instanceof StorageBrowserPolicyFactory) {\n    return true;\n  }\n  return factory.constructor.name === \"StorageBrowserPolicyFactory\";\n}\nfunction isStorageRetryPolicyFactory(factory) {\n  if (factory instanceof StorageRetryPolicyFactory) {\n    return true;\n  }\n  return factory.constructor.name === \"StorageRetryPolicyFactory\";\n}\nfunction isStorageTelemetryPolicyFactory(factory) {\n  return factory.constructor.name === \"TelemetryPolicyFactory\";\n}\nfunction isInjectorPolicyFactory(factory) {\n  return factory.constructor.name === \"InjectorPolicyFactory\";\n}\nfunction isCoreHttpPolicyFactory(factory) {\n  const knownPolicies = [\"GenerateClientRequestIdPolicy\", \"TracingPolicy\", \"LogPolicy\", \"ProxyPolicy\", \"DisableResponseDecompressionPolicy\", \"KeepAlivePolicy\", \"DeserializationPolicy\"];\n  const mockHttpClient = {\n    sendRequest: async request => {\n      return {\n        request,\n        headers: request.headers.clone(),\n        status: 500\n      };\n    }\n  };\n  const mockRequestPolicyOptions = {\n    log(_logLevel, _message) {\n      /* do nothing */\n    },\n    shouldLog(_logLevel) {\n      return false;\n    }\n  };\n  const policyInstance = factory.create(mockHttpClient, mockRequestPolicyOptions);\n  const policyName = policyInstance.constructor.name;\n  // bundlers sometimes add a custom suffix to the class name to make it unique\n  return knownPolicies.some(knownPolicyName => {\n    return policyName.startsWith(knownPolicyName);\n  });\n}","map":{"version":3,"names":["convertHttpClient","createRequestPolicyFactoryPolicy","bearerTokenAuthenticationPolicy","decompressResponsePolicyName","authorizeRequestOnTenantChallenge","createClientPipeline","parseXML","stringifyXML","isTokenCredential","logger","StorageRetryPolicyFactory","StorageSharedKeyCredential","AnonymousCredential","StorageOAuthScopes","StorageBlobLoggingAllowedHeaderNames","StorageBlobLoggingAllowedQueryParameters","SDK_VERSION","getCachedDefaultHttpClient","storageBrowserPolicy","storageRetryPolicy","storageSharedKeyCredentialPolicy","StorageBrowserPolicyFactory","storageCorrectContentLengthPolicy","isPipelineLike","pipeline","castPipeline","Array","isArray","factories","options","toServiceClientOptions","Pipeline","constructor","httpClient","requestPolicyFactories","newPipeline","credential","pipelineOptions","_credential","processDownlevelPipeline","knownFactoryFunctions","isAnonymousCredential","isStorageSharedKeyCredential","isCoreHttpBearerTokenFactory","isStorageBrowserPolicyFactory","isStorageRetryPolicyFactory","isStorageTelemetryPolicyFactory","isCoreHttpPolicyFactory","length","novelFactories","filter","factory","some","knownFactory","hasInjector","isInjectorPolicyFactory","wrappedPolicies","afterRetry","undefined","getCoreClientOptions","v1Client","restOptions","_coreHttpClient","corePipeline","_corePipeline","packageDetails","userAgentPrefix","userAgentOptions","loggingOptions","additionalAllowedHeaderNames","additionalAllowedQueryParameters","info","serializationOptions","serializerOptions","xml","xmlCharKey","deserializationOptions","removePolicy","phase","name","addPolicy","retryOptions","downlevelResults","afterPhase","getCredentialFromPipeline","scopes","audience","challengeCallbacks","authorizeRequestOnChallenge","accountName","accountKey","allowInsecureConnection","knownPolicies","mockHttpClient","sendRequest","request","headers","clone","status","mockRequestPolicyOptions","log","_logLevel","_message","shouldLog","policyInstance","create","policyName","knownPolicyName","startsWith"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@azure\\storage-blob\\src\\Pipeline.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  KeepAliveOptions,\n  ExtendedServiceClientOptions,\n  HttpPipelineLogLevel,\n} from \"@azure/core-http-compat\";\nimport {\n  CompatResponse as HttpOperationResponse,\n  RequestPolicy as IHttpClient,\n  HttpHeadersLike as HttpHeaders,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptionsLike as RequestPolicyOptions,\n  WebResourceLike as WebResource,\n  convertHttpClient,\n  createRequestPolicyFactoryPolicy,\n} from \"@azure/core-http-compat\";\nimport type {\n  ProxySettings as ProxyOptions,\n  UserAgentPolicyOptions as UserAgentOptions,\n  Pipeline as CorePipeline,\n  PipelinePolicy,\n  HttpClient,\n} from \"@azure/core-rest-pipeline\";\nimport {\n  RequestBodyType as HttpRequestBody,\n  bearerTokenAuthenticationPolicy,\n  decompressResponsePolicyName,\n} from \"@azure/core-rest-pipeline\";\nimport { authorizeRequestOnTenantChallenge, createClientPipeline } from \"@azure/core-client\";\nimport { parseXML, stringifyXML } from \"@azure/core-xml\";\nimport type { TokenCredential } from \"@azure/core-auth\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { logger } from \"./log.js\";\nimport type { StorageRetryOptions } from \"./StorageRetryPolicyFactory.js\";\nimport { StorageRetryPolicyFactory } from \"./StorageRetryPolicyFactory.js\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential.js\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential.js\";\nimport {\n  StorageOAuthScopes,\n  StorageBlobLoggingAllowedHeaderNames,\n  StorageBlobLoggingAllowedQueryParameters,\n  SDK_VERSION,\n} from \"./utils/constants.js\";\nimport { getCachedDefaultHttpClient } from \"@azure/storage-common\";\nimport { storageBrowserPolicy } from \"./policies/StorageBrowserPolicyV2.js\";\nimport { storageRetryPolicy } from \"./policies/StorageRetryPolicyV2.js\";\nimport { storageSharedKeyCredentialPolicy } from \"./policies/StorageSharedKeyCredentialPolicyV2.js\";\nimport { StorageBrowserPolicyFactory } from \"./StorageBrowserPolicyFactory.js\";\nimport { storageCorrectContentLengthPolicy } from \"./policies/StorageCorrectContentLengthPolicy.js\";\n\n// Export following interfaces and types for customers who want to implement their\n// own RequestPolicy or HTTPClient\nexport {\n  StorageOAuthScopes,\n  IHttpClient,\n  HttpHeaders,\n  HttpRequestBody,\n  HttpOperationResponse,\n  WebResource,\n  RequestPolicyFactory,\n  RequestPolicy,\n  RequestPolicyOptions,\n};\n\n/**\n * A subset of `@azure/core-http` ServiceClientOptions\n */\nexport interface ServiceClientOptions {\n  /**\n   * Optional. Configures the HTTP client to send requests and receive responses.\n   */\n  httpClient?: IHttpClient;\n  /**\n   * Optional. Overrides the default policy factories.\n   */\n  requestPolicyFactories?:\n    | RequestPolicyFactory[]\n    | ((defaultRequestPolicyFactories: RequestPolicyFactory[]) => void | RequestPolicyFactory[]);\n}\n\n/**\n * Option interface for Pipeline constructor.\n */\nexport interface PipelineOptions {\n  /**\n   * Optional. Configures the HTTP client to send requests and receive responses.\n   */\n  httpClient?: IHttpClient;\n}\n\n/**\n * An interface for the {@link Pipeline} class containing HTTP request policies.\n * You can create a default Pipeline by calling {@link newPipeline}.\n * Or you can create a Pipeline with your own policies by the constructor of Pipeline.\n *\n * Refer to {@link newPipeline} and provided policies before implementing your\n * customized Pipeline.\n */\nexport interface PipelineLike {\n  /**\n   * A list of chained request policy factories.\n   */\n  readonly factories: RequestPolicyFactory[];\n  /**\n   * Configures pipeline logger and HTTP client.\n   */\n  readonly options: PipelineOptions;\n  /**\n   * Transfer Pipeline object to ServiceClientOptions object which is required by\n   * ServiceClient constructor.\n   *\n   * @returns The ServiceClientOptions object from this Pipeline.\n   */\n  toServiceClientOptions(): ServiceClientOptions;\n}\n\n/**\n * A helper to decide if a given argument satisfies the Pipeline contract\n * @param pipeline - An argument that may be a Pipeline\n * @returns true when the argument satisfies the Pipeline contract\n */\nexport function isPipelineLike(pipeline: unknown): pipeline is PipelineLike {\n  if (!pipeline || typeof pipeline !== \"object\") {\n    return false;\n  }\n\n  const castPipeline = pipeline as PipelineLike;\n\n  return (\n    Array.isArray(castPipeline.factories) &&\n    typeof castPipeline.options === \"object\" &&\n    typeof castPipeline.toServiceClientOptions === \"function\"\n  );\n}\n\n/**\n * A Pipeline class containing HTTP request policies.\n * You can create a default Pipeline by calling {@link newPipeline}.\n * Or you can create a Pipeline with your own policies by the constructor of Pipeline.\n *\n * Refer to {@link newPipeline} and provided policies before implementing your\n * customized Pipeline.\n */\nexport class Pipeline implements PipelineLike {\n  /**\n   * A list of chained request policy factories.\n   */\n  public readonly factories: RequestPolicyFactory[];\n  /**\n   * Configures pipeline logger and HTTP client.\n   */\n  public readonly options: PipelineOptions;\n\n  /**\n   * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.\n   *\n   * @param factories -\n   * @param options -\n   */\n  constructor(factories: RequestPolicyFactory[], options: PipelineOptions = {}) {\n    this.factories = factories;\n    this.options = options;\n  }\n\n  /**\n   * Transfer Pipeline object to ServiceClientOptions object which is required by\n   * ServiceClient constructor.\n   *\n   * @returns The ServiceClientOptions object from this Pipeline.\n   */\n  public toServiceClientOptions(): ServiceClientOptions {\n    return {\n      httpClient: this.options.httpClient,\n      requestPolicyFactories: this.factories,\n    };\n  }\n}\n\n/**\n * Options interface for the {@link newPipeline} function.\n */\nexport interface StoragePipelineOptions {\n  /**\n   * Options to configure a proxy for outgoing requests.\n   */\n  proxyOptions?: ProxyOptions;\n  /**\n   * Options for adding user agent details to outgoing requests.\n   */\n  userAgentOptions?: UserAgentOptions;\n  /**\n   * Configures the built-in retry policy behavior.\n   */\n  retryOptions?: StorageRetryOptions;\n  /**\n   * Keep alive configurations. Default keep-alive is enabled.\n   */\n  keepAliveOptions?: KeepAliveOptions;\n  /**\n   * Configures the HTTP client to send requests and receive responses.\n   */\n  httpClient?: IHttpClient;\n  /**\n   * The audience used to retrieve an AAD token.\n   * By default, audience 'https://storage.azure.com/.default' will be used.\n   */\n  audience?: string | string[];\n}\n\n/**\n * Creates a new Pipeline object with Credential provided.\n *\n * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n * @param pipelineOptions - Optional. Options.\n * @returns A new Pipeline object.\n */\nexport function newPipeline(\n  credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n  pipelineOptions: StoragePipelineOptions = {},\n): Pipeline {\n  if (!credential) {\n    credential = new AnonymousCredential();\n  }\n  const pipeline = new Pipeline([], pipelineOptions);\n  (pipeline as any)._credential = credential;\n  return pipeline;\n}\n\nfunction processDownlevelPipeline(\n  pipeline: PipelineLike,\n): { wrappedPolicies: PipelinePolicy; afterRetry: boolean } | undefined {\n  const knownFactoryFunctions = [\n    isAnonymousCredential,\n    isStorageSharedKeyCredential,\n    isCoreHttpBearerTokenFactory,\n    isStorageBrowserPolicyFactory,\n    isStorageRetryPolicyFactory,\n    isStorageTelemetryPolicyFactory,\n    isCoreHttpPolicyFactory,\n  ];\n  if (pipeline.factories.length) {\n    const novelFactories = pipeline.factories.filter((factory) => {\n      return !knownFactoryFunctions.some((knownFactory) => knownFactory(factory));\n    });\n    if (novelFactories.length) {\n      const hasInjector = novelFactories.some((factory) => isInjectorPolicyFactory(factory));\n      // if there are any left over, wrap in a requestPolicyFactoryPolicy\n      return {\n        wrappedPolicies: createRequestPolicyFactoryPolicy(novelFactories),\n        afterRetry: hasInjector,\n      };\n    }\n  }\n  return undefined;\n}\n\nexport function getCoreClientOptions(pipeline: PipelineLike): ExtendedServiceClientOptions {\n  const { httpClient: v1Client, ...restOptions } = pipeline.options as StoragePipelineOptions;\n\n  let httpClient: HttpClient = (pipeline as any)._coreHttpClient;\n  if (!httpClient) {\n    httpClient = v1Client ? convertHttpClient(v1Client) : getCachedDefaultHttpClient();\n    (pipeline as any)._coreHttpClient = httpClient;\n  }\n\n  let corePipeline: CorePipeline = (pipeline as any)._corePipeline;\n  if (!corePipeline) {\n    const packageDetails = `azsdk-js-azure-storage-blob/${SDK_VERSION}`;\n    const userAgentPrefix =\n      restOptions.userAgentOptions && restOptions.userAgentOptions.userAgentPrefix\n        ? `${restOptions.userAgentOptions.userAgentPrefix} ${packageDetails}`\n        : `${packageDetails}`;\n    corePipeline = createClientPipeline({\n      ...restOptions,\n      loggingOptions: {\n        additionalAllowedHeaderNames: StorageBlobLoggingAllowedHeaderNames,\n        additionalAllowedQueryParameters: StorageBlobLoggingAllowedQueryParameters,\n        logger: logger.info,\n      },\n      userAgentOptions: {\n        userAgentPrefix,\n      },\n      serializationOptions: {\n        stringifyXML,\n        serializerOptions: {\n          xml: {\n            // Use customized XML char key of \"#\" so we can deserialize metadata\n            // with \"_\" key\n            xmlCharKey: \"#\",\n          },\n        },\n      },\n      deserializationOptions: {\n        parseXML,\n        serializerOptions: {\n          xml: {\n            // Use customized XML char key of \"#\" so we can deserialize metadata\n            // with \"_\" key\n            xmlCharKey: \"#\",\n          },\n        },\n      },\n    });\n    corePipeline.removePolicy({ phase: \"Retry\" });\n    corePipeline.removePolicy({ name: decompressResponsePolicyName });\n    corePipeline.addPolicy(storageCorrectContentLengthPolicy());\n    corePipeline.addPolicy(storageRetryPolicy(restOptions.retryOptions), { phase: \"Retry\" });\n    corePipeline.addPolicy(storageBrowserPolicy());\n    const downlevelResults = processDownlevelPipeline(pipeline);\n    if (downlevelResults) {\n      corePipeline.addPolicy(\n        downlevelResults.wrappedPolicies,\n        downlevelResults.afterRetry ? { afterPhase: \"Retry\" } : undefined,\n      );\n    }\n    const credential = getCredentialFromPipeline(pipeline);\n    if (isTokenCredential(credential)) {\n      corePipeline.addPolicy(\n        bearerTokenAuthenticationPolicy({\n          credential,\n          scopes: restOptions.audience ?? StorageOAuthScopes,\n          challengeCallbacks: { authorizeRequestOnChallenge: authorizeRequestOnTenantChallenge },\n        }),\n        { phase: \"Sign\" },\n      );\n    } else if (credential instanceof StorageSharedKeyCredential) {\n      corePipeline.addPolicy(\n        storageSharedKeyCredentialPolicy({\n          accountName: credential.accountName,\n          accountKey: (credential as any).accountKey,\n        }),\n        { phase: \"Sign\" },\n      );\n    }\n    (pipeline as any)._corePipeline = corePipeline;\n  }\n  return {\n    ...restOptions,\n    allowInsecureConnection: true,\n    httpClient,\n    pipeline: corePipeline,\n  };\n}\n\nexport function getCredentialFromPipeline(\n  pipeline: PipelineLike,\n): StorageSharedKeyCredential | AnonymousCredential | TokenCredential {\n  // see if we squirreled one away on the type itself\n  if ((pipeline as any)._credential) {\n    return (pipeline as any)._credential;\n  }\n  // if it came from another package, loop over the factories and look for one like before\n  let credential = new AnonymousCredential();\n  for (const factory of pipeline.factories) {\n    if (isTokenCredential((factory as any).credential)) {\n      // Only works if the factory has been attached a \"credential\" property.\n      // We do that in newPipeline() when using TokenCredential.\n      credential = (factory as any).credential;\n    } else if (isStorageSharedKeyCredential(factory)) {\n      return factory;\n    }\n  }\n  return credential;\n}\n\nfunction isStorageSharedKeyCredential(\n  factory: RequestPolicyFactory,\n): factory is StorageSharedKeyCredential {\n  if (factory instanceof StorageSharedKeyCredential) {\n    return true;\n  }\n  return factory.constructor.name === \"StorageSharedKeyCredential\";\n}\n\nfunction isAnonymousCredential(factory: RequestPolicyFactory): factory is AnonymousCredential {\n  if (factory instanceof AnonymousCredential) {\n    return true;\n  }\n  return factory.constructor.name === \"AnonymousCredential\";\n}\n\nfunction isCoreHttpBearerTokenFactory(factory: RequestPolicyFactory): boolean {\n  return isTokenCredential((factory as any).credential);\n}\n\nfunction isStorageBrowserPolicyFactory(\n  factory: RequestPolicyFactory,\n): factory is StorageBrowserPolicyFactory {\n  if (factory instanceof StorageBrowserPolicyFactory) {\n    return true;\n  }\n  return factory.constructor.name === \"StorageBrowserPolicyFactory\";\n}\n\nfunction isStorageRetryPolicyFactory(\n  factory: RequestPolicyFactory,\n): factory is StorageRetryPolicyFactory {\n  if (factory instanceof StorageRetryPolicyFactory) {\n    return true;\n  }\n  return factory.constructor.name === \"StorageRetryPolicyFactory\";\n}\n\nfunction isStorageTelemetryPolicyFactory(factory: RequestPolicyFactory): boolean {\n  return factory.constructor.name === \"TelemetryPolicyFactory\";\n}\n\nfunction isInjectorPolicyFactory(factory: RequestPolicyFactory): boolean {\n  return factory.constructor.name === \"InjectorPolicyFactory\";\n}\n\nfunction isCoreHttpPolicyFactory(factory: RequestPolicyFactory): boolean {\n  const knownPolicies = [\n    \"GenerateClientRequestIdPolicy\",\n    \"TracingPolicy\",\n    \"LogPolicy\",\n    \"ProxyPolicy\",\n    \"DisableResponseDecompressionPolicy\",\n    \"KeepAlivePolicy\",\n    \"DeserializationPolicy\",\n  ];\n\n  const mockHttpClient: IHttpClient = {\n    sendRequest: async (request: WebResource) => {\n      return {\n        request,\n        headers: request.headers.clone(),\n        status: 500,\n      };\n    },\n  };\n  const mockRequestPolicyOptions: RequestPolicyOptions = {\n    log(_logLevel: HttpPipelineLogLevel, _message: string): void {\n      /* do nothing */\n    },\n    shouldLog(_logLevel: HttpPipelineLogLevel): boolean {\n      return false;\n    },\n  };\n  const policyInstance = factory.create(mockHttpClient, mockRequestPolicyOptions);\n  const policyName = policyInstance.constructor.name;\n  // bundlers sometimes add a custom suffix to the class name to make it unique\n  return knownPolicies.some((knownPolicyName) => {\n    return policyName.startsWith(knownPolicyName);\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}