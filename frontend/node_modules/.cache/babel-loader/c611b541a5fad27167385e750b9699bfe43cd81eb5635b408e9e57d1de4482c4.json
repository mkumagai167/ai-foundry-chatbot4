{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { stringToUint8Array } from \"../util/bytesEncoding.js\";\nimport { isNodeLike } from \"../util/checkEnvironment.js\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\n/**\n * The programmatic identifier of the formDataPolicy.\n */\nexport const formDataPolicyName = \"formDataPolicy\";\nfunction formDataToFormDataMap(formData) {\n  const formDataMap = {};\n  for (const [key, value] of formData.entries()) {\n    formDataMap[key] ??= [];\n    formDataMap[key].push(value);\n  }\n  return formDataMap;\n}\n/**\n * A policy that encodes FormData on the request into the body.\n */\nexport function formDataPolicy() {\n  return {\n    name: formDataPolicyName,\n    async sendRequest(request, next) {\n      if (isNodeLike && typeof FormData !== \"undefined\" && request.body instanceof FormData) {\n        request.formData = formDataToFormDataMap(request.body);\n        request.body = undefined;\n      }\n      if (request.formData) {\n        const contentType = request.headers.get(\"Content-Type\");\n        if (contentType && contentType.indexOf(\"application/x-www-form-urlencoded\") !== -1) {\n          request.body = wwwFormUrlEncode(request.formData);\n        } else {\n          await prepareFormData(request.formData, request);\n        }\n        request.formData = undefined;\n      }\n      return next(request);\n    }\n  };\n}\nfunction wwwFormUrlEncode(formData) {\n  const urlSearchParams = new URLSearchParams();\n  for (const [key, value] of Object.entries(formData)) {\n    if (Array.isArray(value)) {\n      for (const subValue of value) {\n        urlSearchParams.append(key, subValue.toString());\n      }\n    } else {\n      urlSearchParams.append(key, value.toString());\n    }\n  }\n  return urlSearchParams.toString();\n}\nasync function prepareFormData(formData, request) {\n  // validate content type (multipart/form-data)\n  const contentType = request.headers.get(\"Content-Type\");\n  if (contentType && !contentType.startsWith(\"multipart/form-data\")) {\n    // content type is specified and is not multipart/form-data. Exit.\n    return;\n  }\n  request.headers.set(\"Content-Type\", contentType ?? \"multipart/form-data\");\n  // set body to MultipartRequestBody using content from FormDataMap\n  const parts = [];\n  for (const [fieldName, values] of Object.entries(formData)) {\n    for (const value of Array.isArray(values) ? values : [values]) {\n      if (typeof value === \"string\") {\n        parts.push({\n          headers: createHttpHeaders({\n            \"Content-Disposition\": `form-data; name=\"${fieldName}\"`\n          }),\n          body: stringToUint8Array(value, \"utf-8\")\n        });\n      } else if (value === undefined || value === null || typeof value !== \"object\") {\n        throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);\n      } else {\n        // using || instead of ?? here since if value.name is empty we should create a file name\n        const fileName = value.name || \"blob\";\n        const headers = createHttpHeaders();\n        headers.set(\"Content-Disposition\", `form-data; name=\"${fieldName}\"; filename=\"${fileName}\"`);\n        // again, || is used since an empty value.type means the content type is unset\n        headers.set(\"Content-Type\", value.type || \"application/octet-stream\");\n        parts.push({\n          headers,\n          body: value\n        });\n      }\n    }\n  }\n  request.multipartBody = {\n    parts\n  };\n}","map":{"version":3,"names":["stringToUint8Array","isNodeLike","createHttpHeaders","formDataPolicyName","formDataToFormDataMap","formData","formDataMap","key","value","entries","push","formDataPolicy","name","sendRequest","request","next","FormData","body","undefined","contentType","headers","get","indexOf","wwwFormUrlEncode","prepareFormData","urlSearchParams","URLSearchParams","Object","Array","isArray","subValue","append","toString","startsWith","set","parts","fieldName","values","Error","fileName","type","multipartBody"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@typespec\\ts-http-runtime\\src\\policies\\formDataPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { stringToUint8Array } from \"../util/bytesEncoding.js\";\nimport { isNodeLike } from \"../util/checkEnvironment.js\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\nimport type {\n  BodyPart,\n  FormDataMap,\n  FormDataValue,\n  PipelineRequest,\n  PipelineResponse,\n  SendRequest,\n} from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\n\n/**\n * The programmatic identifier of the formDataPolicy.\n */\nexport const formDataPolicyName = \"formDataPolicy\";\n\nfunction formDataToFormDataMap(formData: FormData): FormDataMap {\n  const formDataMap: FormDataMap = {};\n  for (const [key, value] of formData.entries()) {\n    formDataMap[key] ??= [];\n    (formDataMap[key] as FormDataValue[]).push(value);\n  }\n  return formDataMap;\n}\n\n/**\n * A policy that encodes FormData on the request into the body.\n */\nexport function formDataPolicy(): PipelinePolicy {\n  return {\n    name: formDataPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (isNodeLike && typeof FormData !== \"undefined\" && request.body instanceof FormData) {\n        request.formData = formDataToFormDataMap(request.body);\n        request.body = undefined;\n      }\n\n      if (request.formData) {\n        const contentType = request.headers.get(\"Content-Type\");\n        if (contentType && contentType.indexOf(\"application/x-www-form-urlencoded\") !== -1) {\n          request.body = wwwFormUrlEncode(request.formData);\n        } else {\n          await prepareFormData(request.formData, request);\n        }\n\n        request.formData = undefined;\n      }\n      return next(request);\n    },\n  };\n}\n\nfunction wwwFormUrlEncode(formData: FormDataMap): string {\n  const urlSearchParams = new URLSearchParams();\n  for (const [key, value] of Object.entries(formData)) {\n    if (Array.isArray(value)) {\n      for (const subValue of value) {\n        urlSearchParams.append(key, subValue.toString());\n      }\n    } else {\n      urlSearchParams.append(key, value.toString());\n    }\n  }\n  return urlSearchParams.toString();\n}\n\nasync function prepareFormData(formData: FormDataMap, request: PipelineRequest): Promise<void> {\n  // validate content type (multipart/form-data)\n  const contentType = request.headers.get(\"Content-Type\");\n  if (contentType && !contentType.startsWith(\"multipart/form-data\")) {\n    // content type is specified and is not multipart/form-data. Exit.\n    return;\n  }\n\n  request.headers.set(\"Content-Type\", contentType ?? \"multipart/form-data\");\n\n  // set body to MultipartRequestBody using content from FormDataMap\n  const parts: BodyPart[] = [];\n\n  for (const [fieldName, values] of Object.entries(formData)) {\n    for (const value of Array.isArray(values) ? values : [values]) {\n      if (typeof value === \"string\") {\n        parts.push({\n          headers: createHttpHeaders({\n            \"Content-Disposition\": `form-data; name=\"${fieldName}\"`,\n          }),\n          body: stringToUint8Array(value, \"utf-8\"),\n        });\n      } else if (value === undefined || value === null || typeof value !== \"object\") {\n        throw new Error(\n          `Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`,\n        );\n      } else {\n        // using || instead of ?? here since if value.name is empty we should create a file name\n        const fileName = (value as File).name || \"blob\";\n        const headers = createHttpHeaders();\n        headers.set(\n          \"Content-Disposition\",\n          `form-data; name=\"${fieldName}\"; filename=\"${fileName}\"`,\n        );\n\n        // again, || is used since an empty value.type means the content type is unset\n        headers.set(\"Content-Type\", value.type || \"application/octet-stream\");\n\n        parts.push({\n          headers,\n          body: value,\n        });\n      }\n    }\n  }\n  request.multipartBody = { parts };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}