{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { createClientPipeline } from \"./pipeline.js\";\nimport { flattenResponse } from \"./utils.js\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nimport { getRequestUrl } from \"./urlHelpers.js\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers.js\";\nimport { logger } from \"./log.js\";\n/**\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   */\n  _endpoint;\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  _requestContentType;\n  /**\n   * Set to true if the request is sent over HTTP instead of HTTPS\n   */\n  _allowInsecureConnection;\n  /**\n   * The HTTP client that will be used to send requests.\n   */\n  _httpClient;\n  /**\n   * The pipeline used by this client to make requests\n   */\n  pipeline;\n  /**\n   * The ServiceClient constructor\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(options = {}) {\n    this._requestContentType = options.requestContentType;\n    this._endpoint = options.endpoint ?? options.baseUri;\n    if (options.baseUri) {\n      logger.warning(\"The baseUri option for SDK Clients has been deprecated, please use endpoint instead.\");\n    }\n    this._allowInsecureConnection = options.allowInsecureConnection;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this.pipeline = options.pipeline || createDefaultPipeline(options);\n    if (options.additionalPolicies?.length) {\n      for (const {\n        policy,\n        position\n      } of options.additionalPolicies) {\n        // Sign happens after Retry and is commonly needed to occur\n        // before policies that intercept post-retry.\n        const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n        this.pipeline.addPolicy(policy, {\n          afterPhase\n        });\n      }\n    }\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n  async sendRequest(request) {\n    return this.pipeline.sendRequest(this._httpClient, request);\n  }\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @typeParam T - The typed result of the request, based on the OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   */\n  async sendOperationRequest(operationArguments, operationSpec) {\n    const endpoint = operationSpec.baseUrl || this._endpoint;\n    if (!endpoint) {\n      throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.\");\n    }\n    // Templatized URLs sometimes reference properties on the ServiceClient child class,\n    // so we have to pass `this` below in order to search these properties if they're\n    // not part of OperationArguments\n    const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);\n    const request = createPipelineRequest({\n      url\n    });\n    request.method = operationSpec.httpMethod;\n    const operationInfo = getOperationRequestInfo(request);\n    operationInfo.operationSpec = operationSpec;\n    operationInfo.operationArguments = operationArguments;\n    const contentType = operationSpec.contentType || this._requestContentType;\n    if (contentType && operationSpec.requestBody) {\n      request.headers.set(\"Content-Type\", contentType);\n    }\n    const options = operationArguments.options;\n    if (options) {\n      const requestOptions = options.requestOptions;\n      if (requestOptions) {\n        if (requestOptions.timeout) {\n          request.timeout = requestOptions.timeout;\n        }\n        if (requestOptions.onUploadProgress) {\n          request.onUploadProgress = requestOptions.onUploadProgress;\n        }\n        if (requestOptions.onDownloadProgress) {\n          request.onDownloadProgress = requestOptions.onDownloadProgress;\n        }\n        if (requestOptions.shouldDeserialize !== undefined) {\n          operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n        }\n        if (requestOptions.allowInsecureConnection) {\n          request.allowInsecureConnection = true;\n        }\n      }\n      if (options.abortSignal) {\n        request.abortSignal = options.abortSignal;\n      }\n      if (options.tracingOptions) {\n        request.tracingOptions = options.tracingOptions;\n      }\n    }\n    if (this._allowInsecureConnection) {\n      request.allowInsecureConnection = true;\n    }\n    if (request.streamResponseStatusCodes === undefined) {\n      request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n    }\n    try {\n      const rawResponse = await this.sendRequest(request);\n      const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);\n      if (options?.onResponse) {\n        options.onResponse(rawResponse, flatResponse);\n      }\n      return flatResponse;\n    } catch (error) {\n      if (typeof error === \"object\" && error?.response) {\n        const rawResponse = error.response;\n        const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"]);\n        error.details = flatResponse;\n        if (options?.onResponse) {\n          options.onResponse(rawResponse, flatResponse, error);\n        }\n      }\n      throw error;\n    }\n  }\n}\nfunction createDefaultPipeline(options) {\n  const credentialScopes = getCredentialScopes(options);\n  const credentialOptions = options.credential && credentialScopes ? {\n    credentialScopes,\n    credential: options.credential\n  } : undefined;\n  return createClientPipeline({\n    ...options,\n    credentialOptions\n  });\n}\nfunction getCredentialScopes(options) {\n  if (options.credentialScopes) {\n    return options.credentialScopes;\n  }\n  if (options.endpoint) {\n    return `${options.endpoint}/.default`;\n  }\n  if (options.baseUri) {\n    return `${options.baseUri}/.default`;\n  }\n  if (options.credential && !options.credentialScopes) {\n    throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);\n  }\n  return undefined;\n}","map":{"version":3,"names":["createPipelineRequest","createClientPipeline","flattenResponse","getCachedDefaultHttpClient","getOperationRequestInfo","getRequestUrl","getStreamingResponseStatusCodes","logger","ServiceClient","_endpoint","_requestContentType","_allowInsecureConnection","_httpClient","pipeline","constructor","options","requestContentType","endpoint","baseUri","warning","allowInsecureConnection","httpClient","createDefaultPipeline","additionalPolicies","length","policy","position","afterPhase","undefined","addPolicy","sendRequest","request","sendOperationRequest","operationArguments","operationSpec","baseUrl","Error","url","method","httpMethod","operationInfo","contentType","requestBody","headers","set","requestOptions","timeout","onUploadProgress","onDownloadProgress","shouldDeserialize","abortSignal","tracingOptions","streamResponseStatusCodes","rawResponse","flatResponse","responses","status","onResponse","error","response","statusCode","details","credentialScopes","getCredentialScopes","credentialOptions","credential"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@azure\\core-client\\src\\serviceClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  CommonClientOptions,\n  OperationArguments,\n  OperationRequest,\n  OperationSpec,\n} from \"./interfaces.js\";\nimport type {\n  HttpClient,\n  Pipeline,\n  PipelineRequest,\n  PipelineResponse,\n} from \"@azure/core-rest-pipeline\";\nimport { createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport type { TokenCredential } from \"@azure/core-auth\";\nimport { createClientPipeline } from \"./pipeline.js\";\nimport { flattenResponse } from \"./utils.js\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nimport { getRequestUrl } from \"./urlHelpers.js\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers.js\";\nimport { logger } from \"./log.js\";\n\n/**\n * Options to be provided while creating the client.\n */\nexport interface ServiceClientOptions extends CommonClientOptions {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   * @deprecated This property is deprecated and will be removed soon, please use endpoint instead\n   */\n  baseUri?: string;\n  /**\n   * If specified, this is the endpoint that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   * to encourage customer to use endpoint, we mark the baseUri as deprecated.\n   */\n  endpoint?: string;\n  /**\n   * If specified, will be used to build the BearerTokenAuthenticationPolicy.\n   */\n  credentialScopes?: string | string[];\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  requestContentType?: string;\n  /**\n   * Credential used to authenticate the request.\n   */\n  credential?: TokenCredential;\n  /**\n   * A customized pipeline to use, otherwise a default one will be created.\n   */\n  pipeline?: Pipeline;\n}\n\n/**\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   */\n  private readonly _endpoint?: string;\n\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  private readonly _requestContentType?: string;\n\n  /**\n   * Set to true if the request is sent over HTTP instead of HTTPS\n   */\n  private readonly _allowInsecureConnection?: boolean;\n\n  /**\n   * The HTTP client that will be used to send requests.\n   */\n  private readonly _httpClient: HttpClient;\n\n  /**\n   * The pipeline used by this client to make requests\n   */\n  public readonly pipeline: Pipeline;\n\n  /**\n   * The ServiceClient constructor\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(options: ServiceClientOptions = {}) {\n    this._requestContentType = options.requestContentType;\n    this._endpoint = options.endpoint ?? options.baseUri;\n    if (options.baseUri) {\n      logger.warning(\n        \"The baseUri option for SDK Clients has been deprecated, please use endpoint instead.\",\n      );\n    }\n    this._allowInsecureConnection = options.allowInsecureConnection;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n\n    this.pipeline = options.pipeline || createDefaultPipeline(options);\n    if (options.additionalPolicies?.length) {\n      for (const { policy, position } of options.additionalPolicies) {\n        // Sign happens after Retry and is commonly needed to occur\n        // before policies that intercept post-retry.\n        const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n        this.pipeline.addPolicy(policy, {\n          afterPhase,\n        });\n      }\n    }\n  }\n\n  /**\n   * Send the provided httpRequest.\n   */\n  async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {\n    return this.pipeline.sendRequest(this._httpClient, request);\n  }\n\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @typeParam T - The typed result of the request, based on the OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   */\n  async sendOperationRequest<T>(\n    operationArguments: OperationArguments,\n    operationSpec: OperationSpec,\n  ): Promise<T> {\n    const endpoint: string | undefined = operationSpec.baseUrl || this._endpoint;\n    if (!endpoint) {\n      throw new Error(\n        \"If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.\",\n      );\n    }\n\n    // Templatized URLs sometimes reference properties on the ServiceClient child class,\n    // so we have to pass `this` below in order to search these properties if they're\n    // not part of OperationArguments\n    const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);\n\n    const request: OperationRequest = createPipelineRequest({\n      url,\n    });\n    request.method = operationSpec.httpMethod;\n    const operationInfo = getOperationRequestInfo(request);\n    operationInfo.operationSpec = operationSpec;\n    operationInfo.operationArguments = operationArguments;\n\n    const contentType = operationSpec.contentType || this._requestContentType;\n    if (contentType && operationSpec.requestBody) {\n      request.headers.set(\"Content-Type\", contentType);\n    }\n\n    const options = operationArguments.options;\n    if (options) {\n      const requestOptions = options.requestOptions;\n\n      if (requestOptions) {\n        if (requestOptions.timeout) {\n          request.timeout = requestOptions.timeout;\n        }\n\n        if (requestOptions.onUploadProgress) {\n          request.onUploadProgress = requestOptions.onUploadProgress;\n        }\n\n        if (requestOptions.onDownloadProgress) {\n          request.onDownloadProgress = requestOptions.onDownloadProgress;\n        }\n\n        if (requestOptions.shouldDeserialize !== undefined) {\n          operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n        }\n\n        if (requestOptions.allowInsecureConnection) {\n          request.allowInsecureConnection = true;\n        }\n      }\n\n      if (options.abortSignal) {\n        request.abortSignal = options.abortSignal;\n      }\n\n      if (options.tracingOptions) {\n        request.tracingOptions = options.tracingOptions;\n      }\n    }\n\n    if (this._allowInsecureConnection) {\n      request.allowInsecureConnection = true;\n    }\n\n    if (request.streamResponseStatusCodes === undefined) {\n      request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n    }\n\n    try {\n      const rawResponse = await this.sendRequest(request);\n      const flatResponse = flattenResponse(\n        rawResponse,\n        operationSpec.responses[rawResponse.status],\n      ) as T;\n      if (options?.onResponse) {\n        options.onResponse(rawResponse, flatResponse);\n      }\n      return flatResponse;\n    } catch (error: any) {\n      if (typeof error === \"object\" && error?.response) {\n        const rawResponse = error.response;\n        const flatResponse = flattenResponse(\n          rawResponse,\n          operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"],\n        );\n        error.details = flatResponse;\n        if (options?.onResponse) {\n          options.onResponse(rawResponse, flatResponse, error);\n        }\n      }\n      throw error;\n    }\n  }\n}\n\nfunction createDefaultPipeline(options: ServiceClientOptions): Pipeline {\n  const credentialScopes = getCredentialScopes(options);\n  const credentialOptions =\n    options.credential && credentialScopes\n      ? { credentialScopes, credential: options.credential }\n      : undefined;\n\n  return createClientPipeline({\n    ...options,\n    credentialOptions,\n  });\n}\n\nfunction getCredentialScopes(options: ServiceClientOptions): string | string[] | undefined {\n  if (options.credentialScopes) {\n    return options.credentialScopes;\n  }\n\n  if (options.endpoint) {\n    return `${options.endpoint}/.default`;\n  }\n\n  if (options.baseUri) {\n    return `${options.baseUri}/.default`;\n  }\n\n  if (options.credential && !options.credentialScopes) {\n    throw new Error(\n      `When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`,\n    );\n  }\n\n  return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}