{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createHttpHeaders } from \"@azure/core-rest-pipeline\";\nimport { isNodeLike } from \"@azure/core-util\";\nimport { DevelopmentConnectionString, HeaderConstants, PathStylePorts, URLConstants } from \"./constants.js\";\n/**\n * Reserved URL characters must be properly escaped for Storage services like Blob or File.\n *\n * ## URL encode and escape strategy for JS SDKs\n *\n * When customers pass a URL string into XxxClient classes constructor, the URL string may already be URL encoded or not.\n * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL\n * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XxxClient constructors.\n *\n * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.\n *\n * This is what legacy V2 SDK does, simple and works for most of the cases.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%253A\" and send to server. A blob named \"b%3A\" will be created.\n *\n * But this strategy will make it not possible to create a blob with \"?\" in it's name. Because when customer URL string is\n * \"http://account.blob.core.windows.net/con/blob?name\", the \"?name\" will be treated as URL paramter instead of blob name.\n * If customer URL string is \"http://account.blob.core.windows.net/con/blob%3Fname\", a blob named \"blob%3Fname\" will be created.\n * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.\n * We cannot accept a SDK cannot create a blob name with \"?\". So we implement strategy two:\n *\n * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.\n *\n * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will escape \":\" like \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%3A\" to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%253A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%253A\" to server. A blob named \"b%3A\" will be created.\n *\n * This strategy gives us flexibility to create with any special characters. But \"%\" will be treated as a special characters, if the URL string\n * is not encoded, there shouldn't a \"%\" in the URL string, otherwise the URL is not a valid URL.\n * If customer needs to create a blob with \"%\" in it's blob name, use \"%25\" instead of \"%\". Just like above 3rd sample.\n * And following URL strings are invalid:\n * - \"http://account.blob.core.windows.net/con/b%\"\n * - \"http://account.blob.core.windows.net/con/b%2\"\n * - \"http://account.blob.core.windows.net/con/b%G\"\n *\n * Another special character is \"?\", use \"%2F\" to represent a blob name with \"?\" in a URL string.\n *\n * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `containerClient.getBlobClient(blobName)`\n *\n * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.\n *\n * @see https://learn.microsoft.com/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata\n * @see https://learn.microsoft.com/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata\n *\n * @param url -\n */\nexport function escapeURLPath(url) {\n  const urlParsed = new URL(url);\n  let path = urlParsed.pathname;\n  path = path || \"/\";\n  path = escape(path);\n  urlParsed.pathname = path;\n  return urlParsed.toString();\n}\nfunction getProxyUriFromDevConnString(connectionString) {\n  // Development Connection String\n  // https://learn.microsoft.com/azure/storage/common/storage-configure-connection-string#connect-to-the-emulator-account-using-the-well-known-account-name-and-key\n  let proxyUri = \"\";\n  if (connectionString.search(\"DevelopmentStorageProxyUri=\") !== -1) {\n    // CONNECTION_STRING=UseDevelopmentStorage=true;DevelopmentStorageProxyUri=http://myProxyUri\n    const matchCredentials = connectionString.split(\";\");\n    for (const element of matchCredentials) {\n      if (element.trim().startsWith(\"DevelopmentStorageProxyUri=\")) {\n        proxyUri = element.trim().match(\"DevelopmentStorageProxyUri=(.*)\")[1];\n      }\n    }\n  }\n  return proxyUri;\n}\nexport function getValueInConnString(connectionString, argument) {\n  const elements = connectionString.split(\";\");\n  for (const element of elements) {\n    if (element.trim().startsWith(argument)) {\n      return element.trim().match(argument + \"=(.*)\")[1];\n    }\n  }\n  return \"\";\n}\n/**\n * Extracts the parts of an Azure Storage account connection string.\n *\n * @param connectionString - Connection string.\n * @returns String key value pairs of the storage account's url and credentials.\n */\nexport function extractConnectionStringParts(connectionString) {\n  let proxyUri = \"\";\n  if (connectionString.startsWith(\"UseDevelopmentStorage=true\")) {\n    // Development connection string\n    proxyUri = getProxyUriFromDevConnString(connectionString);\n    connectionString = DevelopmentConnectionString;\n  }\n  // Matching BlobEndpoint in the Account connection string\n  let blobEndpoint = getValueInConnString(connectionString, \"BlobEndpoint\");\n  // Slicing off '/' at the end if exists\n  // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)\n  blobEndpoint = blobEndpoint.endsWith(\"/\") ? blobEndpoint.slice(0, -1) : blobEndpoint;\n  if (connectionString.search(\"DefaultEndpointsProtocol=\") !== -1 && connectionString.search(\"AccountKey=\") !== -1) {\n    // Account connection string\n    let defaultEndpointsProtocol = \"\";\n    let accountName = \"\";\n    let accountKey = Buffer.from(\"accountKey\", \"base64\");\n    let endpointSuffix = \"\";\n    // Get account name and key\n    accountName = getValueInConnString(connectionString, \"AccountName\");\n    accountKey = Buffer.from(getValueInConnString(connectionString, \"AccountKey\"), \"base64\");\n    if (!blobEndpoint) {\n      // BlobEndpoint is not present in the Account connection string\n      // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`\n      defaultEndpointsProtocol = getValueInConnString(connectionString, \"DefaultEndpointsProtocol\");\n      const protocol = defaultEndpointsProtocol.toLowerCase();\n      if (protocol !== \"https\" && protocol !== \"http\") {\n        throw new Error(\"Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'\");\n      }\n      endpointSuffix = getValueInConnString(connectionString, \"EndpointSuffix\");\n      if (!endpointSuffix) {\n        throw new Error(\"Invalid EndpointSuffix in the provided Connection String\");\n      }\n      blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n    }\n    if (!accountName) {\n      throw new Error(\"Invalid AccountName in the provided Connection String\");\n    } else if (accountKey.length === 0) {\n      throw new Error(\"Invalid AccountKey in the provided Connection String\");\n    }\n    return {\n      kind: \"AccountConnString\",\n      url: blobEndpoint,\n      accountName,\n      accountKey,\n      proxyUri\n    };\n  } else {\n    // SAS connection string\n    let accountSas = getValueInConnString(connectionString, \"SharedAccessSignature\");\n    let accountName = getValueInConnString(connectionString, \"AccountName\");\n    // if accountName is empty, try to read it from BlobEndpoint\n    if (!accountName) {\n      accountName = getAccountNameFromUrl(blobEndpoint);\n    }\n    if (!blobEndpoint) {\n      throw new Error(\"Invalid BlobEndpoint in the provided SAS Connection String\");\n    } else if (!accountSas) {\n      throw new Error(\"Invalid SharedAccessSignature in the provided SAS Connection String\");\n    }\n    // client constructors assume accountSas does *not* start with ?\n    if (accountSas.startsWith(\"?\")) {\n      accountSas = accountSas.substring(1);\n    }\n    return {\n      kind: \"SASConnString\",\n      url: blobEndpoint,\n      accountName,\n      accountSas\n    };\n  }\n}\n/**\n * Internal escape method implemented Strategy Two mentioned in escapeURL() description.\n *\n * @param text -\n */\nfunction escape(text) {\n  return encodeURIComponent(text).replace(/%2F/g, \"/\") // Don't escape for \"/\"\n  .replace(/'/g, \"%27\") // Escape for \"'\"\n  .replace(/\\+/g, \"%20\").replace(/%25/g, \"%\"); // Revert encoded \"%\"\n}\n/**\n * Append a string to URL path. Will remove duplicated \"/\" in front of the string\n * when URL path ends with a \"/\".\n *\n * @param url - Source URL string\n * @param name - String to be appended to URL\n * @returns An updated URL string\n */\nexport function appendToURLPath(url, name) {\n  const urlParsed = new URL(url);\n  let path = urlParsed.pathname;\n  path = path ? path.endsWith(\"/\") ? `${path}${name}` : `${path}/${name}` : name;\n  urlParsed.pathname = path;\n  return urlParsed.toString();\n}\n/**\n * Set URL parameter name and value. If name exists in URL parameters, old value\n * will be replaced by name key. If not provide value, the parameter will be deleted.\n *\n * @param url - Source URL string\n * @param name - Parameter name\n * @param value - Parameter value\n * @returns An updated URL string\n */\nexport function setURLParameter(url, name, value) {\n  const urlParsed = new URL(url);\n  const encodedName = encodeURIComponent(name);\n  const encodedValue = value ? encodeURIComponent(value) : undefined;\n  // mutating searchParams will change the encoding, so we have to do this ourselves\n  const searchString = urlParsed.search === \"\" ? \"?\" : urlParsed.search;\n  const searchPieces = [];\n  for (const pair of searchString.slice(1).split(\"&\")) {\n    if (pair) {\n      const [key] = pair.split(\"=\", 2);\n      if (key !== encodedName) {\n        searchPieces.push(pair);\n      }\n    }\n  }\n  if (encodedValue) {\n    searchPieces.push(`${encodedName}=${encodedValue}`);\n  }\n  urlParsed.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n  return urlParsed.toString();\n}\n/**\n * Get URL parameter by name.\n *\n * @param url -\n * @param name -\n */\nexport function getURLParameter(url, name) {\n  const urlParsed = new URL(url);\n  return urlParsed.searchParams.get(name) ?? undefined;\n}\n/**\n * Set URL host.\n *\n * @param url - Source URL string\n * @param host - New host string\n * @returns An updated URL string\n */\nexport function setURLHost(url, host) {\n  const urlParsed = new URL(url);\n  urlParsed.hostname = host;\n  return urlParsed.toString();\n}\n/**\n * Get URL path from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLPath(url) {\n  try {\n    const urlParsed = new URL(url);\n    return urlParsed.pathname;\n  } catch (e) {\n    return undefined;\n  }\n}\n/**\n * Get URL scheme from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLScheme(url) {\n  try {\n    const urlParsed = new URL(url);\n    return urlParsed.protocol.endsWith(\":\") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;\n  } catch (e) {\n    return undefined;\n  }\n}\n/**\n * Get URL path and query from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLPathAndQuery(url) {\n  const urlParsed = new URL(url);\n  const pathString = urlParsed.pathname;\n  if (!pathString) {\n    throw new RangeError(\"Invalid url without valid path.\");\n  }\n  let queryString = urlParsed.search || \"\";\n  queryString = queryString.trim();\n  if (queryString !== \"\") {\n    queryString = queryString.startsWith(\"?\") ? queryString : `?${queryString}`; // Ensure query string start with '?'\n  }\n  return `${pathString}${queryString}`;\n}\n/**\n * Get URL query key value pairs from an URL string.\n *\n * @param url -\n */\nexport function getURLQueries(url) {\n  let queryString = new URL(url).search;\n  if (!queryString) {\n    return {};\n  }\n  queryString = queryString.trim();\n  queryString = queryString.startsWith(\"?\") ? queryString.substring(1) : queryString;\n  let querySubStrings = queryString.split(\"&\");\n  querySubStrings = querySubStrings.filter(value => {\n    const indexOfEqual = value.indexOf(\"=\");\n    const lastIndexOfEqual = value.lastIndexOf(\"=\");\n    return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;\n  });\n  const queries = {};\n  for (const querySubString of querySubStrings) {\n    const splitResults = querySubString.split(\"=\");\n    const key = splitResults[0];\n    const value = splitResults[1];\n    queries[key] = value;\n  }\n  return queries;\n}\n/**\n * Append a string to URL query.\n *\n * @param url - Source URL string.\n * @param queryParts - String to be appended to the URL query.\n * @returns An updated URL string.\n */\nexport function appendToURLQuery(url, queryParts) {\n  const urlParsed = new URL(url);\n  let query = urlParsed.search;\n  if (query) {\n    query += \"&\" + queryParts;\n  } else {\n    query = queryParts;\n  }\n  urlParsed.search = query;\n  return urlParsed.toString();\n}\n/**\n * Rounds a date off to seconds.\n *\n * @param date -\n * @param withMilliseconds - If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;\n *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.\n * @returns Date string in ISO8061 format, with or without 7 milliseconds component\n */\nexport function truncatedISO8061Date(date, withMilliseconds = true) {\n  // Date.toISOString() will return like \"2018-10-29T06:34:36.139Z\"\n  const dateString = date.toISOString();\n  return withMilliseconds ? dateString.substring(0, dateString.length - 1) + \"0000\" + \"Z\" : dateString.substring(0, dateString.length - 5) + \"Z\";\n}\n/**\n * Base64 encode.\n *\n * @param content -\n */\nexport function base64encode(content) {\n  return !isNodeLike ? btoa(content) : Buffer.from(content).toString(\"base64\");\n}\n/**\n * Base64 decode.\n *\n * @param encodedString -\n */\nexport function base64decode(encodedString) {\n  return !isNodeLike ? atob(encodedString) : Buffer.from(encodedString, \"base64\").toString();\n}\n/**\n * Generate a 64 bytes base64 block ID string.\n *\n * @param blockIndex -\n */\nexport function generateBlockID(blockIDPrefix, blockIndex) {\n  // To generate a 64 bytes base64 string, source string should be 48\n  const maxSourceStringLength = 48;\n  // A blob can have a maximum of 100,000 uncommitted blocks at any given time\n  const maxBlockIndexLength = 6;\n  const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;\n  if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {\n    blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);\n  }\n  const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, \"0\");\n  return base64encode(res);\n}\n/**\n * Delay specified time interval.\n *\n * @param timeInMs -\n * @param aborter -\n * @param abortError -\n */\nexport async function delay(timeInMs, aborter, abortError) {\n  return new Promise((resolve, reject) => {\n    /* eslint-disable-next-line prefer-const */\n    let timeout;\n    const abortHandler = () => {\n      if (timeout !== undefined) {\n        clearTimeout(timeout);\n      }\n      reject(abortError);\n    };\n    const resolveHandler = () => {\n      if (aborter !== undefined) {\n        aborter.removeEventListener(\"abort\", abortHandler);\n      }\n      resolve();\n    };\n    timeout = setTimeout(resolveHandler, timeInMs);\n    if (aborter !== undefined) {\n      aborter.addEventListener(\"abort\", abortHandler);\n    }\n  });\n}\n/**\n * String.prototype.padStart()\n *\n * @param currentString -\n * @param targetLength -\n * @param padString -\n */\nexport function padStart(currentString, targetLength, padString = \" \") {\n  // @ts-expect-error: TS doesn't know this code needs to run downlevel sometimes\n  if (String.prototype.padStart) {\n    return currentString.padStart(targetLength, padString);\n  }\n  padString = padString || \" \";\n  if (currentString.length > targetLength) {\n    return currentString;\n  } else {\n    targetLength = targetLength - currentString.length;\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n    return padString.slice(0, targetLength) + currentString;\n  }\n}\nexport function sanitizeURL(url) {\n  let safeURL = url;\n  if (getURLParameter(safeURL, URLConstants.Parameters.SIGNATURE)) {\n    safeURL = setURLParameter(safeURL, URLConstants.Parameters.SIGNATURE, \"*****\");\n  }\n  return safeURL;\n}\nexport function sanitizeHeaders(originalHeader) {\n  const headers = createHttpHeaders();\n  for (const [name, value] of originalHeader) {\n    if (name.toLowerCase() === HeaderConstants.AUTHORIZATION.toLowerCase()) {\n      headers.set(name, \"*****\");\n    } else if (name.toLowerCase() === HeaderConstants.X_MS_COPY_SOURCE) {\n      headers.set(name, sanitizeURL(value));\n    } else {\n      headers.set(name, value);\n    }\n  }\n  return headers;\n}\n/**\n * If two strings are equal when compared case insensitive.\n *\n * @param str1 -\n * @param str2 -\n */\nexport function iEqual(str1, str2) {\n  return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();\n}\n/**\n * Extracts account name from the url\n * @param url - url to extract the account name from\n * @returns with the account name\n */\nexport function getAccountNameFromUrl(url) {\n  const parsedUrl = new URL(url);\n  let accountName;\n  try {\n    if (parsedUrl.hostname.split(\".\")[1] === \"blob\") {\n      // `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n      accountName = parsedUrl.hostname.split(\".\")[0];\n    } else if (isIpEndpointStyle(parsedUrl)) {\n      // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/\n      // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/\n      // .getPath() -> /devstoreaccount1/\n      accountName = parsedUrl.pathname.split(\"/\")[1];\n    } else {\n      // Custom domain case: \"https://customdomain.com/containername/blob\".\n      accountName = \"\";\n    }\n    return accountName;\n  } catch (error) {\n    throw new Error(\"Unable to extract accountName with provided information.\");\n  }\n}\nexport function isIpEndpointStyle(parsedUrl) {\n  const host = parsedUrl.host;\n  // Case 1: Ipv6, use a broad regex to find out candidates whose host contains two ':'.\n  // Case 2: localhost(:port) or host.docker.internal, use broad regex to match port part.\n  // Case 3: Ipv4, use broad regex which just check if host contains Ipv4.\n  // For valid host please refer to https://man7.org/linux/man-pages/man7/hostname.7.html.\n  return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && PathStylePorts.includes(parsedUrl.port);\n}\n/**\n * Convert Tags to encoded string.\n *\n * @param tags -\n */\nexport function toBlobTagsString(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n  const tagPairs = [];\n  for (const key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      const value = tags[key];\n      tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);\n    }\n  }\n  return tagPairs.join(\"&\");\n}\n/**\n * Convert Tags type to BlobTags.\n *\n * @param tags -\n */\nexport function toBlobTags(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n  const res = {\n    blobTagSet: []\n  };\n  for (const key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      const value = tags[key];\n      res.blobTagSet.push({\n        key,\n        value\n      });\n    }\n  }\n  return res;\n}\n/**\n * Covert BlobTags to Tags type.\n *\n * @param tags -\n */\nexport function toTags(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n  const res = {};\n  for (const blobTag of tags.blobTagSet) {\n    res[blobTag.key] = blobTag.value;\n  }\n  return res;\n}\n/**\n * Convert BlobQueryTextConfiguration to QuerySerialization type.\n *\n * @param textConfiguration -\n */\nexport function toQuerySerialization(textConfiguration) {\n  if (textConfiguration === undefined) {\n    return undefined;\n  }\n  switch (textConfiguration.kind) {\n    case \"csv\":\n      return {\n        format: {\n          type: \"delimited\",\n          delimitedTextConfiguration: {\n            columnSeparator: textConfiguration.columnSeparator || \",\",\n            fieldQuote: textConfiguration.fieldQuote || \"\",\n            recordSeparator: textConfiguration.recordSeparator,\n            escapeChar: textConfiguration.escapeCharacter || \"\",\n            headersPresent: textConfiguration.hasHeaders || false\n          }\n        }\n      };\n    case \"json\":\n      return {\n        format: {\n          type: \"json\",\n          jsonTextConfiguration: {\n            recordSeparator: textConfiguration.recordSeparator\n          }\n        }\n      };\n    case \"arrow\":\n      return {\n        format: {\n          type: \"arrow\",\n          arrowConfiguration: {\n            schema: textConfiguration.schema\n          }\n        }\n      };\n    case \"parquet\":\n      return {\n        format: {\n          type: \"parquet\"\n        }\n      };\n    default:\n      throw Error(\"Invalid BlobQueryTextConfiguration.\");\n  }\n}\nexport function parseObjectReplicationRecord(objectReplicationRecord) {\n  if (!objectReplicationRecord) {\n    return undefined;\n  }\n  if (\"policy-id\" in objectReplicationRecord) {\n    // If the dictionary contains a key with policy id, we are not required to do any parsing since\n    // the policy id should already be stored in the ObjectReplicationDestinationPolicyId.\n    return undefined;\n  }\n  const orProperties = [];\n  for (const key in objectReplicationRecord) {\n    const ids = key.split(\"_\");\n    const policyPrefix = \"or-\";\n    if (ids[0].startsWith(policyPrefix)) {\n      ids[0] = ids[0].substring(policyPrefix.length);\n    }\n    const rule = {\n      ruleId: ids[1],\n      replicationStatus: objectReplicationRecord[key]\n    };\n    const policyIndex = orProperties.findIndex(policy => policy.policyId === ids[0]);\n    if (policyIndex > -1) {\n      orProperties[policyIndex].rules.push(rule);\n    } else {\n      orProperties.push({\n        policyId: ids[0],\n        rules: [rule]\n      });\n    }\n  }\n  return orProperties;\n}\n/**\n * Attach a TokenCredential to an object.\n *\n * @param thing -\n * @param credential -\n */\nexport function attachCredential(thing, credential) {\n  thing.credential = credential;\n  return thing;\n}\nexport function httpAuthorizationToString(httpAuthorization) {\n  return httpAuthorization ? httpAuthorization.scheme + \" \" + httpAuthorization.value : undefined;\n}\nexport function BlobNameToString(name) {\n  if (name.encoded) {\n    return decodeURIComponent(name.content);\n  } else {\n    return name.content;\n  }\n}\nexport function ConvertInternalResponseOfListBlobFlat(internalResponse) {\n  return {\n    ...internalResponse,\n    segment: {\n      blobItems: internalResponse.segment.blobItems.map(blobItemInteral => {\n        const blobItem = {\n          ...blobItemInteral,\n          name: BlobNameToString(blobItemInteral.name)\n        };\n        return blobItem;\n      })\n    }\n  };\n}\nexport function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {\n  return {\n    ...internalResponse,\n    segment: {\n      blobPrefixes: internalResponse.segment.blobPrefixes?.map(blobPrefixInternal => {\n        const blobPrefix = {\n          ...blobPrefixInternal,\n          name: BlobNameToString(blobPrefixInternal.name)\n        };\n        return blobPrefix;\n      }),\n      blobItems: internalResponse.segment.blobItems.map(blobItemInteral => {\n        const blobItem = {\n          ...blobItemInteral,\n          name: BlobNameToString(blobItemInteral.name)\n        };\n        return blobItem;\n      })\n    }\n  };\n}\nexport function* ExtractPageRangeInfoItems(getPageRangesSegment) {\n  let pageRange = [];\n  let clearRange = [];\n  if (getPageRangesSegment.pageRange) pageRange = getPageRangesSegment.pageRange;\n  if (getPageRangesSegment.clearRange) clearRange = getPageRangesSegment.clearRange;\n  let pageRangeIndex = 0;\n  let clearRangeIndex = 0;\n  while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length) {\n    if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {\n      yield {\n        start: pageRange[pageRangeIndex].start,\n        end: pageRange[pageRangeIndex].end,\n        isClear: false\n      };\n      ++pageRangeIndex;\n    } else {\n      yield {\n        start: clearRange[clearRangeIndex].start,\n        end: clearRange[clearRangeIndex].end,\n        isClear: true\n      };\n      ++clearRangeIndex;\n    }\n  }\n  for (; pageRangeIndex < pageRange.length; ++pageRangeIndex) {\n    yield {\n      start: pageRange[pageRangeIndex].start,\n      end: pageRange[pageRangeIndex].end,\n      isClear: false\n    };\n  }\n  for (; clearRangeIndex < clearRange.length; ++clearRangeIndex) {\n    yield {\n      start: clearRange[clearRangeIndex].start,\n      end: clearRange[clearRangeIndex].end,\n      isClear: true\n    };\n  }\n}\n/**\n * Escape the blobName but keep path separator ('/').\n */\nexport function EscapePath(blobName) {\n  const split = blobName.split(\"/\");\n  for (let i = 0; i < split.length; i++) {\n    split[i] = encodeURIComponent(split[i]);\n  }\n  return split.join(\"/\");\n}\n/**\n * A typesafe helper for ensuring that a given response object has\n * the original _response attached.\n * @param response - A response object from calling a client operation\n * @returns The same object, but with known _response property\n */\nexport function assertResponse(response) {\n  if (`_response` in response) {\n    return response;\n  }\n  throw new TypeError(`Unexpected response object ${response}`);\n}","map":{"version":3,"names":["createHttpHeaders","isNodeLike","DevelopmentConnectionString","HeaderConstants","PathStylePorts","URLConstants","escapeURLPath","url","urlParsed","URL","path","pathname","escape","toString","getProxyUriFromDevConnString","connectionString","proxyUri","search","matchCredentials","split","element","trim","startsWith","match","getValueInConnString","argument","elements","extractConnectionStringParts","blobEndpoint","endsWith","slice","defaultEndpointsProtocol","accountName","accountKey","Buffer","from","endpointSuffix","protocol","toLowerCase","Error","length","kind","accountSas","getAccountNameFromUrl","substring","text","encodeURIComponent","replace","appendToURLPath","name","setURLParameter","value","encodedName","encodedValue","undefined","searchString","searchPieces","pair","key","push","join","getURLParameter","searchParams","get","setURLHost","host","hostname","getURLPath","e","getURLScheme","getURLPathAndQuery","pathString","RangeError","queryString","getURLQueries","querySubStrings","filter","indexOfEqual","indexOf","lastIndexOfEqual","lastIndexOf","queries","querySubString","splitResults","appendToURLQuery","queryParts","query","truncatedISO8061Date","date","withMilliseconds","dateString","toISOString","base64encode","content","btoa","base64decode","encodedString","atob","generateBlockID","blockIDPrefix","blockIndex","maxSourceStringLength","maxBlockIndexLength","maxAllowedBlockIDPrefixLength","res","padStart","delay","timeInMs","aborter","abortError","Promise","resolve","reject","timeout","abortHandler","clearTimeout","resolveHandler","removeEventListener","setTimeout","addEventListener","currentString","targetLength","padString","String","prototype","repeat","sanitizeURL","safeURL","Parameters","SIGNATURE","sanitizeHeaders","originalHeader","headers","AUTHORIZATION","set","X_MS_COPY_SOURCE","iEqual","str1","str2","toLocaleLowerCase","parsedUrl","isIpEndpointStyle","error","test","Boolean","port","includes","toBlobTagsString","tags","tagPairs","Object","hasOwnProperty","call","toBlobTags","blobTagSet","toTags","blobTag","toQuerySerialization","textConfiguration","format","type","delimitedTextConfiguration","columnSeparator","fieldQuote","recordSeparator","escapeChar","escapeCharacter","headersPresent","hasHeaders","jsonTextConfiguration","arrowConfiguration","schema","parseObjectReplicationRecord","objectReplicationRecord","orProperties","ids","policyPrefix","rule","ruleId","replicationStatus","policyIndex","findIndex","policy","policyId","rules","attachCredential","thing","credential","httpAuthorizationToString","httpAuthorization","scheme","BlobNameToString","encoded","decodeURIComponent","ConvertInternalResponseOfListBlobFlat","internalResponse","segment","blobItems","map","blobItemInteral","blobItem","ConvertInternalResponseOfListBlobHierarchy","blobPrefixes","blobPrefixInternal","blobPrefix","ExtractPageRangeInfoItems","getPageRangesSegment","pageRange","clearRange","pageRangeIndex","clearRangeIndex","start","end","isClear","EscapePath","blobName","i","assertResponse","response","TypeError"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@azure\\storage-blob\\src\\utils\\utils.common.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport type { TokenCredential } from \"@azure/core-auth\";\nimport type { HttpHeaders } from \"@azure/core-rest-pipeline\";\nimport { createHttpHeaders } from \"@azure/core-rest-pipeline\";\nimport { isNodeLike } from \"@azure/core-util\";\n\nimport type {\n  BlobQueryArrowConfiguration,\n  BlobQueryCsvTextConfiguration,\n  BlobQueryJsonTextConfiguration,\n  BlobQueryParquetConfiguration,\n} from \"../Clients.js\";\nimport type {\n  QuerySerialization,\n  BlobTags,\n  BlobName,\n  ListBlobsFlatSegmentResponse,\n  ListBlobsHierarchySegmentResponse,\n  PageRange,\n  ClearRange,\n} from \"../generated/src/models/index.js\";\nimport {\n  DevelopmentConnectionString,\n  HeaderConstants,\n  PathStylePorts,\n  URLConstants,\n} from \"./constants.js\";\nimport type {\n  Tags,\n  ObjectReplicationPolicy,\n  ObjectReplicationRule,\n  ObjectReplicationStatus,\n  HttpAuthorization,\n} from \"../models.js\";\nimport type {\n  ListBlobsFlatSegmentResponseModel,\n  BlobItemInternal as BlobItemInternalModel,\n  ListBlobsHierarchySegmentResponseModel,\n  BlobPrefix as BlobPrefixModel,\n  PageBlobGetPageRangesDiffResponseModel,\n  PageRangeInfo,\n} from \"../generatedModels.js\";\nimport type { HttpHeadersLike, WebResourceLike } from \"@azure/core-http-compat\";\n\n/**\n * Reserved URL characters must be properly escaped for Storage services like Blob or File.\n *\n * ## URL encode and escape strategy for JS SDKs\n *\n * When customers pass a URL string into XxxClient classes constructor, the URL string may already be URL encoded or not.\n * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL\n * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XxxClient constructors.\n *\n * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.\n *\n * This is what legacy V2 SDK does, simple and works for most of the cases.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%253A\" and send to server. A blob named \"b%3A\" will be created.\n *\n * But this strategy will make it not possible to create a blob with \"?\" in it's name. Because when customer URL string is\n * \"http://account.blob.core.windows.net/con/blob?name\", the \"?name\" will be treated as URL paramter instead of blob name.\n * If customer URL string is \"http://account.blob.core.windows.net/con/blob%3Fname\", a blob named \"blob%3Fname\" will be created.\n * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.\n * We cannot accept a SDK cannot create a blob name with \"?\". So we implement strategy two:\n *\n * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.\n *\n * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will escape \":\" like \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%3A\" to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%253A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%253A\" to server. A blob named \"b%3A\" will be created.\n *\n * This strategy gives us flexibility to create with any special characters. But \"%\" will be treated as a special characters, if the URL string\n * is not encoded, there shouldn't a \"%\" in the URL string, otherwise the URL is not a valid URL.\n * If customer needs to create a blob with \"%\" in it's blob name, use \"%25\" instead of \"%\". Just like above 3rd sample.\n * And following URL strings are invalid:\n * - \"http://account.blob.core.windows.net/con/b%\"\n * - \"http://account.blob.core.windows.net/con/b%2\"\n * - \"http://account.blob.core.windows.net/con/b%G\"\n *\n * Another special character is \"?\", use \"%2F\" to represent a blob name with \"?\" in a URL string.\n *\n * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `containerClient.getBlobClient(blobName)`\n *\n * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.\n *\n * @see https://learn.microsoft.com/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata\n * @see https://learn.microsoft.com/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata\n *\n * @param url -\n */\nexport function escapeURLPath(url: string): string {\n  const urlParsed = new URL(url);\n\n  let path = urlParsed.pathname;\n  path = path || \"/\";\n\n  path = escape(path);\n  urlParsed.pathname = path;\n\n  return urlParsed.toString();\n}\n\nexport interface ConnectionString {\n  kind: \"AccountConnString\" | \"SASConnString\";\n  url: string;\n  accountName: string;\n  accountKey?: any;\n  accountSas?: string;\n  proxyUri?: string; // Development Connection String may contain proxyUri\n}\n\nfunction getProxyUriFromDevConnString(connectionString: string): string {\n  // Development Connection String\n  // https://learn.microsoft.com/azure/storage/common/storage-configure-connection-string#connect-to-the-emulator-account-using-the-well-known-account-name-and-key\n  let proxyUri = \"\";\n  if (connectionString.search(\"DevelopmentStorageProxyUri=\") !== -1) {\n    // CONNECTION_STRING=UseDevelopmentStorage=true;DevelopmentStorageProxyUri=http://myProxyUri\n    const matchCredentials = connectionString.split(\";\");\n    for (const element of matchCredentials) {\n      if (element.trim().startsWith(\"DevelopmentStorageProxyUri=\")) {\n        proxyUri = element.trim().match(\"DevelopmentStorageProxyUri=(.*)\")![1];\n      }\n    }\n  }\n  return proxyUri;\n}\n\nexport function getValueInConnString(\n  connectionString: string,\n  argument:\n    | \"BlobEndpoint\"\n    | \"AccountName\"\n    | \"AccountKey\"\n    | \"DefaultEndpointsProtocol\"\n    | \"EndpointSuffix\"\n    | \"SharedAccessSignature\",\n): string {\n  const elements = connectionString.split(\";\");\n  for (const element of elements) {\n    if (element.trim().startsWith(argument)) {\n      return element.trim().match(argument + \"=(.*)\")![1];\n    }\n  }\n  return \"\";\n}\n\n/**\n * Extracts the parts of an Azure Storage account connection string.\n *\n * @param connectionString - Connection string.\n * @returns String key value pairs of the storage account's url and credentials.\n */\nexport function extractConnectionStringParts(connectionString: string): ConnectionString {\n  let proxyUri = \"\";\n\n  if (connectionString.startsWith(\"UseDevelopmentStorage=true\")) {\n    // Development connection string\n    proxyUri = getProxyUriFromDevConnString(connectionString);\n    connectionString = DevelopmentConnectionString;\n  }\n\n  // Matching BlobEndpoint in the Account connection string\n  let blobEndpoint = getValueInConnString(connectionString, \"BlobEndpoint\");\n  // Slicing off '/' at the end if exists\n  // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)\n  blobEndpoint = blobEndpoint.endsWith(\"/\") ? blobEndpoint.slice(0, -1) : blobEndpoint;\n\n  if (\n    connectionString.search(\"DefaultEndpointsProtocol=\") !== -1 &&\n    connectionString.search(\"AccountKey=\") !== -1\n  ) {\n    // Account connection string\n\n    let defaultEndpointsProtocol = \"\";\n    let accountName = \"\";\n    let accountKey = Buffer.from(\"accountKey\", \"base64\");\n    let endpointSuffix = \"\";\n\n    // Get account name and key\n    accountName = getValueInConnString(connectionString, \"AccountName\");\n    accountKey = Buffer.from(getValueInConnString(connectionString, \"AccountKey\"), \"base64\");\n\n    if (!blobEndpoint) {\n      // BlobEndpoint is not present in the Account connection string\n      // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`\n\n      defaultEndpointsProtocol = getValueInConnString(connectionString, \"DefaultEndpointsProtocol\");\n      const protocol = defaultEndpointsProtocol!.toLowerCase();\n      if (protocol !== \"https\" && protocol !== \"http\") {\n        throw new Error(\n          \"Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'\",\n        );\n      }\n\n      endpointSuffix = getValueInConnString(connectionString, \"EndpointSuffix\");\n      if (!endpointSuffix) {\n        throw new Error(\"Invalid EndpointSuffix in the provided Connection String\");\n      }\n      blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n    }\n\n    if (!accountName) {\n      throw new Error(\"Invalid AccountName in the provided Connection String\");\n    } else if (accountKey.length === 0) {\n      throw new Error(\"Invalid AccountKey in the provided Connection String\");\n    }\n\n    return {\n      kind: \"AccountConnString\",\n      url: blobEndpoint,\n      accountName,\n      accountKey,\n      proxyUri,\n    };\n  } else {\n    // SAS connection string\n\n    let accountSas = getValueInConnString(connectionString, \"SharedAccessSignature\");\n    let accountName = getValueInConnString(connectionString, \"AccountName\");\n    // if accountName is empty, try to read it from BlobEndpoint\n    if (!accountName) {\n      accountName = getAccountNameFromUrl(blobEndpoint);\n    }\n    if (!blobEndpoint) {\n      throw new Error(\"Invalid BlobEndpoint in the provided SAS Connection String\");\n    } else if (!accountSas) {\n      throw new Error(\"Invalid SharedAccessSignature in the provided SAS Connection String\");\n    }\n\n    // client constructors assume accountSas does *not* start with ?\n    if (accountSas.startsWith(\"?\")) {\n      accountSas = accountSas.substring(1);\n    }\n\n    return { kind: \"SASConnString\", url: blobEndpoint, accountName, accountSas };\n  }\n}\n\n/**\n * Internal escape method implemented Strategy Two mentioned in escapeURL() description.\n *\n * @param text -\n */\nfunction escape(text: string): string {\n  return encodeURIComponent(text)\n    .replace(/%2F/g, \"/\") // Don't escape for \"/\"\n    .replace(/'/g, \"%27\") // Escape for \"'\"\n    .replace(/\\+/g, \"%20\")\n    .replace(/%25/g, \"%\"); // Revert encoded \"%\"\n}\n\n/**\n * Append a string to URL path. Will remove duplicated \"/\" in front of the string\n * when URL path ends with a \"/\".\n *\n * @param url - Source URL string\n * @param name - String to be appended to URL\n * @returns An updated URL string\n */\nexport function appendToURLPath(url: string, name: string): string {\n  const urlParsed = new URL(url);\n\n  let path = urlParsed.pathname;\n  path = path ? (path.endsWith(\"/\") ? `${path}${name}` : `${path}/${name}`) : name;\n  urlParsed.pathname = path;\n\n  return urlParsed.toString();\n}\n\n/**\n * Set URL parameter name and value. If name exists in URL parameters, old value\n * will be replaced by name key. If not provide value, the parameter will be deleted.\n *\n * @param url - Source URL string\n * @param name - Parameter name\n * @param value - Parameter value\n * @returns An updated URL string\n */\nexport function setURLParameter(url: string, name: string, value?: string): string {\n  const urlParsed = new URL(url);\n  const encodedName = encodeURIComponent(name);\n  const encodedValue = value ? encodeURIComponent(value) : undefined;\n  // mutating searchParams will change the encoding, so we have to do this ourselves\n  const searchString = urlParsed.search === \"\" ? \"?\" : urlParsed.search;\n\n  const searchPieces: string[] = [];\n\n  for (const pair of searchString.slice(1).split(\"&\")) {\n    if (pair) {\n      const [key] = pair.split(\"=\", 2);\n      if (key !== encodedName) {\n        searchPieces.push(pair);\n      }\n    }\n  }\n  if (encodedValue) {\n    searchPieces.push(`${encodedName}=${encodedValue}`);\n  }\n\n  urlParsed.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n\n  return urlParsed.toString();\n}\n\n/**\n * Get URL parameter by name.\n *\n * @param url -\n * @param name -\n */\nexport function getURLParameter(url: string, name: string): string | string[] | undefined {\n  const urlParsed = new URL(url);\n  return urlParsed.searchParams.get(name) ?? undefined;\n}\n\n/**\n * Set URL host.\n *\n * @param url - Source URL string\n * @param host - New host string\n * @returns An updated URL string\n */\nexport function setURLHost(url: string, host: string): string {\n  const urlParsed = new URL(url);\n  urlParsed.hostname = host;\n  return urlParsed.toString();\n}\n\n/**\n * Get URL path from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLPath(url: string): string | undefined {\n  try {\n    const urlParsed = new URL(url);\n    return urlParsed.pathname;\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * Get URL scheme from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLScheme(url: string): string | undefined {\n  try {\n    const urlParsed = new URL(url);\n    return urlParsed.protocol.endsWith(\":\") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * Get URL path and query from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLPathAndQuery(url: string): string | undefined {\n  const urlParsed = new URL(url);\n  const pathString = urlParsed.pathname;\n  if (!pathString) {\n    throw new RangeError(\"Invalid url without valid path.\");\n  }\n\n  let queryString = urlParsed.search || \"\";\n  queryString = queryString.trim();\n  if (queryString !== \"\") {\n    queryString = queryString.startsWith(\"?\") ? queryString : `?${queryString}`; // Ensure query string start with '?'\n  }\n\n  return `${pathString}${queryString}`;\n}\n\n/**\n * Get URL query key value pairs from an URL string.\n *\n * @param url -\n */\nexport function getURLQueries(url: string): { [key: string]: string } {\n  let queryString = new URL(url).search;\n  if (!queryString) {\n    return {};\n  }\n\n  queryString = queryString.trim();\n  queryString = queryString.startsWith(\"?\") ? queryString.substring(1) : queryString;\n\n  let querySubStrings: string[] = queryString.split(\"&\");\n  querySubStrings = querySubStrings.filter((value: string) => {\n    const indexOfEqual = value.indexOf(\"=\");\n    const lastIndexOfEqual = value.lastIndexOf(\"=\");\n    return (\n      indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1\n    );\n  });\n\n  const queries: { [key: string]: string } = {};\n  for (const querySubString of querySubStrings) {\n    const splitResults = querySubString.split(\"=\");\n    const key: string = splitResults[0];\n    const value: string = splitResults[1];\n    queries[key] = value;\n  }\n\n  return queries;\n}\n\n/**\n * Append a string to URL query.\n *\n * @param url - Source URL string.\n * @param queryParts - String to be appended to the URL query.\n * @returns An updated URL string.\n */\nexport function appendToURLQuery(url: string, queryParts: string): string {\n  const urlParsed = new URL(url);\n\n  let query = urlParsed.search;\n  if (query) {\n    query += \"&\" + queryParts;\n  } else {\n    query = queryParts;\n  }\n\n  urlParsed.search = query;\n  return urlParsed.toString();\n}\n\n/**\n * Rounds a date off to seconds.\n *\n * @param date -\n * @param withMilliseconds - If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;\n *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.\n * @returns Date string in ISO8061 format, with or without 7 milliseconds component\n */\nexport function truncatedISO8061Date(date: Date, withMilliseconds: boolean = true): string {\n  // Date.toISOString() will return like \"2018-10-29T06:34:36.139Z\"\n  const dateString = date.toISOString();\n\n  return withMilliseconds\n    ? dateString.substring(0, dateString.length - 1) + \"0000\" + \"Z\"\n    : dateString.substring(0, dateString.length - 5) + \"Z\";\n}\n\n/**\n * Base64 encode.\n *\n * @param content -\n */\nexport function base64encode(content: string): string {\n  return !isNodeLike ? btoa(content) : Buffer.from(content).toString(\"base64\");\n}\n\n/**\n * Base64 decode.\n *\n * @param encodedString -\n */\nexport function base64decode(encodedString: string): string {\n  return !isNodeLike ? atob(encodedString) : Buffer.from(encodedString, \"base64\").toString();\n}\n\n/**\n * Generate a 64 bytes base64 block ID string.\n *\n * @param blockIndex -\n */\nexport function generateBlockID(blockIDPrefix: string, blockIndex: number): string {\n  // To generate a 64 bytes base64 string, source string should be 48\n  const maxSourceStringLength = 48;\n\n  // A blob can have a maximum of 100,000 uncommitted blocks at any given time\n  const maxBlockIndexLength = 6;\n\n  const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;\n\n  if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {\n    blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);\n  }\n  const res =\n    blockIDPrefix +\n    padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, \"0\");\n  return base64encode(res);\n}\n\n/**\n * Delay specified time interval.\n *\n * @param timeInMs -\n * @param aborter -\n * @param abortError -\n */\nexport async function delay(\n  timeInMs: number,\n  aborter?: AbortSignalLike,\n  abortError?: Error,\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    /* eslint-disable-next-line prefer-const */\n    let timeout: any;\n\n    const abortHandler = () => {\n      if (timeout !== undefined) {\n        clearTimeout(timeout);\n      }\n      reject(abortError);\n    };\n\n    const resolveHandler = () => {\n      if (aborter !== undefined) {\n        aborter.removeEventListener(\"abort\", abortHandler);\n      }\n      resolve();\n    };\n\n    timeout = setTimeout(resolveHandler, timeInMs);\n\n    if (aborter !== undefined) {\n      aborter.addEventListener(\"abort\", abortHandler);\n    }\n  });\n}\n\n/**\n * String.prototype.padStart()\n *\n * @param currentString -\n * @param targetLength -\n * @param padString -\n */\nexport function padStart(\n  currentString: string,\n  targetLength: number,\n  padString: string = \" \",\n): string {\n  // @ts-expect-error: TS doesn't know this code needs to run downlevel sometimes\n  if (String.prototype.padStart) {\n    return currentString.padStart(targetLength, padString);\n  }\n\n  padString = padString || \" \";\n  if (currentString.length > targetLength) {\n    return currentString;\n  } else {\n    targetLength = targetLength - currentString.length;\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n    return padString.slice(0, targetLength) + currentString;\n  }\n}\n\nexport function sanitizeURL(url: string): string {\n  let safeURL: string = url;\n  if (getURLParameter(safeURL, URLConstants.Parameters.SIGNATURE)) {\n    safeURL = setURLParameter(safeURL, URLConstants.Parameters.SIGNATURE, \"*****\");\n  }\n\n  return safeURL;\n}\n\nexport function sanitizeHeaders(originalHeader: HttpHeaders): HttpHeaders {\n  const headers: HttpHeaders = createHttpHeaders();\n  for (const [name, value] of originalHeader) {\n    if (name.toLowerCase() === HeaderConstants.AUTHORIZATION.toLowerCase()) {\n      headers.set(name, \"*****\");\n    } else if (name.toLowerCase() === HeaderConstants.X_MS_COPY_SOURCE) {\n      headers.set(name, sanitizeURL(value));\n    } else {\n      headers.set(name, value);\n    }\n  }\n\n  return headers;\n}\n/**\n * If two strings are equal when compared case insensitive.\n *\n * @param str1 -\n * @param str2 -\n */\nexport function iEqual(str1: string, str2: string): boolean {\n  return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();\n}\n\n/**\n * Extracts account name from the url\n * @param url - url to extract the account name from\n * @returns with the account name\n */\nexport function getAccountNameFromUrl(url: string): string {\n  const parsedUrl = new URL(url);\n  let accountName;\n  try {\n    if (parsedUrl.hostname.split(\".\")[1] === \"blob\") {\n      // `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n      accountName = parsedUrl.hostname.split(\".\")[0];\n    } else if (isIpEndpointStyle(parsedUrl)) {\n      // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/\n      // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/\n      // .getPath() -> /devstoreaccount1/\n      accountName = parsedUrl.pathname.split(\"/\")[1];\n    } else {\n      // Custom domain case: \"https://customdomain.com/containername/blob\".\n      accountName = \"\";\n    }\n    return accountName;\n  } catch (error: any) {\n    throw new Error(\"Unable to extract accountName with provided information.\");\n  }\n}\n\nexport function isIpEndpointStyle(parsedUrl: URL): boolean {\n  const host = parsedUrl.host;\n\n  // Case 1: Ipv6, use a broad regex to find out candidates whose host contains two ':'.\n  // Case 2: localhost(:port) or host.docker.internal, use broad regex to match port part.\n  // Case 3: Ipv4, use broad regex which just check if host contains Ipv4.\n  // For valid host please refer to https://man7.org/linux/man-pages/man7/hostname.7.html.\n  return (\n    /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])){3}(:[0-9]+)?$/.test(\n      host,\n    ) ||\n    (Boolean(parsedUrl.port) && PathStylePorts.includes(parsedUrl.port))\n  );\n}\n\n/**\n * Convert Tags to encoded string.\n *\n * @param tags -\n */\nexport function toBlobTagsString(tags?: Tags): string | undefined {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const tagPairs = [];\n  for (const key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      const value = tags[key];\n      tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);\n    }\n  }\n\n  return tagPairs.join(\"&\");\n}\n\n/**\n * Convert Tags type to BlobTags.\n *\n * @param tags -\n */\nexport function toBlobTags(tags?: Tags): BlobTags | undefined {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const res: BlobTags = {\n    blobTagSet: [],\n  };\n\n  for (const key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      const value = tags[key];\n      res.blobTagSet.push({\n        key,\n        value,\n      });\n    }\n  }\n  return res;\n}\n\n/**\n * Covert BlobTags to Tags type.\n *\n * @param tags -\n */\nexport function toTags(tags?: BlobTags): Tags | undefined {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const res: Tags = {};\n  for (const blobTag of tags.blobTagSet) {\n    res[blobTag.key] = blobTag.value;\n  }\n  return res;\n}\n\n/**\n * Convert BlobQueryTextConfiguration to QuerySerialization type.\n *\n * @param textConfiguration -\n */\nexport function toQuerySerialization(\n  textConfiguration?:\n    | BlobQueryJsonTextConfiguration\n    | BlobQueryCsvTextConfiguration\n    | BlobQueryArrowConfiguration\n    | BlobQueryParquetConfiguration,\n): QuerySerialization | undefined {\n  if (textConfiguration === undefined) {\n    return undefined;\n  }\n\n  switch (textConfiguration.kind) {\n    case \"csv\":\n      return {\n        format: {\n          type: \"delimited\",\n          delimitedTextConfiguration: {\n            columnSeparator: textConfiguration.columnSeparator || \",\",\n            fieldQuote: textConfiguration.fieldQuote || \"\",\n            recordSeparator: textConfiguration.recordSeparator,\n            escapeChar: textConfiguration.escapeCharacter || \"\",\n            headersPresent: textConfiguration.hasHeaders || false,\n          },\n        },\n      };\n    case \"json\":\n      return {\n        format: {\n          type: \"json\",\n          jsonTextConfiguration: {\n            recordSeparator: textConfiguration.recordSeparator,\n          },\n        },\n      };\n    case \"arrow\":\n      return {\n        format: {\n          type: \"arrow\",\n          arrowConfiguration: {\n            schema: textConfiguration.schema,\n          },\n        },\n      };\n    case \"parquet\":\n      return {\n        format: {\n          type: \"parquet\",\n        },\n      };\n\n    default:\n      throw Error(\"Invalid BlobQueryTextConfiguration.\");\n  }\n}\n\nexport function parseObjectReplicationRecord(\n  objectReplicationRecord?: Record<string, string>,\n): ObjectReplicationPolicy[] | undefined {\n  if (!objectReplicationRecord) {\n    return undefined;\n  }\n\n  if (\"policy-id\" in objectReplicationRecord) {\n    // If the dictionary contains a key with policy id, we are not required to do any parsing since\n    // the policy id should already be stored in the ObjectReplicationDestinationPolicyId.\n    return undefined;\n  }\n\n  const orProperties: ObjectReplicationPolicy[] = [];\n  for (const key in objectReplicationRecord) {\n    const ids = key.split(\"_\");\n    const policyPrefix = \"or-\";\n    if (ids[0].startsWith(policyPrefix)) {\n      ids[0] = ids[0].substring(policyPrefix.length);\n    }\n    const rule: ObjectReplicationRule = {\n      ruleId: ids[1],\n      replicationStatus: objectReplicationRecord[key] as ObjectReplicationStatus,\n    };\n    const policyIndex = orProperties.findIndex((policy) => policy.policyId === ids[0]);\n    if (policyIndex > -1) {\n      orProperties[policyIndex].rules.push(rule);\n    } else {\n      orProperties.push({\n        policyId: ids[0],\n        rules: [rule],\n      });\n    }\n  }\n  return orProperties;\n}\n\n/**\n * Attach a TokenCredential to an object.\n *\n * @param thing -\n * @param credential -\n */\nexport function attachCredential<T>(thing: T, credential: TokenCredential): T {\n  (thing as any).credential = credential;\n  return thing;\n}\n\nexport function httpAuthorizationToString(\n  httpAuthorization?: HttpAuthorization,\n): string | undefined {\n  return httpAuthorization ? httpAuthorization.scheme + \" \" + httpAuthorization.value : undefined;\n}\n\nexport function BlobNameToString(name: BlobName): string {\n  if (name.encoded) {\n    return decodeURIComponent(name.content!);\n  } else {\n    return name.content!;\n  }\n}\n\nexport function ConvertInternalResponseOfListBlobFlat(\n  internalResponse: ListBlobsFlatSegmentResponse,\n): ListBlobsFlatSegmentResponseModel {\n  return {\n    ...internalResponse,\n    segment: {\n      blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {\n        const blobItem: BlobItemInternalModel = {\n          ...blobItemInteral,\n          name: BlobNameToString(blobItemInteral.name),\n        };\n        return blobItem;\n      }),\n    },\n  };\n}\n\nexport function ConvertInternalResponseOfListBlobHierarchy(\n  internalResponse: ListBlobsHierarchySegmentResponse,\n): ListBlobsHierarchySegmentResponseModel {\n  return {\n    ...internalResponse,\n    segment: {\n      blobPrefixes: internalResponse.segment.blobPrefixes?.map((blobPrefixInternal) => {\n        const blobPrefix: BlobPrefixModel = {\n          ...blobPrefixInternal,\n          name: BlobNameToString(blobPrefixInternal.name),\n        };\n        return blobPrefix;\n      }),\n      blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {\n        const blobItem: BlobItemInternalModel = {\n          ...blobItemInteral,\n          name: BlobNameToString(blobItemInteral.name),\n        };\n        return blobItem;\n      }),\n    },\n  };\n}\n\nexport function* ExtractPageRangeInfoItems(\n  getPageRangesSegment: PageBlobGetPageRangesDiffResponseModel,\n): IterableIterator<PageRangeInfo> {\n  let pageRange: PageRange[] = [];\n  let clearRange: ClearRange[] = [];\n\n  if (getPageRangesSegment.pageRange) pageRange = getPageRangesSegment.pageRange;\n  if (getPageRangesSegment.clearRange) clearRange = getPageRangesSegment.clearRange;\n\n  let pageRangeIndex = 0;\n  let clearRangeIndex = 0;\n\n  while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length) {\n    if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {\n      yield {\n        start: pageRange[pageRangeIndex].start,\n        end: pageRange[pageRangeIndex].end,\n        isClear: false,\n      };\n      ++pageRangeIndex;\n    } else {\n      yield {\n        start: clearRange[clearRangeIndex].start,\n        end: clearRange[clearRangeIndex].end,\n        isClear: true,\n      };\n      ++clearRangeIndex;\n    }\n  }\n\n  for (; pageRangeIndex < pageRange.length; ++pageRangeIndex) {\n    yield {\n      start: pageRange[pageRangeIndex].start,\n      end: pageRange[pageRangeIndex].end,\n      isClear: false,\n    };\n  }\n\n  for (; clearRangeIndex < clearRange.length; ++clearRangeIndex) {\n    yield {\n      start: clearRange[clearRangeIndex].start,\n      end: clearRange[clearRangeIndex].end,\n      isClear: true,\n    };\n  }\n}\n\n/**\n * Escape the blobName but keep path separator ('/').\n */\nexport function EscapePath(blobName: string): string {\n  const split = blobName.split(\"/\");\n  for (let i = 0; i < split.length; i++) {\n    split[i] = encodeURIComponent(split[i]);\n  }\n  return split.join(\"/\");\n}\n\n/**\n * A representation of an HTTP response that\n * includes a reference to the request that\n * originated it.\n */\nexport interface HttpResponse {\n  /**\n   * The headers from the response.\n   */\n  headers: HttpHeadersLike;\n  /**\n   * The original request that resulted in this response.\n   */\n  request: WebResourceLike;\n  /**\n   * The HTTP status code returned from the service.\n   */\n  status: number;\n}\n\n/**\n * An object with a _response property that has\n * headers already parsed into a typed object.\n */\nexport interface ResponseWithHeaders<Headers> {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: HttpResponse & {\n    /**\n     * The parsed HTTP response headers.\n     */\n    parsedHeaders: Headers;\n  };\n}\n\n/**\n * An object with a _response property that has body\n * and headers already parsed into known types.\n */\nexport interface ResponseWithBody<Headers, Body> {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: HttpResponse & {\n    /**\n     * The parsed HTTP response headers.\n     */\n    parsedHeaders: Headers;\n    /**\n     * The response body as text (string format)\n     */\n    bodyAsText: string;\n    /**\n     * The response body as parsed JSON or XML\n     */\n    parsedBody: Body;\n  };\n}\n\n/**\n * An object with a simple _response property.\n */\nexport interface ResponseLike {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: HttpResponse;\n}\n\n/**\n * A type that represents an operation result with a known _response property.\n */\nexport type WithResponse<T, Headers = undefined, Body = undefined> = T &\n  (Body extends object\n    ? ResponseWithBody<Headers, Body>\n    : Headers extends object\n      ? ResponseWithHeaders<Headers>\n      : ResponseLike);\n\n/**\n * A typesafe helper for ensuring that a given response object has\n * the original _response attached.\n * @param response - A response object from calling a client operation\n * @returns The same object, but with known _response property\n */\nexport function assertResponse<T extends object, Headers = undefined, Body = undefined>(\n  response: T,\n): WithResponse<T, Headers, Body> {\n  if (`_response` in response) {\n    return response as WithResponse<T, Headers, Body>;\n  }\n\n  throw new TypeError(`Unexpected response object ${response}`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}