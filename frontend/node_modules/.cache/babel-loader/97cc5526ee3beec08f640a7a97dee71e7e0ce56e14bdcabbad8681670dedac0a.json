{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getInstrumenter } from \"./instrumenter.js\";\nimport { knownContextKeys } from \"./tracingContext.js\";\n/**\n * Creates a new tracing client.\n *\n * @param options - Options used to configure the tracing client.\n * @returns - An instance of {@link TracingClient}.\n */\nexport function createTracingClient(options) {\n  const {\n    namespace,\n    packageName,\n    packageVersion\n  } = options;\n  function startSpan(name, operationOptions, spanOptions) {\n    const startSpanResult = getInstrumenter().startSpan(name, {\n      ...spanOptions,\n      packageName: packageName,\n      packageVersion: packageVersion,\n      tracingContext: operationOptions?.tracingOptions?.tracingContext\n    });\n    let tracingContext = startSpanResult.tracingContext;\n    const span = startSpanResult.span;\n    if (!tracingContext.getValue(knownContextKeys.namespace)) {\n      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);\n    }\n    span.setAttribute(\"az.namespace\", tracingContext.getValue(knownContextKeys.namespace));\n    const updatedOptions = Object.assign({}, operationOptions, {\n      tracingOptions: {\n        ...operationOptions?.tracingOptions,\n        tracingContext\n      }\n    });\n    return {\n      span,\n      updatedOptions\n    };\n  }\n  async function withSpan(name, operationOptions, callback, spanOptions) {\n    const {\n      span,\n      updatedOptions\n    } = startSpan(name, operationOptions, spanOptions);\n    try {\n      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));\n      span.setStatus({\n        status: \"success\"\n      });\n      return result;\n    } catch (err) {\n      span.setStatus({\n        status: \"error\",\n        error: err\n      });\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n  function withContext(context, callback, ...callbackArgs) {\n    return getInstrumenter().withContext(context, callback, ...callbackArgs);\n  }\n  /**\n   * Parses a traceparent header value into a span identifier.\n   *\n   * @param traceparentHeader - The traceparent header to parse.\n   * @returns An implementation-specific identifier for the span.\n   */\n  function parseTraceparentHeader(traceparentHeader) {\n    return getInstrumenter().parseTraceparentHeader(traceparentHeader);\n  }\n  /**\n   * Creates a set of request headers to propagate tracing information to a backend.\n   *\n   * @param tracingContext - The context containing the span to serialize.\n   * @returns The set of headers to add to a request.\n   */\n  function createRequestHeaders(tracingContext) {\n    return getInstrumenter().createRequestHeaders(tracingContext);\n  }\n  return {\n    startSpan,\n    withSpan,\n    withContext,\n    parseTraceparentHeader,\n    createRequestHeaders\n  };\n}","map":{"version":3,"names":["getInstrumenter","knownContextKeys","createTracingClient","options","namespace","packageName","packageVersion","startSpan","name","operationOptions","spanOptions","startSpanResult","tracingContext","tracingOptions","span","getValue","setValue","setAttribute","updatedOptions","Object","assign","withSpan","callback","result","withContext","Promise","resolve","setStatus","status","err","error","end","context","callbackArgs","parseTraceparentHeader","traceparentHeader","createRequestHeaders"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@azure\\core-tracing\\src\\tracingClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  OperationTracingOptions,\n  OptionsWithTracingContext,\n  Resolved,\n  TracingClient,\n  TracingClientOptions,\n  TracingContext,\n  TracingSpan,\n  TracingSpanOptions,\n} from \"./interfaces.js\";\nimport { getInstrumenter } from \"./instrumenter.js\";\nimport { knownContextKeys } from \"./tracingContext.js\";\n\n/**\n * Creates a new tracing client.\n *\n * @param options - Options used to configure the tracing client.\n * @returns - An instance of {@link TracingClient}.\n */\nexport function createTracingClient(options: TracingClientOptions): TracingClient {\n  const { namespace, packageName, packageVersion } = options;\n\n  function startSpan<Options extends { tracingOptions?: OperationTracingOptions }>(\n    name: string,\n    operationOptions?: Options,\n    spanOptions?: TracingSpanOptions,\n  ): {\n    span: TracingSpan;\n    updatedOptions: OptionsWithTracingContext<Options>;\n  } {\n    const startSpanResult = getInstrumenter().startSpan(name, {\n      ...spanOptions,\n      packageName: packageName,\n      packageVersion: packageVersion,\n      tracingContext: operationOptions?.tracingOptions?.tracingContext,\n    });\n    let tracingContext = startSpanResult.tracingContext;\n    const span = startSpanResult.span;\n    if (!tracingContext.getValue(knownContextKeys.namespace)) {\n      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);\n    }\n    span.setAttribute(\"az.namespace\", tracingContext.getValue(knownContextKeys.namespace));\n    const updatedOptions: OptionsWithTracingContext<Options> = Object.assign({}, operationOptions, {\n      tracingOptions: { ...operationOptions?.tracingOptions, tracingContext },\n    });\n\n    return {\n      span,\n      updatedOptions,\n    };\n  }\n\n  async function withSpan<\n    Options extends { tracingOptions?: OperationTracingOptions },\n    Callback extends (\n      updatedOptions: Options,\n      span: Omit<TracingSpan, \"end\">,\n    ) => ReturnType<Callback>,\n  >(\n    name: string,\n    operationOptions: Options,\n    callback: Callback,\n    spanOptions?: TracingSpanOptions,\n  ): Promise<Resolved<ReturnType<Callback>>> {\n    const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);\n    try {\n      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () =>\n        Promise.resolve(callback(updatedOptions, span)),\n      );\n      span.setStatus({ status: \"success\" });\n      return result as ReturnType<typeof withSpan>;\n    } catch (err: any) {\n      span.setStatus({ status: \"error\", error: err });\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n\n  function withContext<\n    CallbackArgs extends unknown[],\n    Callback extends (...args: CallbackArgs) => ReturnType<Callback>,\n  >(\n    context: TracingContext,\n    callback: Callback,\n    ...callbackArgs: CallbackArgs\n  ): ReturnType<Callback> {\n    return getInstrumenter().withContext(context, callback, ...callbackArgs);\n  }\n\n  /**\n   * Parses a traceparent header value into a span identifier.\n   *\n   * @param traceparentHeader - The traceparent header to parse.\n   * @returns An implementation-specific identifier for the span.\n   */\n  function parseTraceparentHeader(traceparentHeader: string): TracingContext | undefined {\n    return getInstrumenter().parseTraceparentHeader(traceparentHeader);\n  }\n\n  /**\n   * Creates a set of request headers to propagate tracing information to a backend.\n   *\n   * @param tracingContext - The context containing the span to serialize.\n   * @returns The set of headers to add to a request.\n   */\n  function createRequestHeaders(tracingContext?: TracingContext): Record<string, string> {\n    return getInstrumenter().createRequestHeaders(tracingContext);\n  }\n\n  return {\n    startSpan,\n    withSpan,\n    withContext,\n    parseTraceparentHeader,\n    createRequestHeaders,\n  };\n}\n"],"mappings":"AAAA;AACA;AAYA,SAASA,eAAe,QAAQ,mBAAmB;AACnD,SAASC,gBAAgB,QAAQ,qBAAqB;AAEtD;;;;;;AAMA,OAAM,SAAUC,mBAAmBA,CAACC,OAA6B;EAC/D,MAAM;IAAEC,SAAS;IAAEC,WAAW;IAAEC;EAAc,CAAE,GAAGH,OAAO;EAE1D,SAASI,SAASA,CAChBC,IAAY,EACZC,gBAA0B,EAC1BC,WAAgC;IAKhC,MAAMC,eAAe,GAAGX,eAAe,EAAE,CAACO,SAAS,CAACC,IAAI,EAAE;MACxD,GAAGE,WAAW;MACdL,WAAW,EAAEA,WAAW;MACxBC,cAAc,EAAEA,cAAc;MAC9BM,cAAc,EAAEH,gBAAgB,EAAEI,cAAc,EAAED;KACnD,CAAC;IACF,IAAIA,cAAc,GAAGD,eAAe,CAACC,cAAc;IACnD,MAAME,IAAI,GAAGH,eAAe,CAACG,IAAI;IACjC,IAAI,CAACF,cAAc,CAACG,QAAQ,CAACd,gBAAgB,CAACG,SAAS,CAAC,EAAE;MACxDQ,cAAc,GAAGA,cAAc,CAACI,QAAQ,CAACf,gBAAgB,CAACG,SAAS,EAAEA,SAAS,CAAC;IACjF;IACAU,IAAI,CAACG,YAAY,CAAC,cAAc,EAAEL,cAAc,CAACG,QAAQ,CAACd,gBAAgB,CAACG,SAAS,CAAC,CAAC;IACtF,MAAMc,cAAc,GAAuCC,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEX,gBAAgB,EAAE;MAC7FI,cAAc,EAAE;QAAE,GAAGJ,gBAAgB,EAAEI,cAAc;QAAED;MAAc;KACtE,CAAC;IAEF,OAAO;MACLE,IAAI;MACJI;KACD;EACH;EAEA,eAAeG,QAAQA,CAOrBb,IAAY,EACZC,gBAAyB,EACzBa,QAAkB,EAClBZ,WAAgC;IAEhC,MAAM;MAAEI,IAAI;MAAEI;IAAc,CAAE,GAAGX,SAAS,CAACC,IAAI,EAAEC,gBAAgB,EAAEC,WAAW,CAAC;IAC/E,IAAI;MACF,MAAMa,MAAM,GAAG,MAAMC,WAAW,CAACN,cAAc,CAACL,cAAc,CAACD,cAAc,EAAE,MAC7Ea,OAAO,CAACC,OAAO,CAACJ,QAAQ,CAACJ,cAAc,EAAEJ,IAAI,CAAC,CAAC,CAChD;MACDA,IAAI,CAACa,SAAS,CAAC;QAAEC,MAAM,EAAE;MAAS,CAAE,CAAC;MACrC,OAAOL,MAAqC;IAC9C,CAAC,CAAC,OAAOM,GAAQ,EAAE;MACjBf,IAAI,CAACa,SAAS,CAAC;QAAEC,MAAM,EAAE,OAAO;QAAEE,KAAK,EAAED;MAAG,CAAE,CAAC;MAC/C,MAAMA,GAAG;IACX,CAAC,SAAS;MACRf,IAAI,CAACiB,GAAG,EAAE;IACZ;EACF;EAEA,SAASP,WAAWA,CAIlBQ,OAAuB,EACvBV,QAAkB,EAClB,GAAGW,YAA0B;IAE7B,OAAOjC,eAAe,EAAE,CAACwB,WAAW,CAACQ,OAAO,EAAEV,QAAQ,EAAE,GAAGW,YAAY,CAAC;EAC1E;EAEA;;;;;;EAMA,SAASC,sBAAsBA,CAACC,iBAAyB;IACvD,OAAOnC,eAAe,EAAE,CAACkC,sBAAsB,CAACC,iBAAiB,CAAC;EACpE;EAEA;;;;;;EAMA,SAASC,oBAAoBA,CAACxB,cAA+B;IAC3D,OAAOZ,eAAe,EAAE,CAACoC,oBAAoB,CAACxB,cAAc,CAAC;EAC/D;EAEA,OAAO;IACLL,SAAS;IACTc,QAAQ;IACRG,WAAW;IACXU,sBAAsB;IACtBE;GACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}