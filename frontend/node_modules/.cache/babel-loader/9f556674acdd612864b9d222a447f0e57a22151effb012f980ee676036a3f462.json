{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { stringToUint8Array } from \"../util/bytesEncoding.js\";\nimport { isBlob } from \"../util/typeGuards.js\";\nimport { randomUUID } from \"../util/uuidUtils.js\";\nimport { concat } from \"../util/concat.js\";\nfunction generateBoundary() {\n  return `----AzSDKFormBoundary${randomUUID()}`;\n}\nfunction encodeHeaders(headers) {\n  let result = \"\";\n  for (const [key, value] of headers) {\n    result += `${key}: ${value}\\r\\n`;\n  }\n  return result;\n}\nfunction getLength(source) {\n  if (source instanceof Uint8Array) {\n    return source.byteLength;\n  } else if (isBlob(source)) {\n    // if was created using createFile then -1 means we have an unknown size\n    return source.size === -1 ? undefined : source.size;\n  } else {\n    return undefined;\n  }\n}\nfunction getTotalLength(sources) {\n  let total = 0;\n  for (const source of sources) {\n    const partLength = getLength(source);\n    if (partLength === undefined) {\n      return undefined;\n    } else {\n      total += partLength;\n    }\n  }\n  return total;\n}\nasync function buildRequestBody(request, parts, boundary) {\n  const sources = [stringToUint8Array(`--${boundary}`, \"utf-8\"), ...parts.flatMap(part => [stringToUint8Array(\"\\r\\n\", \"utf-8\"), stringToUint8Array(encodeHeaders(part.headers), \"utf-8\"), stringToUint8Array(\"\\r\\n\", \"utf-8\"), part.body, stringToUint8Array(`\\r\\n--${boundary}`, \"utf-8\")]), stringToUint8Array(\"--\\r\\n\\r\\n\", \"utf-8\")];\n  const contentLength = getTotalLength(sources);\n  if (contentLength) {\n    request.headers.set(\"Content-Length\", contentLength);\n  }\n  request.body = await concat(sources);\n}\n/**\n * Name of multipart policy\n */\nexport const multipartPolicyName = \"multipartPolicy\";\nconst maxBoundaryLength = 70;\nconst validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);\nfunction assertValidBoundary(boundary) {\n  if (boundary.length > maxBoundaryLength) {\n    throw new Error(`Multipart boundary \"${boundary}\" exceeds maximum length of 70 characters`);\n  }\n  if (Array.from(boundary).some(x => !validBoundaryCharacters.has(x))) {\n    throw new Error(`Multipart boundary \"${boundary}\" contains invalid characters`);\n  }\n}\n/**\n * Pipeline policy for multipart requests\n */\nexport function multipartPolicy() {\n  return {\n    name: multipartPolicyName,\n    async sendRequest(request, next) {\n      if (!request.multipartBody) {\n        return next(request);\n      }\n      if (request.body) {\n        throw new Error(\"multipartBody and regular body cannot be set at the same time\");\n      }\n      let boundary = request.multipartBody.boundary;\n      const contentTypeHeader = request.headers.get(\"Content-Type\") ?? \"multipart/mixed\";\n      const parsedHeader = contentTypeHeader.match(/^(multipart\\/[^ ;]+)(?:; *boundary=(.+))?$/);\n      if (!parsedHeader) {\n        throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);\n      }\n      const [, contentType, parsedBoundary] = parsedHeader;\n      if (parsedBoundary && boundary && parsedBoundary !== boundary) {\n        throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);\n      }\n      boundary ??= parsedBoundary;\n      if (boundary) {\n        assertValidBoundary(boundary);\n      } else {\n        boundary = generateBoundary();\n      }\n      request.headers.set(\"Content-Type\", `${contentType}; boundary=${boundary}`);\n      await buildRequestBody(request, request.multipartBody.parts, boundary);\n      request.multipartBody = undefined;\n      return next(request);\n    }\n  };\n}","map":{"version":3,"names":["stringToUint8Array","isBlob","randomUUID","concat","generateBoundary","encodeHeaders","headers","result","key","value","getLength","source","Uint8Array","byteLength","size","undefined","getTotalLength","sources","total","partLength","buildRequestBody","request","parts","boundary","flatMap","part","body","contentLength","set","multipartPolicyName","maxBoundaryLength","validBoundaryCharacters","Set","assertValidBoundary","length","Error","Array","from","some","x","has","multipartPolicy","name","sendRequest","next","multipartBody","contentTypeHeader","get","parsedHeader","match","contentType","parsedBoundary"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@typespec\\ts-http-runtime\\src\\policies\\multipartPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { BodyPart, HttpHeaders, PipelineRequest, PipelineResponse } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { stringToUint8Array } from \"../util/bytesEncoding.js\";\nimport { isBlob } from \"../util/typeGuards.js\";\nimport { randomUUID } from \"../util/uuidUtils.js\";\nimport { concat } from \"../util/concat.js\";\n\nfunction generateBoundary(): string {\n  return `----AzSDKFormBoundary${randomUUID()}`;\n}\n\nfunction encodeHeaders(headers: HttpHeaders): string {\n  let result = \"\";\n  for (const [key, value] of headers) {\n    result += `${key}: ${value}\\r\\n`;\n  }\n  return result;\n}\n\nfunction getLength(\n  source:\n    | (() => ReadableStream<Uint8Array>)\n    | (() => NodeJS.ReadableStream)\n    | Uint8Array\n    | Blob\n    | ReadableStream\n    | NodeJS.ReadableStream,\n): number | undefined {\n  if (source instanceof Uint8Array) {\n    return source.byteLength;\n  } else if (isBlob(source)) {\n    // if was created using createFile then -1 means we have an unknown size\n    return source.size === -1 ? undefined : source.size;\n  } else {\n    return undefined;\n  }\n}\n\nfunction getTotalLength(\n  sources: (\n    | (() => ReadableStream<Uint8Array>)\n    | (() => NodeJS.ReadableStream)\n    | Uint8Array\n    | Blob\n    | ReadableStream\n    | NodeJS.ReadableStream\n  )[],\n): number | undefined {\n  let total = 0;\n  for (const source of sources) {\n    const partLength = getLength(source);\n    if (partLength === undefined) {\n      return undefined;\n    } else {\n      total += partLength;\n    }\n  }\n  return total;\n}\n\nasync function buildRequestBody(\n  request: PipelineRequest,\n  parts: BodyPart[],\n  boundary: string,\n): Promise<void> {\n  const sources = [\n    stringToUint8Array(`--${boundary}`, \"utf-8\"),\n    ...parts.flatMap((part) => [\n      stringToUint8Array(\"\\r\\n\", \"utf-8\"),\n      stringToUint8Array(encodeHeaders(part.headers), \"utf-8\"),\n      stringToUint8Array(\"\\r\\n\", \"utf-8\"),\n      part.body,\n      stringToUint8Array(`\\r\\n--${boundary}`, \"utf-8\"),\n    ]),\n    stringToUint8Array(\"--\\r\\n\\r\\n\", \"utf-8\"),\n  ];\n\n  const contentLength = getTotalLength(sources);\n  if (contentLength) {\n    request.headers.set(\"Content-Length\", contentLength);\n  }\n\n  request.body = await concat(sources);\n}\n\n/**\n * Name of multipart policy\n */\nexport const multipartPolicyName = \"multipartPolicy\";\n\nconst maxBoundaryLength = 70;\nconst validBoundaryCharacters = new Set(\n  `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`,\n);\n\nfunction assertValidBoundary(boundary: string): void {\n  if (boundary.length > maxBoundaryLength) {\n    throw new Error(`Multipart boundary \"${boundary}\" exceeds maximum length of 70 characters`);\n  }\n\n  if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {\n    throw new Error(`Multipart boundary \"${boundary}\" contains invalid characters`);\n  }\n}\n\n/**\n * Pipeline policy for multipart requests\n */\nexport function multipartPolicy(): PipelinePolicy {\n  return {\n    name: multipartPolicyName,\n    async sendRequest(request, next): Promise<PipelineResponse> {\n      if (!request.multipartBody) {\n        return next(request);\n      }\n\n      if (request.body) {\n        throw new Error(\"multipartBody and regular body cannot be set at the same time\");\n      }\n\n      let boundary = request.multipartBody.boundary;\n\n      const contentTypeHeader = request.headers.get(\"Content-Type\") ?? \"multipart/mixed\";\n      const parsedHeader = contentTypeHeader.match(/^(multipart\\/[^ ;]+)(?:; *boundary=(.+))?$/);\n      if (!parsedHeader) {\n        throw new Error(\n          `Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`,\n        );\n      }\n\n      const [, contentType, parsedBoundary] = parsedHeader;\n      if (parsedBoundary && boundary && parsedBoundary !== boundary) {\n        throw new Error(\n          `Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`,\n        );\n      }\n\n      boundary ??= parsedBoundary;\n      if (boundary) {\n        assertValidBoundary(boundary);\n      } else {\n        boundary = generateBoundary();\n      }\n      request.headers.set(\"Content-Type\", `${contentType}; boundary=${boundary}`);\n      await buildRequestBody(request, request.multipartBody.parts, boundary);\n\n      request.multipartBody = undefined;\n\n      return next(request);\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}