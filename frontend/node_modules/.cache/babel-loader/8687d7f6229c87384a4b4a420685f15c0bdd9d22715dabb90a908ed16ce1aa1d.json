{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nconst ValidPhaseNames = new Set([\"Deserialize\", \"Serialize\", \"Retry\", \"Sign\"]);\n/**\n * A private implementation of Pipeline.\n * Do not export this class from the package.\n * @internal\n */\nclass HttpPipeline {\n  _policies = [];\n  _orderedPolicies;\n  constructor(policies) {\n    this._policies = policies?.slice(0) ?? [];\n    this._orderedPolicies = undefined;\n  }\n  addPolicy(policy, options = {}) {\n    if (options.phase && options.afterPhase) {\n      throw new Error(\"Policies inside a phase cannot specify afterPhase.\");\n    }\n    if (options.phase && !ValidPhaseNames.has(options.phase)) {\n      throw new Error(`Invalid phase name: ${options.phase}`);\n    }\n    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {\n      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);\n    }\n    this._policies.push({\n      policy,\n      options\n    });\n    this._orderedPolicies = undefined;\n  }\n  removePolicy(options) {\n    const removedPolicies = [];\n    this._policies = this._policies.filter(policyDescriptor => {\n      if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {\n        removedPolicies.push(policyDescriptor.policy);\n        return false;\n      } else {\n        return true;\n      }\n    });\n    this._orderedPolicies = undefined;\n    return removedPolicies;\n  }\n  sendRequest(httpClient, request) {\n    const policies = this.getOrderedPolicies();\n    const pipeline = policies.reduceRight((next, policy) => {\n      return req => {\n        return policy.sendRequest(req, next);\n      };\n    }, req => httpClient.sendRequest(req));\n    return pipeline(request);\n  }\n  getOrderedPolicies() {\n    if (!this._orderedPolicies) {\n      this._orderedPolicies = this.orderPolicies();\n    }\n    return this._orderedPolicies;\n  }\n  clone() {\n    return new HttpPipeline(this._policies);\n  }\n  static create() {\n    return new HttpPipeline();\n  }\n  orderPolicies() {\n    /**\n     * The goal of this method is to reliably order pipeline policies\n     * based on their declared requirements when they were added.\n     *\n     * Order is first determined by phase:\n     *\n     * 1. Serialize Phase\n     * 2. Policies not in a phase\n     * 3. Deserialize Phase\n     * 4. Retry Phase\n     * 5. Sign Phase\n     *\n     * Within each phase, policies are executed in the order\n     * they were added unless they were specified to execute\n     * before/after other policies or after a particular phase.\n     *\n     * To determine the final order, we will walk the policy list\n     * in phase order multiple times until all dependencies are\n     * satisfied.\n     *\n     * `afterPolicies` are the set of policies that must be\n     * executed before a given policy. This requirement is\n     * considered satisfied when each of the listed policies\n     * have been scheduled.\n     *\n     * `beforePolicies` are the set of policies that must be\n     * executed after a given policy. Since this dependency\n     * can be expressed by converting it into a equivalent\n     * `afterPolicies` declarations, they are normalized\n     * into that form for simplicity.\n     *\n     * An `afterPhase` dependency is considered satisfied when all\n     * policies in that phase have scheduled.\n     *\n     */\n    const result = [];\n    // Track all policies we know about.\n    const policyMap = new Map();\n    function createPhase(name) {\n      return {\n        name,\n        policies: new Set(),\n        hasRun: false,\n        hasAfterPolicies: false\n      };\n    }\n    // Track policies for each phase.\n    const serializePhase = createPhase(\"Serialize\");\n    const noPhase = createPhase(\"None\");\n    const deserializePhase = createPhase(\"Deserialize\");\n    const retryPhase = createPhase(\"Retry\");\n    const signPhase = createPhase(\"Sign\");\n    // a list of phases in order\n    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];\n    // Small helper function to map phase name to each Phase\n    function getPhase(phase) {\n      if (phase === \"Retry\") {\n        return retryPhase;\n      } else if (phase === \"Serialize\") {\n        return serializePhase;\n      } else if (phase === \"Deserialize\") {\n        return deserializePhase;\n      } else if (phase === \"Sign\") {\n        return signPhase;\n      } else {\n        return noPhase;\n      }\n    }\n    // First walk each policy and create a node to track metadata.\n    for (const descriptor of this._policies) {\n      const policy = descriptor.policy;\n      const options = descriptor.options;\n      const policyName = policy.name;\n      if (policyMap.has(policyName)) {\n        throw new Error(\"Duplicate policy names not allowed in pipeline\");\n      }\n      const node = {\n        policy,\n        dependsOn: new Set(),\n        dependants: new Set()\n      };\n      if (options.afterPhase) {\n        node.afterPhase = getPhase(options.afterPhase);\n        node.afterPhase.hasAfterPolicies = true;\n      }\n      policyMap.set(policyName, node);\n      const phase = getPhase(options.phase);\n      phase.policies.add(node);\n    }\n    // Now that each policy has a node, connect dependency references.\n    for (const descriptor of this._policies) {\n      const {\n        policy,\n        options\n      } = descriptor;\n      const policyName = policy.name;\n      const node = policyMap.get(policyName);\n      if (!node) {\n        throw new Error(`Missing node for policy ${policyName}`);\n      }\n      if (options.afterPolicies) {\n        for (const afterPolicyName of options.afterPolicies) {\n          const afterNode = policyMap.get(afterPolicyName);\n          if (afterNode) {\n            // Linking in both directions helps later\n            // when we want to notify dependants.\n            node.dependsOn.add(afterNode);\n            afterNode.dependants.add(node);\n          }\n        }\n      }\n      if (options.beforePolicies) {\n        for (const beforePolicyName of options.beforePolicies) {\n          const beforeNode = policyMap.get(beforePolicyName);\n          if (beforeNode) {\n            // To execute before another node, make it\n            // depend on the current node.\n            beforeNode.dependsOn.add(node);\n            node.dependants.add(beforeNode);\n          }\n        }\n      }\n    }\n    function walkPhase(phase) {\n      phase.hasRun = true;\n      // Sets iterate in insertion order\n      for (const node of phase.policies) {\n        if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {\n          // If this node is waiting on a phase to complete,\n          // we need to skip it for now.\n          // Even if the phase is empty, we should wait for it\n          // to be walked to avoid re-ordering policies.\n          continue;\n        }\n        if (node.dependsOn.size === 0) {\n          // If there's nothing else we're waiting for, we can\n          // add this policy to the result list.\n          result.push(node.policy);\n          // Notify anything that depends on this policy that\n          // the policy has been scheduled.\n          for (const dependant of node.dependants) {\n            dependant.dependsOn.delete(node);\n          }\n          policyMap.delete(node.policy.name);\n          phase.policies.delete(node);\n        }\n      }\n    }\n    function walkPhases() {\n      for (const phase of orderedPhases) {\n        walkPhase(phase);\n        // if the phase isn't complete\n        if (phase.policies.size > 0 && phase !== noPhase) {\n          if (!noPhase.hasRun) {\n            // Try running noPhase to see if that unblocks this phase next tick.\n            // This can happen if a phase that happens before noPhase\n            // is waiting on a noPhase policy to complete.\n            walkPhase(noPhase);\n          }\n          // Don't proceed to the next phase until this phase finishes.\n          return;\n        }\n        if (phase.hasAfterPolicies) {\n          // Run any policies unblocked by this phase\n          walkPhase(noPhase);\n        }\n      }\n    }\n    // Iterate until we've put every node in the result list.\n    let iteration = 0;\n    while (policyMap.size > 0) {\n      iteration++;\n      const initialResultLength = result.length;\n      // Keep walking each phase in order until we can order every node.\n      walkPhases();\n      // The result list *should* get at least one larger each time\n      // after the first full pass.\n      // Otherwise, we're going to loop forever.\n      if (result.length <= initialResultLength && iteration > 1) {\n        throw new Error(\"Cannot satisfy policy dependencies due to requirements cycle.\");\n      }\n    }\n    return result;\n  }\n}\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\nexport function createEmptyPipeline() {\n  return HttpPipeline.create();\n}","map":{"version":3,"names":["ValidPhaseNames","Set","HttpPipeline","_policies","_orderedPolicies","constructor","policies","slice","undefined","addPolicy","policy","options","phase","afterPhase","Error","has","push","removePolicy","removedPolicies","filter","policyDescriptor","name","sendRequest","httpClient","request","getOrderedPolicies","pipeline","reduceRight","next","req","orderPolicies","clone","create","result","policyMap","Map","createPhase","hasRun","hasAfterPolicies","serializePhase","noPhase","deserializePhase","retryPhase","signPhase","orderedPhases","getPhase","descriptor","policyName","node","dependsOn","dependants","set","add","get","afterPolicies","afterPolicyName","afterNode","beforePolicies","beforePolicyName","beforeNode","walkPhase","size","dependant","delete","walkPhases","iteration","initialResultLength","length","createEmptyPipeline"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@typespec\\ts-http-runtime\\src\\pipeline.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { HttpClient, PipelineRequest, PipelineResponse, SendRequest } from \"./interfaces.js\";\n\n/**\n * Policies are executed in phases.\n * The execution order is:\n * 1. Serialize Phase\n * 2. Policies not in a phase\n * 3. Deserialize Phase\n * 4. Retry Phase\n * 5. Sign Phase\n */\nexport type PipelinePhase = \"Deserialize\" | \"Serialize\" | \"Retry\" | \"Sign\";\n\nconst ValidPhaseNames = new Set<PipelinePhase>([\"Deserialize\", \"Serialize\", \"Retry\", \"Sign\"]);\n\n/**\n * Options when adding a policy to the pipeline.\n * Used to express dependencies on other policies.\n */\nexport interface AddPolicyOptions {\n  /**\n   * Policies that this policy must come before.\n   */\n  beforePolicies?: string[];\n  /**\n   * Policies that this policy must come after.\n   */\n  afterPolicies?: string[];\n  /**\n   * The phase that this policy must come after.\n   */\n  afterPhase?: PipelinePhase;\n  /**\n   * The phase this policy belongs to.\n   */\n  phase?: PipelinePhase;\n}\n\n/**\n * A pipeline policy manipulates a request as it travels through the pipeline.\n * It is conceptually a middleware that is allowed to modify the request before\n * it is made as well as the response when it is received.\n */\nexport interface PipelinePolicy {\n  /**\n   * The policy name. Must be a unique string in the pipeline.\n   */\n  name: string;\n  /**\n   * The main method to implement that manipulates a request/response.\n   * @param request - The request being performed.\n   * @param next - The next policy in the pipeline. Must be called to continue the pipeline.\n   */\n  sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;\n}\n\n/**\n * Represents a pipeline for making a HTTP request to a URL.\n * Pipelines can have multiple policies to manage manipulating each request\n * before and after it is made to the server.\n */\nexport interface Pipeline {\n  /**\n   * Add a new policy to the pipeline.\n   * @param policy - A policy that manipulates a request.\n   * @param options - A set of options for when the policy should run.\n   */\n  addPolicy(policy: PipelinePolicy, options?: AddPolicyOptions): void;\n  /**\n   * Remove a policy from the pipeline.\n   * @param options - Options that let you specify which policies to remove.\n   */\n  removePolicy(options: { name?: string; phase?: PipelinePhase }): PipelinePolicy[];\n  /**\n   * Uses the pipeline to make a HTTP request.\n   * @param httpClient - The HttpClient that actually performs the request.\n   * @param request - The request to be made.\n   */\n  sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse>;\n  /**\n   * Returns the current set of policies in the pipeline in the order in which\n   * they will be applied to the request. Later in the list is closer to when\n   * the request is performed.\n   */\n  getOrderedPolicies(): PipelinePolicy[];\n  /**\n   * Duplicates this pipeline to allow for modifying an existing one without mutating it.\n   */\n  clone(): Pipeline;\n}\n\ninterface PipelineDescriptor {\n  policy: PipelinePolicy;\n  options: AddPolicyOptions;\n}\n\ninterface PolicyGraphNode {\n  policy: PipelinePolicy;\n  dependsOn: Set<PolicyGraphNode>;\n  dependants: Set<PolicyGraphNode>;\n  afterPhase?: Phase;\n}\n\ninterface Phase {\n  name: PipelinePhase | \"None\";\n  policies: Set<PolicyGraphNode>;\n  hasRun: boolean;\n  hasAfterPolicies: boolean;\n}\n\n/**\n * A private implementation of Pipeline.\n * Do not export this class from the package.\n * @internal\n */\nclass HttpPipeline implements Pipeline {\n  private _policies: PipelineDescriptor[] = [];\n  private _orderedPolicies?: PipelinePolicy[];\n\n  private constructor(policies?: PipelineDescriptor[]) {\n    this._policies = policies?.slice(0) ?? [];\n    this._orderedPolicies = undefined;\n  }\n\n  public addPolicy(policy: PipelinePolicy, options: AddPolicyOptions = {}): void {\n    if (options.phase && options.afterPhase) {\n      throw new Error(\"Policies inside a phase cannot specify afterPhase.\");\n    }\n    if (options.phase && !ValidPhaseNames.has(options.phase)) {\n      throw new Error(`Invalid phase name: ${options.phase}`);\n    }\n    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {\n      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);\n    }\n    this._policies.push({\n      policy,\n      options,\n    });\n    this._orderedPolicies = undefined;\n  }\n\n  public removePolicy(options: { name?: string; phase?: string }): PipelinePolicy[] {\n    const removedPolicies: PipelinePolicy[] = [];\n\n    this._policies = this._policies.filter((policyDescriptor) => {\n      if (\n        (options.name && policyDescriptor.policy.name === options.name) ||\n        (options.phase && policyDescriptor.options.phase === options.phase)\n      ) {\n        removedPolicies.push(policyDescriptor.policy);\n        return false;\n      } else {\n        return true;\n      }\n    });\n    this._orderedPolicies = undefined;\n\n    return removedPolicies;\n  }\n\n  public sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse> {\n    const policies = this.getOrderedPolicies();\n\n    const pipeline = policies.reduceRight<SendRequest>(\n      (next, policy) => {\n        return (req: PipelineRequest) => {\n          return policy.sendRequest(req, next);\n        };\n      },\n      (req: PipelineRequest) => httpClient.sendRequest(req),\n    );\n\n    return pipeline(request);\n  }\n\n  public getOrderedPolicies(): PipelinePolicy[] {\n    if (!this._orderedPolicies) {\n      this._orderedPolicies = this.orderPolicies();\n    }\n    return this._orderedPolicies;\n  }\n\n  public clone(): Pipeline {\n    return new HttpPipeline(this._policies);\n  }\n\n  public static create(): Pipeline {\n    return new HttpPipeline();\n  }\n\n  private orderPolicies(): PipelinePolicy[] {\n    /**\n     * The goal of this method is to reliably order pipeline policies\n     * based on their declared requirements when they were added.\n     *\n     * Order is first determined by phase:\n     *\n     * 1. Serialize Phase\n     * 2. Policies not in a phase\n     * 3. Deserialize Phase\n     * 4. Retry Phase\n     * 5. Sign Phase\n     *\n     * Within each phase, policies are executed in the order\n     * they were added unless they were specified to execute\n     * before/after other policies or after a particular phase.\n     *\n     * To determine the final order, we will walk the policy list\n     * in phase order multiple times until all dependencies are\n     * satisfied.\n     *\n     * `afterPolicies` are the set of policies that must be\n     * executed before a given policy. This requirement is\n     * considered satisfied when each of the listed policies\n     * have been scheduled.\n     *\n     * `beforePolicies` are the set of policies that must be\n     * executed after a given policy. Since this dependency\n     * can be expressed by converting it into a equivalent\n     * `afterPolicies` declarations, they are normalized\n     * into that form for simplicity.\n     *\n     * An `afterPhase` dependency is considered satisfied when all\n     * policies in that phase have scheduled.\n     *\n     */\n    const result: PipelinePolicy[] = [];\n\n    // Track all policies we know about.\n    const policyMap: Map<string, PolicyGraphNode> = new Map<string, PolicyGraphNode>();\n\n    function createPhase(name: PipelinePhase | \"None\"): Phase {\n      return {\n        name,\n        policies: new Set<PolicyGraphNode>(),\n        hasRun: false,\n        hasAfterPolicies: false,\n      };\n    }\n\n    // Track policies for each phase.\n    const serializePhase = createPhase(\"Serialize\");\n    const noPhase = createPhase(\"None\");\n    const deserializePhase = createPhase(\"Deserialize\");\n    const retryPhase = createPhase(\"Retry\");\n    const signPhase = createPhase(\"Sign\");\n\n    // a list of phases in order\n    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];\n\n    // Small helper function to map phase name to each Phase\n    function getPhase(phase: PipelinePhase | undefined): Phase {\n      if (phase === \"Retry\") {\n        return retryPhase;\n      } else if (phase === \"Serialize\") {\n        return serializePhase;\n      } else if (phase === \"Deserialize\") {\n        return deserializePhase;\n      } else if (phase === \"Sign\") {\n        return signPhase;\n      } else {\n        return noPhase;\n      }\n    }\n\n    // First walk each policy and create a node to track metadata.\n    for (const descriptor of this._policies) {\n      const policy = descriptor.policy;\n      const options = descriptor.options;\n      const policyName = policy.name;\n      if (policyMap.has(policyName)) {\n        throw new Error(\"Duplicate policy names not allowed in pipeline\");\n      }\n      const node: PolicyGraphNode = {\n        policy,\n        dependsOn: new Set<PolicyGraphNode>(),\n        dependants: new Set<PolicyGraphNode>(),\n      };\n      if (options.afterPhase) {\n        node.afterPhase = getPhase(options.afterPhase);\n        node.afterPhase.hasAfterPolicies = true;\n      }\n      policyMap.set(policyName, node);\n      const phase = getPhase(options.phase);\n      phase.policies.add(node);\n    }\n\n    // Now that each policy has a node, connect dependency references.\n    for (const descriptor of this._policies) {\n      const { policy, options } = descriptor;\n      const policyName = policy.name;\n      const node = policyMap.get(policyName);\n      if (!node) {\n        throw new Error(`Missing node for policy ${policyName}`);\n      }\n\n      if (options.afterPolicies) {\n        for (const afterPolicyName of options.afterPolicies) {\n          const afterNode = policyMap.get(afterPolicyName);\n          if (afterNode) {\n            // Linking in both directions helps later\n            // when we want to notify dependants.\n            node.dependsOn.add(afterNode);\n            afterNode.dependants.add(node);\n          }\n        }\n      }\n      if (options.beforePolicies) {\n        for (const beforePolicyName of options.beforePolicies) {\n          const beforeNode = policyMap.get(beforePolicyName);\n          if (beforeNode) {\n            // To execute before another node, make it\n            // depend on the current node.\n            beforeNode.dependsOn.add(node);\n            node.dependants.add(beforeNode);\n          }\n        }\n      }\n    }\n\n    function walkPhase(phase: Phase): void {\n      phase.hasRun = true;\n      // Sets iterate in insertion order\n      for (const node of phase.policies) {\n        if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {\n          // If this node is waiting on a phase to complete,\n          // we need to skip it for now.\n          // Even if the phase is empty, we should wait for it\n          // to be walked to avoid re-ordering policies.\n          continue;\n        }\n        if (node.dependsOn.size === 0) {\n          // If there's nothing else we're waiting for, we can\n          // add this policy to the result list.\n          result.push(node.policy);\n          // Notify anything that depends on this policy that\n          // the policy has been scheduled.\n          for (const dependant of node.dependants) {\n            dependant.dependsOn.delete(node);\n          }\n          policyMap.delete(node.policy.name);\n          phase.policies.delete(node);\n        }\n      }\n    }\n\n    function walkPhases(): void {\n      for (const phase of orderedPhases) {\n        walkPhase(phase);\n        // if the phase isn't complete\n        if (phase.policies.size > 0 && phase !== noPhase) {\n          if (!noPhase.hasRun) {\n            // Try running noPhase to see if that unblocks this phase next tick.\n            // This can happen if a phase that happens before noPhase\n            // is waiting on a noPhase policy to complete.\n            walkPhase(noPhase);\n          }\n          // Don't proceed to the next phase until this phase finishes.\n          return;\n        }\n\n        if (phase.hasAfterPolicies) {\n          // Run any policies unblocked by this phase\n          walkPhase(noPhase);\n        }\n      }\n    }\n\n    // Iterate until we've put every node in the result list.\n    let iteration = 0;\n    while (policyMap.size > 0) {\n      iteration++;\n      const initialResultLength = result.length;\n      // Keep walking each phase in order until we can order every node.\n      walkPhases();\n      // The result list *should* get at least one larger each time\n      // after the first full pass.\n      // Otherwise, we're going to loop forever.\n      if (result.length <= initialResultLength && iteration > 1) {\n        throw new Error(\"Cannot satisfy policy dependencies due to requirements cycle.\");\n      }\n    }\n\n    return result;\n  }\n}\n\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\nexport function createEmptyPipeline(): Pipeline {\n  return HttpPipeline.create();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}