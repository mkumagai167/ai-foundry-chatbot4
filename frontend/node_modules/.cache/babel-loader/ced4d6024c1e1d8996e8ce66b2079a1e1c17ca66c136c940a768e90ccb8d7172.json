{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\n// We use a custom symbol to cache a reference to the original request without\n// exposing it on the public interface.\nconst originalRequestSymbol = Symbol(\"Original PipelineRequest\");\n// Symbol.for() will return the same symbol if it's already been created\n// This particular one is used in core-client to handle the case of when a request is\n// cloned but we need to retrieve the OperationSpec and OperationArguments from the\n// original request.\nconst originalClientRequestSymbol = Symbol.for(\"@azure/core-client original request\");\nexport function toPipelineRequest(webResource, options = {}) {\n  const compatWebResource = webResource;\n  const request = compatWebResource[originalRequestSymbol];\n  const headers = createHttpHeaders(webResource.headers.toJson({\n    preserveCase: true\n  }));\n  if (request) {\n    request.headers = headers;\n    return request;\n  } else {\n    const newRequest = createPipelineRequest({\n      url: webResource.url,\n      method: webResource.method,\n      headers,\n      withCredentials: webResource.withCredentials,\n      timeout: webResource.timeout,\n      requestId: webResource.requestId,\n      abortSignal: webResource.abortSignal,\n      body: webResource.body,\n      formData: webResource.formData,\n      disableKeepAlive: !!webResource.keepAlive,\n      onDownloadProgress: webResource.onDownloadProgress,\n      onUploadProgress: webResource.onUploadProgress,\n      proxySettings: webResource.proxySettings,\n      streamResponseStatusCodes: webResource.streamResponseStatusCodes,\n      agent: webResource.agent,\n      requestOverrides: webResource.requestOverrides\n    });\n    if (options.originalRequest) {\n      newRequest[originalClientRequestSymbol] = options.originalRequest;\n    }\n    return newRequest;\n  }\n}\nexport function toWebResourceLike(request, options) {\n  const originalRequest = options?.originalRequest ?? request;\n  const webResource = {\n    url: request.url,\n    method: request.method,\n    headers: toHttpHeadersLike(request.headers),\n    withCredentials: request.withCredentials,\n    timeout: request.timeout,\n    requestId: request.headers.get(\"x-ms-client-request-id\") || request.requestId,\n    abortSignal: request.abortSignal,\n    body: request.body,\n    formData: request.formData,\n    keepAlive: !!request.disableKeepAlive,\n    onDownloadProgress: request.onDownloadProgress,\n    onUploadProgress: request.onUploadProgress,\n    proxySettings: request.proxySettings,\n    streamResponseStatusCodes: request.streamResponseStatusCodes,\n    agent: request.agent,\n    requestOverrides: request.requestOverrides,\n    clone() {\n      throw new Error(\"Cannot clone a non-proxied WebResourceLike\");\n    },\n    prepare() {\n      throw new Error(\"WebResourceLike.prepare() is not supported by @azure/core-http-compat\");\n    },\n    validateRequestProperties() {\n      /** do nothing */\n    }\n  };\n  if (options?.createProxy) {\n    return new Proxy(webResource, {\n      get(target, prop, receiver) {\n        if (prop === originalRequestSymbol) {\n          return request;\n        } else if (prop === \"clone\") {\n          return () => {\n            return toWebResourceLike(toPipelineRequest(webResource, {\n              originalRequest\n            }), {\n              createProxy: true,\n              originalRequest\n            });\n          };\n        }\n        return Reflect.get(target, prop, receiver);\n      },\n      set(target, prop, value, receiver) {\n        if (prop === \"keepAlive\") {\n          request.disableKeepAlive = !value;\n        }\n        const passThroughProps = [\"url\", \"method\", \"withCredentials\", \"timeout\", \"requestId\", \"abortSignal\", \"body\", \"formData\", \"onDownloadProgress\", \"onUploadProgress\", \"proxySettings\", \"streamResponseStatusCodes\", \"agent\", \"requestOverrides\"];\n        if (typeof prop === \"string\" && passThroughProps.includes(prop)) {\n          request[prop] = value;\n        }\n        return Reflect.set(target, prop, value, receiver);\n      }\n    });\n  } else {\n    return webResource;\n  }\n}\n/**\n * Converts HttpHeaders from core-rest-pipeline to look like\n * HttpHeaders from core-http.\n * @param headers - HttpHeaders from core-rest-pipeline\n * @returns HttpHeaders as they looked in core-http\n */\nexport function toHttpHeadersLike(headers) {\n  return new HttpHeaders(headers.toJSON({\n    preserveCase: true\n  }));\n}\n/**\n * A collection of HttpHeaders that can be sent with a HTTP request.\n */\nfunction getHeaderKey(headerName) {\n  return headerName.toLowerCase();\n}\n/**\n * A collection of HTTP header key/value pairs.\n */\nexport class HttpHeaders {\n  _headersMap;\n  constructor(rawHeaders) {\n    this._headersMap = {};\n    if (rawHeaders) {\n      for (const headerName in rawHeaders) {\n        this.set(headerName, rawHeaders[headerName]);\n      }\n    }\n  }\n  /**\n   * Set a header in this collection with the provided name and value. The name is\n   * case-insensitive.\n   * @param headerName - The name of the header to set. This value is case-insensitive.\n   * @param headerValue - The value of the header to set.\n   */\n  set(headerName, headerValue) {\n    this._headersMap[getHeaderKey(headerName)] = {\n      name: headerName,\n      value: headerValue.toString()\n    };\n  }\n  /**\n   * Get the header value for the provided header name, or undefined if no header exists in this\n   * collection with the provided name.\n   * @param headerName - The name of the header.\n   */\n  get(headerName) {\n    const header = this._headersMap[getHeaderKey(headerName)];\n    return !header ? undefined : header.value;\n  }\n  /**\n   * Get whether or not this header collection contains a header entry for the provided header name.\n   */\n  contains(headerName) {\n    return !!this._headersMap[getHeaderKey(headerName)];\n  }\n  /**\n   * Remove the header with the provided headerName. Return whether or not the header existed and\n   * was removed.\n   * @param headerName - The name of the header to remove.\n   */\n  remove(headerName) {\n    const result = this.contains(headerName);\n    delete this._headersMap[getHeaderKey(headerName)];\n    return result;\n  }\n  /**\n   * Get the headers that are contained this collection as an object.\n   */\n  rawHeaders() {\n    return this.toJson({\n      preserveCase: true\n    });\n  }\n  /**\n   * Get the headers that are contained in this collection as an array.\n   */\n  headersArray() {\n    const headers = [];\n    for (const headerKey in this._headersMap) {\n      headers.push(this._headersMap[headerKey]);\n    }\n    return headers;\n  }\n  /**\n   * Get the header names that are contained in this collection.\n   */\n  headerNames() {\n    const headerNames = [];\n    const headers = this.headersArray();\n    for (let i = 0; i < headers.length; ++i) {\n      headerNames.push(headers[i].name);\n    }\n    return headerNames;\n  }\n  /**\n   * Get the header values that are contained in this collection.\n   */\n  headerValues() {\n    const headerValues = [];\n    const headers = this.headersArray();\n    for (let i = 0; i < headers.length; ++i) {\n      headerValues.push(headers[i].value);\n    }\n    return headerValues;\n  }\n  /**\n   * Get the JSON object representation of this HTTP header collection.\n   */\n  toJson(options = {}) {\n    const result = {};\n    if (options.preserveCase) {\n      for (const headerKey in this._headersMap) {\n        const header = this._headersMap[headerKey];\n        result[header.name] = header.value;\n      }\n    } else {\n      for (const headerKey in this._headersMap) {\n        const header = this._headersMap[headerKey];\n        result[getHeaderKey(header.name)] = header.value;\n      }\n    }\n    return result;\n  }\n  /**\n   * Get the string representation of this HTTP header collection.\n   */\n  toString() {\n    return JSON.stringify(this.toJson({\n      preserveCase: true\n    }));\n  }\n  /**\n   * Create a deep clone/copy of this HttpHeaders collection.\n   */\n  clone() {\n    const resultPreservingCasing = {};\n    for (const headerKey in this._headersMap) {\n      const header = this._headersMap[headerKey];\n      resultPreservingCasing[header.name] = header.value;\n    }\n    return new HttpHeaders(resultPreservingCasing);\n  }\n}","map":{"version":3,"names":["createHttpHeaders","createPipelineRequest","originalRequestSymbol","Symbol","originalClientRequestSymbol","for","toPipelineRequest","webResource","options","compatWebResource","request","headers","toJson","preserveCase","newRequest","url","method","withCredentials","timeout","requestId","abortSignal","body","formData","disableKeepAlive","keepAlive","onDownloadProgress","onUploadProgress","proxySettings","streamResponseStatusCodes","agent","requestOverrides","originalRequest","toWebResourceLike","toHttpHeadersLike","get","clone","Error","prepare","validateRequestProperties","createProxy","Proxy","target","prop","receiver","Reflect","set","value","passThroughProps","includes","HttpHeaders","toJSON","getHeaderKey","headerName","toLowerCase","_headersMap","constructor","rawHeaders","headerValue","name","toString","header","undefined","contains","remove","result","headersArray","headerKey","push","headerNames","i","length","headerValues","JSON","stringify","resultPreservingCasing"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@azure\\core-http-compat\\src\\util.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { HttpMethods, ProxySettings } from \"@azure/core-rest-pipeline\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport type { HttpHeaders as HttpHeadersV2, PipelineRequest } from \"@azure/core-rest-pipeline\";\n\n// We use a custom symbol to cache a reference to the original request without\n// exposing it on the public interface.\nconst originalRequestSymbol = Symbol(\"Original PipelineRequest\");\ntype CompatWebResourceLike = WebResourceLike & { [originalRequestSymbol]?: PipelineRequest };\n// Symbol.for() will return the same symbol if it's already been created\n// This particular one is used in core-client to handle the case of when a request is\n// cloned but we need to retrieve the OperationSpec and OperationArguments from the\n// original request.\nconst originalClientRequestSymbol = Symbol.for(\"@azure/core-client original request\");\ntype PipelineRequestWithOriginal = PipelineRequest & {\n  [originalClientRequestSymbol]?: PipelineRequest;\n};\n\nexport function toPipelineRequest(\n  webResource: WebResourceLike,\n  options: {\n    originalRequest?: PipelineRequest;\n  } = {},\n): PipelineRequest {\n  const compatWebResource = webResource as CompatWebResourceLike;\n  const request = compatWebResource[originalRequestSymbol];\n  const headers = createHttpHeaders(webResource.headers.toJson({ preserveCase: true }));\n  if (request) {\n    request.headers = headers;\n    return request;\n  } else {\n    const newRequest = createPipelineRequest({\n      url: webResource.url,\n      method: webResource.method,\n      headers,\n      withCredentials: webResource.withCredentials,\n      timeout: webResource.timeout,\n      requestId: webResource.requestId,\n      abortSignal: webResource.abortSignal,\n      body: webResource.body,\n      formData: webResource.formData,\n      disableKeepAlive: !!webResource.keepAlive,\n      onDownloadProgress: webResource.onDownloadProgress,\n      onUploadProgress: webResource.onUploadProgress,\n      proxySettings: webResource.proxySettings,\n      streamResponseStatusCodes: webResource.streamResponseStatusCodes,\n      agent: webResource.agent,\n      requestOverrides: webResource.requestOverrides,\n    });\n    if (options.originalRequest) {\n      (newRequest as PipelineRequestWithOriginal)[originalClientRequestSymbol] =\n        options.originalRequest;\n    }\n    return newRequest;\n  }\n}\n\nexport function toWebResourceLike(\n  request: PipelineRequest,\n  options?: { createProxy?: boolean; originalRequest?: PipelineRequest },\n): WebResourceLike {\n  const originalRequest = options?.originalRequest ?? request;\n  const webResource: WebResourceLike = {\n    url: request.url,\n    method: request.method,\n    headers: toHttpHeadersLike(request.headers),\n    withCredentials: request.withCredentials,\n    timeout: request.timeout,\n    requestId: request.headers.get(\"x-ms-client-request-id\") || request.requestId,\n    abortSignal: request.abortSignal,\n    body: request.body,\n    formData: request.formData,\n    keepAlive: !!request.disableKeepAlive,\n    onDownloadProgress: request.onDownloadProgress,\n    onUploadProgress: request.onUploadProgress,\n    proxySettings: request.proxySettings,\n    streamResponseStatusCodes: request.streamResponseStatusCodes,\n    agent: request.agent,\n    requestOverrides: request.requestOverrides,\n    clone(): WebResourceLike {\n      throw new Error(\"Cannot clone a non-proxied WebResourceLike\");\n    },\n    prepare(): WebResourceLike {\n      throw new Error(\"WebResourceLike.prepare() is not supported by @azure/core-http-compat\");\n    },\n    validateRequestProperties(): void {\n      /** do nothing */\n    },\n  };\n\n  if (options?.createProxy) {\n    return new Proxy(webResource, {\n      get(target, prop, receiver) {\n        if (prop === originalRequestSymbol) {\n          return request;\n        } else if (prop === \"clone\") {\n          return () => {\n            return toWebResourceLike(toPipelineRequest(webResource, { originalRequest }), {\n              createProxy: true,\n              originalRequest,\n            });\n          };\n        }\n        return Reflect.get(target, prop, receiver);\n      },\n      set(target: any, prop, value, receiver) {\n        if (prop === \"keepAlive\") {\n          request.disableKeepAlive = !value;\n        }\n        const passThroughProps = [\n          \"url\",\n          \"method\",\n          \"withCredentials\",\n          \"timeout\",\n          \"requestId\",\n          \"abortSignal\",\n          \"body\",\n          \"formData\",\n          \"onDownloadProgress\",\n          \"onUploadProgress\",\n          \"proxySettings\",\n          \"streamResponseStatusCodes\",\n          \"agent\",\n          \"requestOverrides\",\n        ];\n\n        if (typeof prop === \"string\" && passThroughProps.includes(prop)) {\n          (request as any)[prop] = value;\n        }\n\n        return Reflect.set(target, prop, value, receiver);\n      },\n    });\n  } else {\n    return webResource;\n  }\n}\n\n/**\n * Converts HttpHeaders from core-rest-pipeline to look like\n * HttpHeaders from core-http.\n * @param headers - HttpHeaders from core-rest-pipeline\n * @returns HttpHeaders as they looked in core-http\n */\nexport function toHttpHeadersLike(headers: HttpHeadersV2): HttpHeadersLike {\n  return new HttpHeaders(headers.toJSON({ preserveCase: true }));\n}\n\n/**\n * A collection of HttpHeaders that can be sent with a HTTP request.\n */\nfunction getHeaderKey(headerName: string): string {\n  return headerName.toLowerCase();\n}\n\n/**\n * An individual header within a HttpHeaders collection.\n */\nexport interface HttpHeader {\n  /**\n   * The name of the header.\n   */\n  name: string;\n\n  /**\n   * The value of the header.\n   */\n  value: string;\n}\n\n/**\n * A HttpHeaders collection represented as a simple JSON object.\n */\nexport type RawHttpHeaders = { [headerName: string]: string };\n\n/**\n * A collection of HTTP header key/value pairs.\n */\nexport interface HttpHeadersLike {\n  /**\n   * Set a header in this collection with the provided name and value. The name is\n   * case-insensitive.\n   * @param headerName - The name of the header to set. This value is case-insensitive.\n   * @param headerValue - The value of the header to set.\n   */\n  set(headerName: string, headerValue: string | number): void;\n  /**\n   * Get the header value for the provided header name, or undefined if no header exists in this\n   * collection with the provided name.\n   * @param headerName - The name of the header.\n   */\n  get(headerName: string): string | undefined;\n  /**\n   * Get whether or not this header collection contains a header entry for the provided header name.\n   */\n  contains(headerName: string): boolean;\n  /**\n   * Remove the header with the provided headerName. Return whether or not the header existed and\n   * was removed.\n   * @param headerName - The name of the header to remove.\n   */\n  remove(headerName: string): boolean;\n  /**\n   * Get the headers that are contained this collection as an object.\n   */\n  rawHeaders(): RawHttpHeaders;\n  /**\n   * Get the headers that are contained in this collection as an array.\n   */\n  headersArray(): HttpHeader[];\n  /**\n   * Get the header names that are contained in this collection.\n   */\n  headerNames(): string[];\n  /**\n   * Get the header values that are contained in this collection.\n   */\n  headerValues(): string[];\n  /**\n   * Create a deep clone/copy of this HttpHeaders collection.\n   */\n  clone(): HttpHeadersLike;\n  /**\n   * Get the JSON object representation of this HTTP header collection.\n   * The result is the same as `rawHeaders()`.\n   */\n  toJson(options?: { preserveCase?: boolean }): RawHttpHeaders;\n}\n\n/**\n * A collection of HTTP header key/value pairs.\n */\nexport class HttpHeaders implements HttpHeadersLike {\n  private readonly _headersMap: { [headerKey: string]: HttpHeader };\n\n  constructor(rawHeaders?: RawHttpHeaders) {\n    this._headersMap = {};\n    if (rawHeaders) {\n      for (const headerName in rawHeaders) {\n        this.set(headerName, rawHeaders[headerName]);\n      }\n    }\n  }\n\n  /**\n   * Set a header in this collection with the provided name and value. The name is\n   * case-insensitive.\n   * @param headerName - The name of the header to set. This value is case-insensitive.\n   * @param headerValue - The value of the header to set.\n   */\n  public set(headerName: string, headerValue: string | number): void {\n    this._headersMap[getHeaderKey(headerName)] = {\n      name: headerName,\n      value: headerValue.toString(),\n    };\n  }\n\n  /**\n   * Get the header value for the provided header name, or undefined if no header exists in this\n   * collection with the provided name.\n   * @param headerName - The name of the header.\n   */\n  public get(headerName: string): string | undefined {\n    const header: HttpHeader = this._headersMap[getHeaderKey(headerName)];\n    return !header ? undefined : header.value;\n  }\n\n  /**\n   * Get whether or not this header collection contains a header entry for the provided header name.\n   */\n  public contains(headerName: string): boolean {\n    return !!this._headersMap[getHeaderKey(headerName)];\n  }\n\n  /**\n   * Remove the header with the provided headerName. Return whether or not the header existed and\n   * was removed.\n   * @param headerName - The name of the header to remove.\n   */\n  public remove(headerName: string): boolean {\n    const result: boolean = this.contains(headerName);\n    delete this._headersMap[getHeaderKey(headerName)];\n    return result;\n  }\n\n  /**\n   * Get the headers that are contained this collection as an object.\n   */\n  public rawHeaders(): RawHttpHeaders {\n    return this.toJson({ preserveCase: true });\n  }\n\n  /**\n   * Get the headers that are contained in this collection as an array.\n   */\n  public headersArray(): HttpHeader[] {\n    const headers: HttpHeader[] = [];\n    for (const headerKey in this._headersMap) {\n      headers.push(this._headersMap[headerKey]);\n    }\n    return headers;\n  }\n\n  /**\n   * Get the header names that are contained in this collection.\n   */\n  public headerNames(): string[] {\n    const headerNames: string[] = [];\n    const headers: HttpHeader[] = this.headersArray();\n    for (let i = 0; i < headers.length; ++i) {\n      headerNames.push(headers[i].name);\n    }\n    return headerNames;\n  }\n\n  /**\n   * Get the header values that are contained in this collection.\n   */\n  public headerValues(): string[] {\n    const headerValues: string[] = [];\n    const headers: HttpHeader[] = this.headersArray();\n    for (let i = 0; i < headers.length; ++i) {\n      headerValues.push(headers[i].value);\n    }\n    return headerValues;\n  }\n\n  /**\n   * Get the JSON object representation of this HTTP header collection.\n   */\n  public toJson(options: { preserveCase?: boolean } = {}): RawHttpHeaders {\n    const result: RawHttpHeaders = {};\n    if (options.preserveCase) {\n      for (const headerKey in this._headersMap) {\n        const header: HttpHeader = this._headersMap[headerKey];\n        result[header.name] = header.value;\n      }\n    } else {\n      for (const headerKey in this._headersMap) {\n        const header: HttpHeader = this._headersMap[headerKey];\n        result[getHeaderKey(header.name)] = header.value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Get the string representation of this HTTP header collection.\n   */\n  public toString(): string {\n    return JSON.stringify(this.toJson({ preserveCase: true }));\n  }\n\n  /**\n   * Create a deep clone/copy of this HttpHeaders collection.\n   */\n  public clone(): HttpHeaders {\n    const resultPreservingCasing: RawHttpHeaders = {};\n    for (const headerKey in this._headersMap) {\n      const header: HttpHeader = this._headersMap[headerKey];\n      resultPreservingCasing[header.name] = header.value;\n    }\n    return new HttpHeaders(resultPreservingCasing);\n  }\n}\n\n/**\n * An interface compatible with NodeJS's `http.Agent`.\n * We want to avoid publicly re-exporting the actual interface,\n * since it might vary across runtime versions.\n */\nexport interface Agent {\n  /**\n   * Destroy any sockets that are currently in use by the agent.\n   */\n  destroy(): void;\n  /**\n   * For agents with keepAlive enabled, this sets the maximum number of sockets that will be left open in the free state.\n   */\n  maxFreeSockets: number;\n  /**\n   * Determines how many concurrent sockets the agent can have open per origin.\n   */\n  maxSockets: number;\n  /**\n   * An object which contains queues of requests that have not yet been assigned to sockets.\n   */\n  requests: unknown;\n  /**\n   * An object which contains arrays of sockets currently in use by the agent.\n   */\n  sockets: unknown;\n}\n\n/**\n * A description of a HTTP request to be made to a remote server.\n */\nexport interface WebResourceLike {\n  /**\n   * The URL being accessed by the request.\n   */\n  url: string;\n  /**\n   * The HTTP method to use when making the request.\n   */\n  method: HttpMethods;\n  /**\n   * The HTTP body contents of the request.\n   */\n  body?: any;\n  /**\n   * The HTTP headers to use when making the request.\n   */\n  headers: HttpHeadersLike;\n  /**\n   * Whether or not the body of the HttpOperationResponse should be treated as a stream.\n   * @deprecated Use streamResponseStatusCodes property instead.\n   */\n  streamResponseBody?: boolean;\n  /**\n   * A list of response status codes whose corresponding HttpOperationResponse body should be treated as a stream.\n   */\n  streamResponseStatusCodes?: Set<number>;\n  /**\n   * Form data, used to build the request body.\n   */\n  formData?: any;\n  /**\n   * A query string represented as an object.\n   */\n  query?: { [key: string]: any };\n  /**\n   * If credentials (cookies) should be sent along during an XHR.\n   */\n  withCredentials: boolean;\n  /**\n   * The number of milliseconds a request can take before automatically being terminated.\n   * If the request is terminated, an `AbortError` is thrown.\n   */\n  timeout: number;\n  /**\n   * Proxy configuration.\n   */\n  proxySettings?: ProxySettings;\n  /**\n   * If the connection should be reused.\n   */\n  keepAlive?: boolean;\n  /**\n   * Whether or not to decompress response according to Accept-Encoding header (node-fetch only)\n   */\n  decompressResponse?: boolean;\n  /**\n   * A unique identifier for the request. Used for logging and tracing.\n   */\n  requestId: string;\n\n  /**\n   * Signal of an abort controller. Can be used to abort both sending a network request and waiting for a response.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Callback which fires upon upload progress.\n   */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /** Callback which fires upon download progress. */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * NODEJS ONLY\n   *\n   * A Node-only option to provide a custom `http.Agent`/`https.Agent`.\n   * NOTE: usually this should be one instance shared by multiple requests so that the underlying\n   *       connection to the service can be reused.\n   * Does nothing when running in the browser.\n   */\n  agent?: Agent;\n\n  /**\n   * Additional options to set on the request. This provides a way to override\n   * existing ones or provide request properties that are not declared.\n   *\n   * For possible valid properties, see\n   *   - NodeJS https.request options:  https://nodejs.org/api/http.html#httprequestoptions-callback\n   *   - Browser RequestInit: https://developer.mozilla.org/en-US/docs/Web/API/RequestInit\n   *\n   * WARNING: Options specified here will override any properties of same names when request is sent by {@link HttpClient}.\n   */\n  requestOverrides?: Record<string, unknown>;\n\n  /**\n   * Clone this request object.\n   */\n  clone(): WebResourceLike;\n\n  /**\n   * Validates that the required properties such as method, url, headers[\"Content-Type\"],\n   * headers[\"accept-language\"] are defined. It will throw an error if one of the above\n   * mentioned properties are not defined.\n   * Note: this a no-op for compat purposes.\n   */\n  validateRequestProperties(): void;\n\n  /**\n   * This is a no-op for compat purposes and will throw if called.\n   */\n  prepare(options: unknown): WebResourceLike;\n}\n\n/**\n * Fired in response to upload or download progress.\n */\nexport type TransferProgressEvent = {\n  /**\n   * The number of bytes loaded so far.\n   */\n  loadedBytes: number;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}