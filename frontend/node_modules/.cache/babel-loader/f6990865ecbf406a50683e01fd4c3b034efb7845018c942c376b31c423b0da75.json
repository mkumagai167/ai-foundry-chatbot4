{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AbortError } from \"@azure/abort-controller\";\nimport { isRestError, RestError } from \"@azure/core-rest-pipeline\";\nimport { getErrorMessage } from \"@azure/core-util\";\nimport { StorageRetryPolicyType } from \"../StorageRetryPolicyFactory.js\";\nimport { URLConstants } from \"../utils/constants.js\";\nimport { delay, setURLHost, setURLParameter } from \"../utils/utils.common.js\";\nimport { logger } from \"../log.js\";\n/**\n * Name of the {@link storageRetryPolicy}\n */\nexport const storageRetryPolicyName = \"storageRetryPolicy\";\n// Default values of StorageRetryOptions\nconst DEFAULT_RETRY_OPTIONS = {\n  maxRetryDelayInMs: 120 * 1000,\n  maxTries: 4,\n  retryDelayInMs: 4 * 1000,\n  retryPolicyType: StorageRetryPolicyType.EXPONENTIAL,\n  secondaryHost: \"\",\n  tryTimeoutInMs: undefined // Use server side default timeout strategy\n};\nconst retriableErrors = [\"ETIMEDOUT\", \"ESOCKETTIMEDOUT\", \"ECONNREFUSED\", \"ECONNRESET\", \"ENOENT\", \"ENOTFOUND\", \"TIMEOUT\", \"EPIPE\", \"REQUEST_SEND_ERROR\"];\nconst RETRY_ABORT_ERROR = new AbortError(\"The operation was aborted.\");\n/**\n * Retry policy with exponential retry and linear retry implemented.\n */\nexport function storageRetryPolicy(options = {}) {\n  const retryPolicyType = options.retryPolicyType ?? DEFAULT_RETRY_OPTIONS.retryPolicyType;\n  const maxTries = options.maxTries ?? DEFAULT_RETRY_OPTIONS.maxTries;\n  const retryDelayInMs = options.retryDelayInMs ?? DEFAULT_RETRY_OPTIONS.retryDelayInMs;\n  const maxRetryDelayInMs = options.maxRetryDelayInMs ?? DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;\n  const secondaryHost = options.secondaryHost ?? DEFAULT_RETRY_OPTIONS.secondaryHost;\n  const tryTimeoutInMs = options.tryTimeoutInMs ?? DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;\n  function shouldRetry({\n    isPrimaryRetry,\n    attempt,\n    response,\n    error\n  }) {\n    if (attempt >= maxTries) {\n      logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);\n      return false;\n    }\n    if (error) {\n      for (const retriableError of retriableErrors) {\n        if (error.name.toUpperCase().includes(retriableError) || error.message.toUpperCase().includes(retriableError) || error.code && error.code.toString().toUpperCase() === retriableError) {\n          logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);\n          return true;\n        }\n      }\n      if (error?.code === \"PARSE_ERROR\" && error?.message.startsWith(`Error \"Error: Unclosed root tag`)) {\n        logger.info(\"RetryPolicy: Incomplete XML response likely due to service timeout, will retry.\");\n        return true;\n      }\n    }\n    // If attempt was against the secondary & it returned a StatusNotFound (404), then\n    // the resource was not found. This may be due to replication delay. So, in this\n    // case, we'll never try the secondary again for this operation.\n    if (response || error) {\n      const statusCode = response?.status ?? error?.statusCode ?? 0;\n      if (!isPrimaryRetry && statusCode === 404) {\n        logger.info(`RetryPolicy: Secondary access with 404, will retry.`);\n        return true;\n      }\n      // Server internal error or server timeout\n      if (statusCode === 503 || statusCode === 500) {\n        logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);\n        return true;\n      }\n    }\n    // [Copy source error code] Feature is pending on service side, skip retry on copy source error for now.\n    // if (response) {\n    //   // Retry select Copy Source Error Codes.\n    //   if (response?.status >= 400) {\n    //     const copySourceError = response.headers.get(HeaderConstants.X_MS_CopySourceErrorCode);\n    //     if (copySourceError !== undefined) {\n    //       switch (copySourceError) {\n    //         case \"InternalError\":\n    //         case \"OperationTimedOut\":\n    //         case \"ServerBusy\":\n    //           return true;\n    //       }\n    //     }\n    //   }\n    // }\n    return false;\n  }\n  function calculateDelay(isPrimaryRetry, attempt) {\n    let delayTimeInMs = 0;\n    if (isPrimaryRetry) {\n      switch (retryPolicyType) {\n        case StorageRetryPolicyType.EXPONENTIAL:\n          delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);\n          break;\n        case StorageRetryPolicyType.FIXED:\n          delayTimeInMs = retryDelayInMs;\n          break;\n      }\n    } else {\n      delayTimeInMs = Math.random() * 1000;\n    }\n    logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);\n    return delayTimeInMs;\n  }\n  return {\n    name: storageRetryPolicyName,\n    async sendRequest(request, next) {\n      // Set the server-side timeout query parameter \"timeout=[seconds]\"\n      if (tryTimeoutInMs) {\n        request.url = setURLParameter(request.url, URLConstants.Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1000)));\n      }\n      const primaryUrl = request.url;\n      const secondaryUrl = secondaryHost ? setURLHost(request.url, secondaryHost) : undefined;\n      let secondaryHas404 = false;\n      let attempt = 1;\n      let retryAgain = true;\n      let response;\n      let error;\n      while (retryAgain) {\n        const isPrimaryRetry = secondaryHas404 || !secondaryUrl || ![\"GET\", \"HEAD\", \"OPTIONS\"].includes(request.method) || attempt % 2 === 1;\n        request.url = isPrimaryRetry ? primaryUrl : secondaryUrl;\n        response = undefined;\n        error = undefined;\n        try {\n          logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? \"Primary\" : \"Secondary\"}`);\n          response = await next(request);\n          secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;\n        } catch (e) {\n          if (isRestError(e)) {\n            logger.error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`);\n            error = e;\n          } else {\n            logger.error(`RetryPolicy: Caught error, message: ${getErrorMessage(e)}`);\n            throw e;\n          }\n        }\n        retryAgain = shouldRetry({\n          isPrimaryRetry,\n          attempt,\n          response,\n          error\n        });\n        if (retryAgain) {\n          await delay(calculateDelay(isPrimaryRetry, attempt), request.abortSignal, RETRY_ABORT_ERROR);\n        }\n        attempt++;\n      }\n      if (response) {\n        return response;\n      }\n      throw error ?? new RestError(\"RetryPolicy failed without known error.\");\n    }\n  };\n}","map":{"version":3,"names":["AbortError","isRestError","RestError","getErrorMessage","StorageRetryPolicyType","URLConstants","delay","setURLHost","setURLParameter","logger","storageRetryPolicyName","DEFAULT_RETRY_OPTIONS","maxRetryDelayInMs","maxTries","retryDelayInMs","retryPolicyType","EXPONENTIAL","secondaryHost","tryTimeoutInMs","undefined","retriableErrors","RETRY_ABORT_ERROR","storageRetryPolicy","options","shouldRetry","isPrimaryRetry","attempt","response","error","info","retriableError","name","toUpperCase","includes","message","code","toString","startsWith","statusCode","status","calculateDelay","delayTimeInMs","Math","min","pow","FIXED","random","sendRequest","request","next","url","Parameters","TIMEOUT","String","floor","primaryUrl","secondaryUrl","secondaryHas404","retryAgain","method","e","abortSignal"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@azure\\storage-blob\\src\\policies\\StorageRetryPolicyV2.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortError } from \"@azure/abort-controller\";\nimport type {\n  PipelinePolicy,\n  PipelineRequest,\n  SendRequest,\n  PipelineResponse,\n} from \"@azure/core-rest-pipeline\";\nimport { isRestError, RestError } from \"@azure/core-rest-pipeline\";\nimport { getErrorMessage } from \"@azure/core-util\";\nimport { StorageRetryPolicyType, type StorageRetryOptions } from \"../StorageRetryPolicyFactory.js\";\nimport { URLConstants } from \"../utils/constants.js\";\nimport { delay, setURLHost, setURLParameter } from \"../utils/utils.common.js\";\nimport { logger } from \"../log.js\";\n\n/**\n * Name of the {@link storageRetryPolicy}\n */\nexport const storageRetryPolicyName = \"storageRetryPolicy\";\n\n// Default values of StorageRetryOptions\nconst DEFAULT_RETRY_OPTIONS = {\n  maxRetryDelayInMs: 120 * 1000,\n  maxTries: 4,\n  retryDelayInMs: 4 * 1000,\n  retryPolicyType: StorageRetryPolicyType.EXPONENTIAL,\n  secondaryHost: \"\",\n  tryTimeoutInMs: undefined, // Use server side default timeout strategy\n} as const;\n\nconst retriableErrors = [\n  \"ETIMEDOUT\",\n  \"ESOCKETTIMEDOUT\",\n  \"ECONNREFUSED\",\n  \"ECONNRESET\",\n  \"ENOENT\",\n  \"ENOTFOUND\",\n  \"TIMEOUT\",\n  \"EPIPE\",\n  \"REQUEST_SEND_ERROR\",\n] as const;\n\nconst RETRY_ABORT_ERROR = new AbortError(\"The operation was aborted.\");\n\n/**\n * Retry policy with exponential retry and linear retry implemented.\n */\nexport function storageRetryPolicy(options: StorageRetryOptions = {}): PipelinePolicy {\n  const retryPolicyType = options.retryPolicyType ?? DEFAULT_RETRY_OPTIONS.retryPolicyType;\n  const maxTries = options.maxTries ?? DEFAULT_RETRY_OPTIONS.maxTries;\n  const retryDelayInMs = options.retryDelayInMs ?? DEFAULT_RETRY_OPTIONS.retryDelayInMs;\n  const maxRetryDelayInMs = options.maxRetryDelayInMs ?? DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;\n  const secondaryHost = options.secondaryHost ?? DEFAULT_RETRY_OPTIONS.secondaryHost;\n  const tryTimeoutInMs = options.tryTimeoutInMs ?? DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;\n\n  function shouldRetry({\n    isPrimaryRetry,\n    attempt,\n    response,\n    error,\n  }: {\n    isPrimaryRetry: boolean;\n    attempt: number;\n    response?: PipelineResponse;\n    error?: RestError;\n  }): boolean {\n    if (attempt >= maxTries) {\n      logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);\n      return false;\n    }\n    if (error) {\n      for (const retriableError of retriableErrors) {\n        if (\n          error.name.toUpperCase().includes(retriableError) ||\n          error.message.toUpperCase().includes(retriableError) ||\n          (error.code && error.code.toString().toUpperCase() === retriableError)\n        ) {\n          logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);\n          return true;\n        }\n      }\n      if (\n        error?.code === \"PARSE_ERROR\" &&\n        error?.message.startsWith(`Error \"Error: Unclosed root tag`)\n      ) {\n        logger.info(\n          \"RetryPolicy: Incomplete XML response likely due to service timeout, will retry.\",\n        );\n        return true;\n      }\n    }\n\n    // If attempt was against the secondary & it returned a StatusNotFound (404), then\n    // the resource was not found. This may be due to replication delay. So, in this\n    // case, we'll never try the secondary again for this operation.\n    if (response || error) {\n      const statusCode = response?.status ?? error?.statusCode ?? 0;\n      if (!isPrimaryRetry && statusCode === 404) {\n        logger.info(`RetryPolicy: Secondary access with 404, will retry.`);\n        return true;\n      }\n\n      // Server internal error or server timeout\n      if (statusCode === 503 || statusCode === 500) {\n        logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);\n        return true;\n      }\n    }\n\n    // [Copy source error code] Feature is pending on service side, skip retry on copy source error for now.\n    // if (response) {\n    //   // Retry select Copy Source Error Codes.\n    //   if (response?.status >= 400) {\n    //     const copySourceError = response.headers.get(HeaderConstants.X_MS_CopySourceErrorCode);\n    //     if (copySourceError !== undefined) {\n    //       switch (copySourceError) {\n    //         case \"InternalError\":\n    //         case \"OperationTimedOut\":\n    //         case \"ServerBusy\":\n    //           return true;\n    //       }\n    //     }\n    //   }\n    // }\n\n    return false;\n  }\n  function calculateDelay(isPrimaryRetry: boolean, attempt: number): number {\n    let delayTimeInMs = 0;\n\n    if (isPrimaryRetry) {\n      switch (retryPolicyType) {\n        case StorageRetryPolicyType.EXPONENTIAL:\n          delayTimeInMs = Math.min(\n            (Math.pow(2, attempt - 1) - 1) * retryDelayInMs,\n            maxRetryDelayInMs,\n          );\n          break;\n        case StorageRetryPolicyType.FIXED:\n          delayTimeInMs = retryDelayInMs;\n          break;\n      }\n    } else {\n      delayTimeInMs = Math.random() * 1000;\n    }\n\n    logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);\n    return delayTimeInMs;\n  }\n  return {\n    name: storageRetryPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      // Set the server-side timeout query parameter \"timeout=[seconds]\"\n      if (tryTimeoutInMs) {\n        request.url = setURLParameter(\n          request.url,\n          URLConstants.Parameters.TIMEOUT,\n          String(Math.floor(tryTimeoutInMs / 1000)),\n        );\n      }\n      const primaryUrl = request.url;\n      const secondaryUrl = secondaryHost ? setURLHost(request.url, secondaryHost) : undefined;\n      let secondaryHas404 = false;\n      let attempt = 1;\n      let retryAgain = true;\n      let response: PipelineResponse | undefined;\n      let error: RestError | undefined;\n      while (retryAgain) {\n        const isPrimaryRetry: boolean =\n          secondaryHas404 ||\n          !secondaryUrl ||\n          ![\"GET\", \"HEAD\", \"OPTIONS\"].includes(request.method) ||\n          attempt % 2 === 1;\n        request.url = isPrimaryRetry ? primaryUrl : secondaryUrl!;\n        response = undefined;\n        error = undefined;\n        try {\n          logger.info(\n            `RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? \"Primary\" : \"Secondary\"}`,\n          );\n          response = await next(request);\n          secondaryHas404 = secondaryHas404 || (!isPrimaryRetry && response.status === 404);\n        } catch (e: unknown) {\n          if (isRestError(e)) {\n            logger.error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`);\n            error = e;\n          } else {\n            logger.error(`RetryPolicy: Caught error, message: ${getErrorMessage(e)}`);\n            throw e;\n          }\n        }\n        retryAgain = shouldRetry({ isPrimaryRetry, attempt, response, error });\n        if (retryAgain) {\n          await delay(\n            calculateDelay(isPrimaryRetry, attempt),\n            request.abortSignal,\n            RETRY_ABORT_ERROR,\n          );\n        }\n        attempt++;\n      }\n      if (response) {\n        return response;\n      }\n      throw error ?? new RestError(\"RetryPolicy failed without known error.\");\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}