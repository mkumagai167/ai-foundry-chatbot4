{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * A type guard for a primitive response body.\n * @param value - Value to test\n *\n * @internal\n */\nexport function isPrimitiveBody(value, mapperTypeName) {\n  return mapperTypeName !== \"Composite\" && mapperTypeName !== \"Dictionary\" && (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || mapperTypeName?.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i) !== null || value === undefined || value === null);\n}\nconst validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n/**\n * Returns true if the given string is in ISO 8601 format.\n * @param value - The value to be validated for ISO 8601 duration format.\n * @internal\n */\nexport function isDuration(value) {\n  return validateISODuration.test(value);\n}\nconst validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\n/**\n * Returns true if the provided uuid is valid.\n *\n * @param uuid - The uuid that needs to be validated.\n *\n * @internal\n */\nexport function isValidUuid(uuid) {\n  return validUuidRegex.test(uuid);\n}\n/**\n * Maps the response as follows:\n * - wraps the response body if needed (typically if its type is primitive).\n * - returns null if the combination of the headers and the body is empty.\n * - otherwise, returns the combination of the headers and the body.\n *\n * @param responseObject - a representation of the parsed response\n * @returns the response that will be returned to the user which can be null and/or wrapped\n *\n * @internal\n */\nfunction handleNullableResponseAndWrappableBody(responseObject) {\n  const combinedHeadersAndBody = {\n    ...responseObject.headers,\n    ...responseObject.body\n  };\n  if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {\n    return responseObject.shouldWrapBody ? {\n      body: null\n    } : null;\n  } else {\n    return responseObject.shouldWrapBody ? {\n      ...responseObject.headers,\n      body: responseObject.body\n    } : combinedHeadersAndBody;\n  }\n}\n/**\n * Take a `FullOperationResponse` and turn it into a flat\n * response object to hand back to the consumer.\n * @param fullResponse - The processed response from the operation request\n * @param responseSpec - The response map from the OperationSpec\n *\n * @internal\n */\nexport function flattenResponse(fullResponse, responseSpec) {\n  const parsedHeaders = fullResponse.parsedHeaders;\n  // head methods never have a body, but we return a boolean set to body property\n  // to indicate presence/absence of the resource\n  if (fullResponse.request.method === \"HEAD\") {\n    return {\n      ...parsedHeaders,\n      body: fullResponse.parsedBody\n    };\n  }\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n  const isNullable = Boolean(bodyMapper?.nullable);\n  const expectedBodyTypeName = bodyMapper?.type.name;\n  /** If the body is asked for, we look at the expected body type to handle it */\n  if (expectedBodyTypeName === \"Stream\") {\n    return {\n      ...parsedHeaders,\n      blobBody: fullResponse.blobBody,\n      readableStreamBody: fullResponse.readableStreamBody\n    };\n  }\n  const modelProperties = expectedBodyTypeName === \"Composite\" && bodyMapper.type.modelProperties || {};\n  const isPageableResponse = Object.keys(modelProperties).some(k => modelProperties[k].serializedName === \"\");\n  if (expectedBodyTypeName === \"Sequence\" || isPageableResponse) {\n    const arrayResponse = fullResponse.parsedBody ?? [];\n    for (const key of Object.keys(modelProperties)) {\n      if (modelProperties[key].serializedName) {\n        arrayResponse[key] = fullResponse.parsedBody?.[key];\n      }\n    }\n    if (parsedHeaders) {\n      for (const key of Object.keys(parsedHeaders)) {\n        arrayResponse[key] = parsedHeaders[key];\n      }\n    }\n    return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;\n  }\n  return handleNullableResponseAndWrappableBody({\n    body: fullResponse.parsedBody,\n    headers: parsedHeaders,\n    hasNullableType: isNullable,\n    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)\n  });\n}","map":{"version":3,"names":["isPrimitiveBody","value","mapperTypeName","match","undefined","validateISODuration","isDuration","test","validUuidRegex","isValidUuid","uuid","handleNullableResponseAndWrappableBody","responseObject","combinedHeadersAndBody","headers","body","hasNullableType","Object","getOwnPropertyNames","length","shouldWrapBody","flattenResponse","fullResponse","responseSpec","parsedHeaders","request","method","parsedBody","bodyMapper","isNullable","Boolean","nullable","expectedBodyTypeName","type","name","blobBody","readableStreamBody","modelProperties","isPageableResponse","keys","some","k","serializedName","arrayResponse","key"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@azure\\core-client\\src\\utils.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { CompositeMapper, FullOperationResponse, OperationResponseMap } from \"./interfaces.js\";\n\n/**\n * The union of all possible types for a primitive response body.\n * @internal\n */\nexport type BodyPrimitive = number | string | boolean | Date | Uint8Array | undefined | null;\n\n/**\n * A type guard for a primitive response body.\n * @param value - Value to test\n *\n * @internal\n */\nexport function isPrimitiveBody(value: unknown, mapperTypeName?: string): value is BodyPrimitive {\n  return (\n    mapperTypeName !== \"Composite\" &&\n    mapperTypeName !== \"Dictionary\" &&\n    (typeof value === \"string\" ||\n      typeof value === \"number\" ||\n      typeof value === \"boolean\" ||\n      mapperTypeName?.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i) !==\n        null ||\n      value === undefined ||\n      value === null)\n  );\n}\n\nconst validateISODuration =\n  /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n/**\n * Returns true if the given string is in ISO 8601 format.\n * @param value - The value to be validated for ISO 8601 duration format.\n * @internal\n */\nexport function isDuration(value: string): boolean {\n  return validateISODuration.test(value);\n}\n\nconst validUuidRegex =\n  /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\n\n/**\n * Returns true if the provided uuid is valid.\n *\n * @param uuid - The uuid that needs to be validated.\n *\n * @internal\n */\nexport function isValidUuid(uuid: string): boolean {\n  return validUuidRegex.test(uuid);\n}\n\n/**\n * Representation of parsed response headers and body coupled with information\n * about how to map them:\n * - whether the response body should be wrapped (typically if its type is primitive).\n * - whether the response is nullable so it can be null if the combination of\n *   the headers and the body is empty.\n */\ninterface ResponseObjectWithMetadata {\n  /** whether the mapper allows nullable body */\n  hasNullableType: boolean;\n  /** whether the response's body should be wrapped */\n  shouldWrapBody: boolean;\n  /** parsed headers of the response */\n  headers:\n    | {\n        [key: string]: unknown;\n      }\n    | undefined;\n  /** parsed body of the response */\n  body: any;\n}\n\n/**\n * Maps the response as follows:\n * - wraps the response body if needed (typically if its type is primitive).\n * - returns null if the combination of the headers and the body is empty.\n * - otherwise, returns the combination of the headers and the body.\n *\n * @param responseObject - a representation of the parsed response\n * @returns the response that will be returned to the user which can be null and/or wrapped\n *\n * @internal\n */\nfunction handleNullableResponseAndWrappableBody(\n  responseObject: ResponseObjectWithMetadata,\n): unknown | null {\n  const combinedHeadersAndBody = {\n    ...responseObject.headers,\n    ...responseObject.body,\n  };\n  if (\n    responseObject.hasNullableType &&\n    Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0\n  ) {\n    return responseObject.shouldWrapBody ? { body: null } : null;\n  } else {\n    return responseObject.shouldWrapBody\n      ? {\n          ...responseObject.headers,\n          body: responseObject.body,\n        }\n      : combinedHeadersAndBody;\n  }\n}\n\n/**\n * Take a `FullOperationResponse` and turn it into a flat\n * response object to hand back to the consumer.\n * @param fullResponse - The processed response from the operation request\n * @param responseSpec - The response map from the OperationSpec\n *\n * @internal\n */\nexport function flattenResponse(\n  fullResponse: FullOperationResponse,\n  responseSpec: OperationResponseMap | undefined,\n): unknown {\n  const parsedHeaders = fullResponse.parsedHeaders;\n\n  // head methods never have a body, but we return a boolean set to body property\n  // to indicate presence/absence of the resource\n  if (fullResponse.request.method === \"HEAD\") {\n    return {\n      ...parsedHeaders,\n      body: fullResponse.parsedBody,\n    };\n  }\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n  const isNullable = Boolean(bodyMapper?.nullable);\n  const expectedBodyTypeName = bodyMapper?.type.name;\n\n  /** If the body is asked for, we look at the expected body type to handle it */\n  if (expectedBodyTypeName === \"Stream\") {\n    return {\n      ...parsedHeaders,\n      blobBody: fullResponse.blobBody,\n      readableStreamBody: fullResponse.readableStreamBody,\n    };\n  }\n\n  const modelProperties =\n    (expectedBodyTypeName === \"Composite\" &&\n      (bodyMapper as CompositeMapper).type.modelProperties) ||\n    {};\n  const isPageableResponse = Object.keys(modelProperties).some(\n    (k) => modelProperties[k].serializedName === \"\",\n  );\n  if (expectedBodyTypeName === \"Sequence\" || isPageableResponse) {\n    const arrayResponse: { [key: string]: unknown } =\n      fullResponse.parsedBody ?? ([] as unknown as { [key: string]: unknown });\n\n    for (const key of Object.keys(modelProperties)) {\n      if (modelProperties[key].serializedName) {\n        arrayResponse[key] = fullResponse.parsedBody?.[key];\n      }\n    }\n\n    if (parsedHeaders) {\n      for (const key of Object.keys(parsedHeaders)) {\n        arrayResponse[key] = parsedHeaders[key];\n      }\n    }\n    return isNullable &&\n      !fullResponse.parsedBody &&\n      !parsedHeaders &&\n      Object.getOwnPropertyNames(modelProperties).length === 0\n      ? null\n      : arrayResponse;\n  }\n\n  return handleNullableResponseAndWrappableBody({\n    body: fullResponse.parsedBody,\n    headers: parsedHeaders,\n    hasNullableType: isNullable,\n    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName),\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}