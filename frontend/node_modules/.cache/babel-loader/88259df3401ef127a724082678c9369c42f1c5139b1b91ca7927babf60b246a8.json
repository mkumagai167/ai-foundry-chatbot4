{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTracingClient } from \"@azure/core-tracing\";\nimport { SDK_VERSION } from \"../constants.js\";\nimport { getUserAgentValue } from \"../util/userAgent.js\";\nimport { logger } from \"../log.js\";\nimport { getErrorMessage, isError } from \"@azure/core-util\";\nimport { isRestError } from \"../restError.js\";\nimport { Sanitizer } from \"@typespec/ts-http-runtime/internal/util\";\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy(options = {}) {\n  const userAgentPromise = getUserAgentValue(options.userAgentPrefix);\n  const sanitizer = new Sanitizer({\n    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters\n  });\n  const tracingClient = tryCreateTracingClient();\n  return {\n    name: tracingPolicyName,\n    async sendRequest(request, next) {\n      if (!tracingClient) {\n        return next(request);\n      }\n      const userAgent = await userAgentPromise;\n      const spanAttributes = {\n        \"http.url\": sanitizer.sanitizeUrl(request.url),\n        \"http.method\": request.method,\n        \"http.user_agent\": userAgent,\n        requestId: request.requestId\n      };\n      if (userAgent) {\n        spanAttributes[\"http.user_agent\"] = userAgent;\n      }\n      const {\n        span,\n        tracingContext\n      } = tryCreateSpan(tracingClient, request, spanAttributes) ?? {};\n      if (!span || !tracingContext) {\n        return next(request);\n      }\n      try {\n        const response = await tracingClient.withContext(tracingContext, next, request);\n        tryProcessResponse(span, response);\n        return response;\n      } catch (err) {\n        tryProcessError(span, err);\n        throw err;\n      }\n    }\n  };\n}\nfunction tryCreateTracingClient() {\n  try {\n    return createTracingClient({\n      namespace: \"\",\n      packageName: \"@azure/core-rest-pipeline\",\n      packageVersion: SDK_VERSION\n    });\n  } catch (e) {\n    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\nfunction tryCreateSpan(tracingClient, request, spanAttributes) {\n  try {\n    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n    const {\n      span,\n      updatedOptions\n    } = tracingClient.startSpan(`HTTP ${request.method}`, {\n      tracingOptions: request.tracingOptions\n    }, {\n      spanKind: \"client\",\n      spanAttributes\n    });\n    // If the span is not recording, don't do any more work.\n    if (!span.isRecording()) {\n      span.end();\n      return undefined;\n    }\n    // set headers\n    const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);\n    for (const [key, value] of Object.entries(headers)) {\n      request.headers.set(key, value);\n    }\n    return {\n      span,\n      tracingContext: updatedOptions.tracingOptions.tracingContext\n    };\n  } catch (e) {\n    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\nfunction tryProcessError(span, error) {\n  try {\n    span.setStatus({\n      status: \"error\",\n      error: isError(error) ? error : undefined\n    });\n    if (isRestError(error) && error.statusCode) {\n      span.setAttribute(\"http.status_code\", error.statusCode);\n    }\n    span.end();\n  } catch (e) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\nfunction tryProcessResponse(span, response) {\n  try {\n    span.setAttribute(\"http.status_code\", response.status);\n    const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n    if (serviceRequestId) {\n      span.setAttribute(\"serviceRequestId\", serviceRequestId);\n    }\n    // Per semantic conventions, only set the status to error if the status code is 4xx or 5xx.\n    // Otherwise, the status MUST remain unset.\n    // https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status\n    if (response.status >= 400) {\n      span.setStatus({\n        status: \"error\"\n      });\n    }\n    span.end();\n  } catch (e) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}","map":{"version":3,"names":["createTracingClient","SDK_VERSION","getUserAgentValue","logger","getErrorMessage","isError","isRestError","Sanitizer","tracingPolicyName","tracingPolicy","options","userAgentPromise","userAgentPrefix","sanitizer","additionalAllowedQueryParameters","tracingClient","tryCreateTracingClient","name","sendRequest","request","next","userAgent","spanAttributes","sanitizeUrl","url","method","requestId","span","tracingContext","tryCreateSpan","response","withContext","tryProcessResponse","err","tryProcessError","namespace","packageName","packageVersion","e","warning","undefined","updatedOptions","startSpan","tracingOptions","spanKind","isRecording","end","headers","createRequestHeaders","key","value","Object","entries","set","error","setStatus","status","statusCode","setAttribute","serviceRequestId","get"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@azure\\core-rest-pipeline\\src\\policies\\tracingPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport {\n  type TracingClient,\n  type TracingContext,\n  type TracingSpan,\n  createTracingClient,\n} from \"@azure/core-tracing\";\nimport { SDK_VERSION } from \"../constants.js\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { getUserAgentValue } from \"../util/userAgent.js\";\nimport { logger } from \"../log.js\";\nimport { getErrorMessage, isError } from \"@azure/core-util\";\nimport { isRestError } from \"../restError.js\";\nimport { Sanitizer } from \"@typespec/ts-http-runtime/internal/util\";\n\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n\n/**\n * Options to configure the tracing policy.\n */\nexport interface TracingPolicyOptions {\n  /**\n   * String prefix to add to the user agent logged as metadata\n   * on the generated Span.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n  /**\n   * Query string names whose values will be logged when logging is enabled. By default no\n   * query string values are logged.\n   */\n  additionalAllowedQueryParameters?: string[];\n}\n\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy(options: TracingPolicyOptions = {}): PipelinePolicy {\n  const userAgentPromise = getUserAgentValue(options.userAgentPrefix);\n  const sanitizer = new Sanitizer({\n    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,\n  });\n  const tracingClient = tryCreateTracingClient();\n\n  return {\n    name: tracingPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!tracingClient) {\n        return next(request);\n      }\n\n      const userAgent = await userAgentPromise;\n\n      const spanAttributes = {\n        \"http.url\": sanitizer.sanitizeUrl(request.url),\n        \"http.method\": request.method,\n        \"http.user_agent\": userAgent,\n        requestId: request.requestId,\n      };\n      if (userAgent) {\n        spanAttributes[\"http.user_agent\"] = userAgent;\n      }\n\n      const { span, tracingContext } = tryCreateSpan(tracingClient, request, spanAttributes) ?? {};\n\n      if (!span || !tracingContext) {\n        return next(request);\n      }\n\n      try {\n        const response = await tracingClient.withContext(tracingContext, next, request);\n        tryProcessResponse(span, response);\n        return response;\n      } catch (err: any) {\n        tryProcessError(span, err);\n        throw err;\n      }\n    },\n  };\n}\n\nfunction tryCreateTracingClient(): TracingClient | undefined {\n  try {\n    return createTracingClient({\n      namespace: \"\",\n      packageName: \"@azure/core-rest-pipeline\",\n      packageVersion: SDK_VERSION,\n    });\n  } catch (e: unknown) {\n    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\n\nfunction tryCreateSpan(\n  tracingClient: TracingClient,\n  request: PipelineRequest,\n  spanAttributes: Record<string, unknown>,\n): { span: TracingSpan; tracingContext: TracingContext } | undefined {\n  try {\n    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n    const { span, updatedOptions } = tracingClient.startSpan(\n      `HTTP ${request.method}`,\n      { tracingOptions: request.tracingOptions },\n      {\n        spanKind: \"client\",\n        spanAttributes,\n      },\n    );\n\n    // If the span is not recording, don't do any more work.\n    if (!span.isRecording()) {\n      span.end();\n      return undefined;\n    }\n\n    // set headers\n    const headers = tracingClient.createRequestHeaders(\n      updatedOptions.tracingOptions.tracingContext,\n    );\n    for (const [key, value] of Object.entries(headers)) {\n      request.headers.set(key, value);\n    }\n    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };\n  } catch (e: any) {\n    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\n\nfunction tryProcessError(span: TracingSpan, error: unknown): void {\n  try {\n    span.setStatus({\n      status: \"error\",\n      error: isError(error) ? error : undefined,\n    });\n    if (isRestError(error) && error.statusCode) {\n      span.setAttribute(\"http.status_code\", error.statusCode);\n    }\n    span.end();\n  } catch (e: any) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\n\nfunction tryProcessResponse(span: TracingSpan, response: PipelineResponse): void {\n  try {\n    span.setAttribute(\"http.status_code\", response.status);\n    const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n    if (serviceRequestId) {\n      span.setAttribute(\"serviceRequestId\", serviceRequestId);\n    }\n    // Per semantic conventions, only set the status to error if the status code is 4xx or 5xx.\n    // Otherwise, the status MUST remain unset.\n    // https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status\n    if (response.status >= 400) {\n      span.setStatus({\n        status: \"error\",\n      });\n    }\n    span.end();\n  } catch (e: any) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}