{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\n/**\n * The programmatic identifier of the auxiliaryAuthenticationHeaderPolicy.\n */\nexport const auxiliaryAuthenticationHeaderPolicyName = \"auxiliaryAuthenticationHeaderPolicy\";\nconst AUTHORIZATION_AUXILIARY_HEADER = \"x-ms-authorization-auxiliary\";\nasync function sendAuthorizeRequest(options) {\n  const {\n    scopes,\n    getAccessToken,\n    request\n  } = options;\n  const getTokenOptions = {\n    abortSignal: request.abortSignal,\n    tracingOptions: request.tracingOptions\n  };\n  return (await getAccessToken(scopes, getTokenOptions))?.token ?? \"\";\n}\n/**\n * A policy for external tokens to `x-ms-authorization-auxiliary` header.\n * This header will be used when creating a cross-tenant application we may need to handle authentication requests\n * for resources that are in different tenants.\n * You could see [ARM docs](https://learn.microsoft.com/azure/azure-resource-manager/management/authenticate-multi-tenant) for a rundown of how this feature works\n */\nexport function auxiliaryAuthenticationHeaderPolicy(options) {\n  const {\n    credentials,\n    scopes\n  } = options;\n  const logger = options.logger || coreLogger;\n  const tokenCyclerMap = new WeakMap();\n  return {\n    name: auxiliaryAuthenticationHeaderPolicyName,\n    async sendRequest(request, next) {\n      if (!request.url.toLowerCase().startsWith(\"https://\")) {\n        throw new Error(\"Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.\");\n      }\n      if (!credentials || credentials.length === 0) {\n        logger.info(`${auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);\n        return next(request);\n      }\n      const tokenPromises = [];\n      for (const credential of credentials) {\n        let getAccessToken = tokenCyclerMap.get(credential);\n        if (!getAccessToken) {\n          getAccessToken = createTokenCycler(credential);\n          tokenCyclerMap.set(credential, getAccessToken);\n        }\n        tokenPromises.push(sendAuthorizeRequest({\n          scopes: Array.isArray(scopes) ? scopes : [scopes],\n          request,\n          getAccessToken,\n          logger\n        }));\n      }\n      const auxiliaryTokens = (await Promise.all(tokenPromises)).filter(token => Boolean(token));\n      if (auxiliaryTokens.length === 0) {\n        logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);\n        return next(request);\n      }\n      request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map(token => `Bearer ${token}`).join(\", \"));\n      return next(request);\n    }\n  };\n}","map":{"version":3,"names":["createTokenCycler","logger","coreLogger","auxiliaryAuthenticationHeaderPolicyName","AUTHORIZATION_AUXILIARY_HEADER","sendAuthorizeRequest","options","scopes","getAccessToken","request","getTokenOptions","abortSignal","tracingOptions","token","auxiliaryAuthenticationHeaderPolicy","credentials","tokenCyclerMap","WeakMap","name","sendRequest","next","url","toLowerCase","startsWith","Error","length","info","tokenPromises","credential","get","set","push","Array","isArray","auxiliaryTokens","Promise","all","filter","Boolean","warning","headers","map","join"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@azure\\core-rest-pipeline\\src\\policies\\auxiliaryAuthenticationHeaderPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport type { AzureLogger } from \"@azure/logger\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { type AccessTokenGetter, createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\nimport type { AuthorizeRequestOptions } from \"./bearerTokenAuthenticationPolicy.js\";\n\n/**\n * The programmatic identifier of the auxiliaryAuthenticationHeaderPolicy.\n */\nexport const auxiliaryAuthenticationHeaderPolicyName = \"auxiliaryAuthenticationHeaderPolicy\";\nconst AUTHORIZATION_AUXILIARY_HEADER = \"x-ms-authorization-auxiliary\";\n\n/**\n * Options to configure the auxiliaryAuthenticationHeaderPolicy\n */\nexport interface AuxiliaryAuthenticationHeaderPolicyOptions {\n  /**\n   * TokenCredential list used to get token from auxiliary tenants and\n   * one credential for each tenant the client may need to access\n   */\n  credentials?: TokenCredential[];\n  /**\n   * Scopes depend on the cloud your application runs in\n   */\n  scopes: string | string[];\n  /**\n   * A logger can be sent for debugging purposes.\n   */\n  logger?: AzureLogger;\n}\n\nasync function sendAuthorizeRequest(options: AuthorizeRequestOptions): Promise<string> {\n  const { scopes, getAccessToken, request } = options;\n  const getTokenOptions: GetTokenOptions = {\n    abortSignal: request.abortSignal,\n    tracingOptions: request.tracingOptions,\n  };\n\n  return (await getAccessToken(scopes, getTokenOptions))?.token ?? \"\";\n}\n\n/**\n * A policy for external tokens to `x-ms-authorization-auxiliary` header.\n * This header will be used when creating a cross-tenant application we may need to handle authentication requests\n * for resources that are in different tenants.\n * You could see [ARM docs](https://learn.microsoft.com/azure/azure-resource-manager/management/authenticate-multi-tenant) for a rundown of how this feature works\n */\nexport function auxiliaryAuthenticationHeaderPolicy(\n  options: AuxiliaryAuthenticationHeaderPolicyOptions,\n): PipelinePolicy {\n  const { credentials, scopes } = options;\n  const logger = options.logger || coreLogger;\n  const tokenCyclerMap = new WeakMap<TokenCredential, AccessTokenGetter>();\n\n  return {\n    name: auxiliaryAuthenticationHeaderPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.url.toLowerCase().startsWith(\"https://\")) {\n        throw new Error(\n          \"Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.\",\n        );\n      }\n      if (!credentials || credentials.length === 0) {\n        logger.info(\n          `${auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`,\n        );\n        return next(request);\n      }\n\n      const tokenPromises: Promise<string>[] = [];\n      for (const credential of credentials) {\n        let getAccessToken = tokenCyclerMap.get(credential);\n        if (!getAccessToken) {\n          getAccessToken = createTokenCycler(credential);\n          tokenCyclerMap.set(credential, getAccessToken);\n        }\n        tokenPromises.push(\n          sendAuthorizeRequest({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            request,\n            getAccessToken,\n            logger,\n          }),\n        );\n      }\n      const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));\n      if (auxiliaryTokens.length === 0) {\n        logger.warning(\n          `None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`,\n        );\n        return next(request);\n      }\n      request.headers.set(\n        AUTHORIZATION_AUXILIARY_HEADER,\n        auxiliaryTokens.map((token) => `Bearer ${token}`).join(\", \"),\n      );\n\n      return next(request);\n    },\n  };\n}\n"],"mappings":"AAAA;AACA;AAMA,SAAiCA,iBAAiB,QAAQ,wBAAwB;AAClF,SAASC,MAAM,IAAIC,UAAU,QAAQ,WAAW;AAGhD;;;AAGA,OAAO,MAAMC,uCAAuC,GAAG,qCAAqC;AAC5F,MAAMC,8BAA8B,GAAG,8BAA8B;AAqBrE,eAAeC,oBAAoBA,CAACC,OAAgC;EAClE,MAAM;IAAEC,MAAM;IAAEC,cAAc;IAAEC;EAAO,CAAE,GAAGH,OAAO;EACnD,MAAMI,eAAe,GAAoB;IACvCC,WAAW,EAAEF,OAAO,CAACE,WAAW;IAChCC,cAAc,EAAEH,OAAO,CAACG;GACzB;EAED,OAAO,CAAC,MAAMJ,cAAc,CAACD,MAAM,EAAEG,eAAe,CAAC,GAAGG,KAAK,IAAI,EAAE;AACrE;AAEA;;;;;;AAMA,OAAM,SAAUC,mCAAmCA,CACjDR,OAAmD;EAEnD,MAAM;IAAES,WAAW;IAAER;EAAM,CAAE,GAAGD,OAAO;EACvC,MAAML,MAAM,GAAGK,OAAO,CAACL,MAAM,IAAIC,UAAU;EAC3C,MAAMc,cAAc,GAAG,IAAIC,OAAO,EAAsC;EAExE,OAAO;IACLC,IAAI,EAAEf,uCAAuC;IAC7C,MAAMgB,WAAWA,CAACV,OAAwB,EAAEW,IAAiB;MAC3D,IAAI,CAACX,OAAO,CAACY,GAAG,CAACC,WAAW,EAAE,CAACC,UAAU,CAAC,UAAU,CAAC,EAAE;QACrD,MAAM,IAAIC,KAAK,CACb,2GAA2G,CAC5G;MACH;MACA,IAAI,CAACT,WAAW,IAAIA,WAAW,CAACU,MAAM,KAAK,CAAC,EAAE;QAC5CxB,MAAM,CAACyB,IAAI,CACT,GAAGvB,uCAAuC,mDAAmD,CAC9F;QACD,OAAOiB,IAAI,CAACX,OAAO,CAAC;MACtB;MAEA,MAAMkB,aAAa,GAAsB,EAAE;MAC3C,KAAK,MAAMC,UAAU,IAAIb,WAAW,EAAE;QACpC,IAAIP,cAAc,GAAGQ,cAAc,CAACa,GAAG,CAACD,UAAU,CAAC;QACnD,IAAI,CAACpB,cAAc,EAAE;UACnBA,cAAc,GAAGR,iBAAiB,CAAC4B,UAAU,CAAC;UAC9CZ,cAAc,CAACc,GAAG,CAACF,UAAU,EAAEpB,cAAc,CAAC;QAChD;QACAmB,aAAa,CAACI,IAAI,CAChB1B,oBAAoB,CAAC;UACnBE,MAAM,EAAEyB,KAAK,CAACC,OAAO,CAAC1B,MAAM,CAAC,GAAGA,MAAM,GAAG,CAACA,MAAM,CAAC;UACjDE,OAAO;UACPD,cAAc;UACdP;SACD,CAAC,CACH;MACH;MACA,MAAMiC,eAAe,GAAG,CAAC,MAAMC,OAAO,CAACC,GAAG,CAACT,aAAa,CAAC,EAAEU,MAAM,CAAExB,KAAK,IAAKyB,OAAO,CAACzB,KAAK,CAAC,CAAC;MAC5F,IAAIqB,eAAe,CAACT,MAAM,KAAK,CAAC,EAAE;QAChCxB,MAAM,CAACsC,OAAO,CACZ,2CAA2CnC,8BAA8B,0BAA0B,CACpG;QACD,OAAOgB,IAAI,CAACX,OAAO,CAAC;MACtB;MACAA,OAAO,CAAC+B,OAAO,CAACV,GAAG,CACjB1B,8BAA8B,EAC9B8B,eAAe,CAACO,GAAG,CAAE5B,KAAK,IAAK,UAAUA,KAAK,EAAE,CAAC,CAAC6B,IAAI,CAAC,IAAI,CAAC,CAC7D;MAED,OAAOtB,IAAI,CAACX,OAAO,CAAC;IACtB;GACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}