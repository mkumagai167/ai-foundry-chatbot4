{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { log } from \"./log.js\";\nconst debugEnvVariable = typeof process !== \"undefined\" && process.env && process.env.DEBUG || undefined;\nlet enabledString;\nlet enabledNamespaces = [];\nlet skippedNamespaces = [];\nconst debuggers = [];\nif (debugEnvVariable) {\n  enable(debugEnvVariable);\n}\nconst debugObj = Object.assign(namespace => {\n  return createDebugger(namespace);\n}, {\n  enable,\n  enabled,\n  disable,\n  log\n});\nfunction enable(namespaces) {\n  enabledString = namespaces;\n  enabledNamespaces = [];\n  skippedNamespaces = [];\n  const namespaceList = namespaces.split(\",\").map(ns => ns.trim());\n  for (const ns of namespaceList) {\n    if (ns.startsWith(\"-\")) {\n      skippedNamespaces.push(ns.substring(1));\n    } else {\n      enabledNamespaces.push(ns);\n    }\n  }\n  for (const instance of debuggers) {\n    instance.enabled = enabled(instance.namespace);\n  }\n}\nfunction enabled(namespace) {\n  if (namespace.endsWith(\"*\")) {\n    return true;\n  }\n  for (const skipped of skippedNamespaces) {\n    if (namespaceMatches(namespace, skipped)) {\n      return false;\n    }\n  }\n  for (const enabledNamespace of enabledNamespaces) {\n    if (namespaceMatches(namespace, enabledNamespace)) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Given a namespace, check if it matches a pattern.\n * Patterns only have a single wildcard character which is *.\n * The behavior of * is that it matches zero or more other characters.\n */\nfunction namespaceMatches(namespace, patternToMatch) {\n  // simple case, no pattern matching required\n  if (patternToMatch.indexOf(\"*\") === -1) {\n    return namespace === patternToMatch;\n  }\n  let pattern = patternToMatch;\n  // normalize successive * if needed\n  if (patternToMatch.indexOf(\"**\") !== -1) {\n    const patternParts = [];\n    let lastCharacter = \"\";\n    for (const character of patternToMatch) {\n      if (character === \"*\" && lastCharacter === \"*\") {\n        continue;\n      } else {\n        lastCharacter = character;\n        patternParts.push(character);\n      }\n    }\n    pattern = patternParts.join(\"\");\n  }\n  let namespaceIndex = 0;\n  let patternIndex = 0;\n  const patternLength = pattern.length;\n  const namespaceLength = namespace.length;\n  let lastWildcard = -1;\n  let lastWildcardNamespace = -1;\n  while (namespaceIndex < namespaceLength && patternIndex < patternLength) {\n    if (pattern[patternIndex] === \"*\") {\n      lastWildcard = patternIndex;\n      patternIndex++;\n      if (patternIndex === patternLength) {\n        // if wildcard is the last character, it will match the remaining namespace string\n        return true;\n      }\n      // now we let the wildcard eat characters until we match the next literal in the pattern\n      while (namespace[namespaceIndex] !== pattern[patternIndex]) {\n        namespaceIndex++;\n        // reached the end of the namespace without a match\n        if (namespaceIndex === namespaceLength) {\n          return false;\n        }\n      }\n      // now that we have a match, let's try to continue on\n      // however, it's possible we could find a later match\n      // so keep a reference in case we have to backtrack\n      lastWildcardNamespace = namespaceIndex;\n      namespaceIndex++;\n      patternIndex++;\n      continue;\n    } else if (pattern[patternIndex] === namespace[namespaceIndex]) {\n      // simple case: literal pattern matches so keep going\n      patternIndex++;\n      namespaceIndex++;\n    } else if (lastWildcard >= 0) {\n      // special case: we don't have a literal match, but there is a previous wildcard\n      // which we can backtrack to and try having the wildcard eat the match instead\n      patternIndex = lastWildcard + 1;\n      namespaceIndex = lastWildcardNamespace + 1;\n      // we've reached the end of the namespace without a match\n      if (namespaceIndex === namespaceLength) {\n        return false;\n      }\n      // similar to the previous logic, let's keep going until we find the next literal match\n      while (namespace[namespaceIndex] !== pattern[patternIndex]) {\n        namespaceIndex++;\n        if (namespaceIndex === namespaceLength) {\n          return false;\n        }\n      }\n      lastWildcardNamespace = namespaceIndex;\n      namespaceIndex++;\n      patternIndex++;\n      continue;\n    } else {\n      return false;\n    }\n  }\n  const namespaceDone = namespaceIndex === namespace.length;\n  const patternDone = patternIndex === pattern.length;\n  // this is to detect the case of an unneeded final wildcard\n  // e.g. the pattern `ab*` should match the string `ab`\n  const trailingWildCard = patternIndex === pattern.length - 1 && pattern[patternIndex] === \"*\";\n  return namespaceDone && (patternDone || trailingWildCard);\n}\nfunction disable() {\n  const result = enabledString || \"\";\n  enable(\"\");\n  return result;\n}\nfunction createDebugger(namespace) {\n  const newDebugger = Object.assign(debug, {\n    enabled: enabled(namespace),\n    destroy,\n    log: debugObj.log,\n    namespace,\n    extend\n  });\n  function debug(...args) {\n    if (!newDebugger.enabled) {\n      return;\n    }\n    if (args.length > 0) {\n      args[0] = `${namespace} ${args[0]}`;\n    }\n    newDebugger.log(...args);\n  }\n  debuggers.push(newDebugger);\n  return newDebugger;\n}\nfunction destroy() {\n  const index = debuggers.indexOf(this);\n  if (index >= 0) {\n    debuggers.splice(index, 1);\n    return true;\n  }\n  return false;\n}\nfunction extend(namespace) {\n  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);\n  newDebugger.log = this.log;\n  return newDebugger;\n}\nexport default debugObj;","map":{"version":3,"names":["log","debugEnvVariable","process","env","DEBUG","undefined","enabledString","enabledNamespaces","skippedNamespaces","debuggers","enable","debugObj","Object","assign","namespace","createDebugger","enabled","disable","namespaces","namespaceList","split","map","ns","trim","startsWith","push","substring","instance","endsWith","skipped","namespaceMatches","enabledNamespace","patternToMatch","indexOf","pattern","patternParts","lastCharacter","character","join","namespaceIndex","patternIndex","patternLength","length","namespaceLength","lastWildcard","lastWildcardNamespace","namespaceDone","patternDone","trailingWildCard","result","newDebugger","debug","destroy","extend","args","index","splice"],"sources":["C:\\Users\\M.Kumagai\\Documents\\React\\ai-foundry-chatbot4\\frontend\\node_modules\\@typespec\\ts-http-runtime\\src\\logger\\debug.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { log } from \"./log.js\";\n\n/**\n * A simple mechanism for enabling logging.\n * Intended to mimic the publicly available `debug` package.\n */\nexport interface Debug {\n  /**\n   * Creates a new logger with the given namespace.\n   */\n  (namespace: string): Debugger;\n  /**\n   * The default log method (defaults to console)\n   */\n  log: (...args: any[]) => void;\n  /**\n   * Enables a particular set of namespaces.\n   * To enable multiple separate them with commas, e.g. \"info,debug\".\n   * Supports wildcards, e.g. \"typeSpecRuntime:*\"\n   * Supports skip syntax, e.g. \"typeSpecRuntime:*,-typeSpecRuntime:storage:*\" will enable\n   * everything under typeSpecRuntime except for things under typeSpecRuntime:storage.\n   */\n  enable: (namespaces: string) => void;\n  /**\n   * Checks if a particular namespace is enabled.\n   */\n  enabled: (namespace: string) => boolean;\n  /**\n   * Disables all logging, returns what was previously enabled.\n   */\n  disable: () => string;\n}\n\n/**\n * A log function that can be dynamically enabled and redirected.\n */\nexport interface Debugger {\n  /**\n   * Logs the given arguments to the `log` method.\n   */\n  (...args: any[]): void;\n  /**\n   * True if this logger is active and logging.\n   */\n  enabled: boolean;\n  /**\n   * Used to cleanup/remove this logger.\n   */\n  destroy: () => boolean;\n  /**\n   * The current log method. Can be overridden to redirect output.\n   */\n  log: (...args: any[]) => void;\n  /**\n   * The namespace of this logger.\n   */\n  namespace: string;\n  /**\n   * Extends this logger with a child namespace.\n   * Namespaces are separated with a ':' character.\n   */\n  extend: (namespace: string) => Debugger;\n}\n\nconst debugEnvVariable =\n  (typeof process !== \"undefined\" && process.env && process.env.DEBUG) || undefined;\n\nlet enabledString: string | undefined;\nlet enabledNamespaces: string[] = [];\nlet skippedNamespaces: string[] = [];\nconst debuggers: Debugger[] = [];\n\nif (debugEnvVariable) {\n  enable(debugEnvVariable);\n}\n\nconst debugObj: Debug = Object.assign(\n  (namespace: string): Debugger => {\n    return createDebugger(namespace);\n  },\n  {\n    enable,\n    enabled,\n    disable,\n    log,\n  },\n);\n\nfunction enable(namespaces: string): void {\n  enabledString = namespaces;\n  enabledNamespaces = [];\n  skippedNamespaces = [];\n  const namespaceList = namespaces.split(\",\").map((ns) => ns.trim());\n  for (const ns of namespaceList) {\n    if (ns.startsWith(\"-\")) {\n      skippedNamespaces.push(ns.substring(1));\n    } else {\n      enabledNamespaces.push(ns);\n    }\n  }\n  for (const instance of debuggers) {\n    instance.enabled = enabled(instance.namespace);\n  }\n}\n\nfunction enabled(namespace: string): boolean {\n  if (namespace.endsWith(\"*\")) {\n    return true;\n  }\n\n  for (const skipped of skippedNamespaces) {\n    if (namespaceMatches(namespace, skipped)) {\n      return false;\n    }\n  }\n  for (const enabledNamespace of enabledNamespaces) {\n    if (namespaceMatches(namespace, enabledNamespace)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Given a namespace, check if it matches a pattern.\n * Patterns only have a single wildcard character which is *.\n * The behavior of * is that it matches zero or more other characters.\n */\nfunction namespaceMatches(namespace: string, patternToMatch: string): boolean {\n  // simple case, no pattern matching required\n  if (patternToMatch.indexOf(\"*\") === -1) {\n    return namespace === patternToMatch;\n  }\n\n  let pattern = patternToMatch;\n\n  // normalize successive * if needed\n  if (patternToMatch.indexOf(\"**\") !== -1) {\n    const patternParts = [];\n    let lastCharacter = \"\";\n    for (const character of patternToMatch) {\n      if (character === \"*\" && lastCharacter === \"*\") {\n        continue;\n      } else {\n        lastCharacter = character;\n        patternParts.push(character);\n      }\n    }\n    pattern = patternParts.join(\"\");\n  }\n\n  let namespaceIndex = 0;\n  let patternIndex = 0;\n  const patternLength = pattern.length;\n  const namespaceLength = namespace.length;\n  let lastWildcard = -1;\n  let lastWildcardNamespace = -1;\n\n  while (namespaceIndex < namespaceLength && patternIndex < patternLength) {\n    if (pattern[patternIndex] === \"*\") {\n      lastWildcard = patternIndex;\n      patternIndex++;\n      if (patternIndex === patternLength) {\n        // if wildcard is the last character, it will match the remaining namespace string\n        return true;\n      }\n      // now we let the wildcard eat characters until we match the next literal in the pattern\n      while (namespace[namespaceIndex] !== pattern[patternIndex]) {\n        namespaceIndex++;\n        // reached the end of the namespace without a match\n        if (namespaceIndex === namespaceLength) {\n          return false;\n        }\n      }\n\n      // now that we have a match, let's try to continue on\n      // however, it's possible we could find a later match\n      // so keep a reference in case we have to backtrack\n      lastWildcardNamespace = namespaceIndex;\n      namespaceIndex++;\n      patternIndex++;\n      continue;\n    } else if (pattern[patternIndex] === namespace[namespaceIndex]) {\n      // simple case: literal pattern matches so keep going\n      patternIndex++;\n      namespaceIndex++;\n    } else if (lastWildcard >= 0) {\n      // special case: we don't have a literal match, but there is a previous wildcard\n      // which we can backtrack to and try having the wildcard eat the match instead\n      patternIndex = lastWildcard + 1;\n      namespaceIndex = lastWildcardNamespace + 1;\n      // we've reached the end of the namespace without a match\n      if (namespaceIndex === namespaceLength) {\n        return false;\n      }\n      // similar to the previous logic, let's keep going until we find the next literal match\n      while (namespace[namespaceIndex] !== pattern[patternIndex]) {\n        namespaceIndex++;\n        if (namespaceIndex === namespaceLength) {\n          return false;\n        }\n      }\n      lastWildcardNamespace = namespaceIndex;\n      namespaceIndex++;\n      patternIndex++;\n      continue;\n    } else {\n      return false;\n    }\n  }\n\n  const namespaceDone = namespaceIndex === namespace.length;\n  const patternDone = patternIndex === pattern.length;\n  // this is to detect the case of an unneeded final wildcard\n  // e.g. the pattern `ab*` should match the string `ab`\n  const trailingWildCard = patternIndex === pattern.length - 1 && pattern[patternIndex] === \"*\";\n  return namespaceDone && (patternDone || trailingWildCard);\n}\n\nfunction disable(): string {\n  const result = enabledString || \"\";\n  enable(\"\");\n  return result;\n}\n\nfunction createDebugger(namespace: string): Debugger {\n  const newDebugger: Debugger = Object.assign(debug, {\n    enabled: enabled(namespace),\n    destroy,\n    log: debugObj.log,\n    namespace,\n    extend,\n  });\n\n  function debug(...args: any[]): void {\n    if (!newDebugger.enabled) {\n      return;\n    }\n    if (args.length > 0) {\n      args[0] = `${namespace} ${args[0]}`;\n    }\n    newDebugger.log(...args);\n  }\n\n  debuggers.push(newDebugger);\n\n  return newDebugger;\n}\n\nfunction destroy(this: Debugger): boolean {\n  const index = debuggers.indexOf(this);\n  if (index >= 0) {\n    debuggers.splice(index, 1);\n    return true;\n  }\n  return false;\n}\n\nfunction extend(this: Debugger, namespace: string): Debugger {\n  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);\n  newDebugger.log = this.log;\n  return newDebugger;\n}\n\nexport default debugObj;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}